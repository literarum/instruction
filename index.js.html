<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="shortcut icon" href="/instruction/img/ico.png" type="image/png">
    <link rel="shortcut icon" href="/img/ico.png" type="image/png">
    <link rel="stylesheet" href="/instruction/css/normalize.min.css">
    <link rel="stylesheet" href="../css/normalize.min.css">
    <link rel="stylesheet" type="text/css" href="../css/introduction.css">
    <link rel="stylesheet" type="text/css" href="/instruction/css/introduction.css">
    <script src="/js/jquery.min.js"></script>
    <script src="/instruction/js/jquery.min.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Caveat&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://ajax.googleapis.com/ajax/libs/jqueryui/1.13.2/themes/smoothness/jquery-ui.css">
    <script src="https://ajax.googleapis.com/ajax/libs/jqueryui/1.13.2/jquery-ui.min.js"></script>
    <script src="templates/js/lightGallery.js"></script>
    <script>
        $(function(){
            $('a[href^="#"]').click(function(){
         		var target = $(this).attr('href');
         	    $('html, body').animate({scrollTop: $(target).offset().top}, 500);
         		return false;
            });
        });
    </script>
    <style>
        .clicked {
            color: rgba(0, 0, 0, 1);
            text-shadow: 0 0 10px #fff, 1px 1px 1px #fff;
        }
    </style>
    <title>JavaScript</title>
</head>

<body id="body">
    <div class="progress-bar" id="progressBar"></div>
    <input type="checkbox" id="nav-toggle" hidden>
    <nav class="nav">
        <ul>
            <li style="margin-left: 1rem; font-size: 24px; color:rgba(0, 0, 0, .8)">Навигация по сайту</li>
            <li><a href="/instruction/index.html">Главная</a></li>
            <li><a href="/instruction/old.index.html">Оригинал</a></li>
            <li><a href="/instruction/index.html5.html">HTML5</a></li>
            <li><a href="/instruction/index.css.html">CSS</a></li>
            <li><a href="/instruction/index.js.html">JavaScript</a></li>
            <li><a href="/instruction/index.jquery.html">jQuery</a></li>
            <li><a href="/instruction/index.bootstrap.html">Bootstrap</a></li>
            <li style="margin-left: 1rem; font-size: 24px; color:rgba(0, 0, 0, .8)">Полезные ссылки</li>
            <li><a href="https://www.w3schools.com/">W3Schools</a></li>
            <li><a href="https://developer.mozilla.org/ru/">MDN</a></li>
            <li><a href="https://html5book.ru/">HTML5Book</a></li>
        </ul>
    </nav>
    <div class="mask-content"></div>
    <header class="header">
        <label for="nav-toggle" class="nav-toggle" onclick></label>
        <ul class="header__list">
            <li class="header__item"><a class="hover" data-title="Перейти во введение" href="/instruction/index.html" class="header__link">Главная</a></li>
            <li class="header__item"><a class="hover" data-title="Старая версия инструкции" href="/instruction/old.index.html" class="header__link">Оригинал</a></li>
            <div class="dropdown-links">
                <button class="dropbtn-links">Cсылки</button>
                <div class="dropdown-content-links">
                    <a href="https://www.w3schools.com/" target="_blank">W3Schools</a>
                    <a href="https://developer.mozilla.org/ru/" target="_blank">MDN</a>
                    <a href="https://html5book.ru/" target="_blank">HTML5Book</a>
                </div>
            </div>
            <li class="header__item">
                <div class="dropdown">
                <button class="dropbtn clicked">Разделы</button>
                <div class="dropdown-content">
                    <a href="/instruction/index.html5.html">HTML5</a>
                    <a href="/instruction/index.css.html">CSS</a>
                    <button onclick="window.location.href='/instruction/index.js.html'" class="dropbtn dropbtn__jQuery clicked">JavaScript</button>
                    <div class="dropdown__jQuery__div">
                        <a class="jquery__a" href="index.jquery.html">jQuery</a>
                    </div>
                    <a href="#">Bootstrap</a>
                </div>
            </div></li>
        </ul>
        <div class="up__down">
            <a class="hover" data-title="Переместиться в самый верх страницы" href="#top">Наверх</a>
            <a class="hover" data-title="Переместиться в самый низ страницы" href="#bottom">Вниз</a>
            <div id="tooltip"></div>
        </div>
    <p class="slogan">Make Web-Sites not War</p>
    <div class="logo">
        <img src="/instruction/img/logo.png">
    </div>
</header>
    <div id="top">&nbsp;</div>
    <div id="container" class="container">
        <div class="table__of__contents">
            <h1 class="contents__header">Оглавление</h1>
            <ul class="list__tableOf">
                <li><a href="#general">Общие положения</a></li>
                <li><a href="#variables">Переменные</a></li>
                <li><a href="#built__methods">Встроенные методы</a></li>
                <li><a href="#order__operators">Порядок операторов</a></li>
                <li><a href="#if__else">Условные операторы. If/Else</a></li>
                <li><a href="#ternary">Тернарный оператор</a></li>
                <li><a href="#switch">Оператор Switch</a></li>
                <li><a href="#while">Цикл While</a></li>
                <li><a href="#for">Цикл for</a></li>
                <li><a href="#functions">Функции</a></li>
                <li><a href="#function_param">Параметры (аргументы) функции</a></li>
                <li><a href="#function__returns">Возвращаемые значения функций</a></li>
                <li><a href="#statements">Statements vs. Expressions</a></li>
                <li><a href="#func_ex">Различные примеры реализации функций и рефакторинг</a></li>
                <li><a href="#area__of__vis">Область видимости переменных</a></li>
                <li><a href="#massives">Массивы</a></li>
                <li><a href="#massive__methods">Методы массивов</a></li>
                <li><a href="#objects">Объекты</a></li>
                <li><a href="#objects__massives">Массивы или объекты</a></li>
                <li><a href="#objects__methods">Методы объектов</a></li>
                <li><a href="#this">'this' в методе объекта</a></li>
                <li><a href="#dom"></a>DOM</li>
                <li><a href="#dom__selectors">DOM. Селекторы</a></li>
                <li><a href="#dom__changing__content">DOM. Изменение контента</a></li>
                <li><a href="#dom__changing__attributes">DOM. Изменение контента</a></li>
                <li><a href="#dom__events">DOM. Events</a></li>
                <li><a href="#js__game">Финал JS. Игра на реакцию</a></li>
            </ul>
        </div>
        <h1 class="tom__name">Том III. JavaScript</h1>
        <div id="general">&nbsp;</div>
        <h1 class="main__head">Общие положения</h1>
        <p class="main__par">
            <span class="tab">Итак</span>, JavaScript – это язык программирования, позволяющий достичь наивысшей производительности HTML-станиц, наполняя их анимацией, интерактивными элементами и динамическими визуальными эффектами. Язык JS способен сделать веб-страницы более полезными, обеспечивая немедленную обратную связь, то есть, для изменений не требует перезагрузки страницы. 
            <span class="tab">Если</span> вы помните, в HTML документе мы можем создавать кнопки. Делается это с помощью зеркального тега <strong>&lt;button&gt;</strong>. Этот тег сам по себе является простым шаблоном и не обладает никакой функциональностью без нужной настройки. Соответственно, чтобы при нажатии добавленной нами кнопки выполнялся какой-то код, тегу <strong>&lt;button&gt;</strong>, к примеру, можно присвоить атрибут <strong>'onclick'</strong>. Внутри этого атрибута можно указать код JavaScript inline-способом, то есть, без создания дополнительного документа с кодом. Самое элементарное, что мы сейчас можем сделать, просто для понимания – это по нажатию кнопки вывести какое-то сообщение. Выглядеть это будет следующим образом: <strong>&lt;button onclick="alert('Hello world!')"&gt;Поприветствуй мир!&lt;/button&gt;</strong>. Еще один абстрактный пример: точно таким же inline-способом (и всеми остальными, разумеется, тоже), с помощью JavaScript можно отправлять, к примеру, и сообщения в консоль браузера. Делается это с помощью кода <strong class="break">&lt;button onclick="console.log('Hello Console!')"&gt;Поприветствуй консоль!&lt;button&gt;</strong>. По нажатию на <button class="button" id="button" onclick="alert('Не тыкай!'), console.log('Hello Console!')">эту</button> кнопку вы получите alert-сообщение в окне браузера и вывод сообщения в консоль.
        </p>
        <div class="faq__any faq__flex">
            <img src="/instruction/img/faq.png">
            <p>*для справки: способы помещения кода JavaScript и взаимодействия его со страницей ничем не отличается от способов работы c CSS. У него точно так же есть способы <strong>inline</strong> – внутристрочный, <strong>internal</strong> – внутри HTML кода (документа), но отдельным блоком кода и <strong>external</strong> – создавая отдельный документ под JavaScript с расширением <strong>'js'</strong>.<br>
            <span class="tab">Одним</span> из способов активировать код при загрузке страницы – это поместить его в HTML методом <strong>internal</strong>, код по умолчанию будет выполняться при загрузке страницы. К примеру, той же командой <strong>'alert'</strong> из JavaScript можно уведомить пользователя о сборе файлов Cookies при входе на страницу.
        </div>
        <div id="variables">&nbsp;</div>
        <h1 class="main__head">Переменные в JavaScript</h1>
        <p class="main__par">
            <span class="tab">Как</span> и в любом другом языке программирования в языке JavaScript есть переменные и типы данных. Есть несколько видов переменных: string, number, boolean, undefined и null.<br><br>
            <span class="tab"><strong>Переменные</strong></span> являются неким логическим контейнером для хранения в них неких данных, к которым в дальнейшем можно обращаться. Переменные в языке JavaScript декларируются значением <strong>'let'</strong> (от англ. пусть). К слову, есть и устаревшее значение var – variable (от англ. переменная), которое сейчас не используется. Далее переменной присваивается значение (имя). Выглядит это так: <strong>'var firstName = "Vasya"'</strong>. То есть, грубо говоря, мы объявляем: пусть значение <strong>'firstName'</strong> (то есть, в данном случае, имя человека) будет равняться (приравниваться) к значению <strong>'Vasya'</strong>, то есть, теперь мы ввели переменную <strong>'firstName'</strong>, которая равна <strong>'Vasya'</strong>. Далее, после объявления переменной, мы можем на эту переменную сослаться, просто записывая в коде <strong>'firstName'</strong>. Например, как и раньше, вывести в консоль. Выглядеть это будет следующим образом: <strong>'console.log(firstName)'</strong>, после чего мы получим выведенное в консоль ранее установленное значение переменной – <strong>'Vasya'</strong>. Концепция переменных очень важна и позволяет значительно сократить код. Представьте себе самое длинное математическое выражение, с которым в дальнейшем коде вам нужно работать. Представьте, что оно еще и не одно. Так вот идея в том, вто вы можете поместить каждое из этих выражений в переменные и затем использовать их в виде одного короткого слова.<br><br>
            <span class="tab">Значения</span> переменных после присваивания им одних значений могут быть переписаны на другие значения. Для этого уже не нужно заново создавать "коробку" с переменной, а достаточно просто написать её ранее объявленное название и через знак приравнивания прописать ее новое значение, например: <strong>'firstName = Petya;'</strong>. После объявления необходимых переменных их можно использовать в каких-то выражениях. Для этого объявим еще одну переменную – <strong>'var lastName = "Ivanov";'</strong>. Теперь, после того, как у нас есть некоторый набор переменных, их можно, к примеру, сложить. Для этого объявим еще одну переменную – <strong>'var fullName = firstName + lastName;'</strong>. Переменные в этом случае уже пишуться <strong>без кавычек</strong>! Как видно из кода, взаимодействие этих переменных осуществялется через операцию сложения. То есть, таким образом, мы получаем сумму двух переменных, в данном случае переменной <strong>'firstName'</strong> и <strong>'lastName'</strong>, то есть имя и фамилию вместе, что в сумме представляет собой ранее объявленную переменную <strong>'fullName'</strong>. К типу переменных, о которых сейчас была речь, относятся <strong>string</strong>, <strong>number</strong>.<br><br>
            <span class="tab">Следующим</span> типом переменных является тип <strong>boolean</strong>. Переменная типа <strong>boolean</strong> являет собой логический тип данных, который принимает только два значения: <strong>'true'</strong> или <strong>'false'</strong> – ложь или правда.
        </p>
        <div class="faq__any faq__flex">
               <img src="/instruction/img/faq.png">
               <p>*для справки: логический тип данных <strong>'boolean'</strong> точно так же объявляется уже описанным "контейнером" <strong>'var'</strong>, но после его объявялния ему придается значение <strong>'true'</strong> или <strong>'false'</strong>. Кроме того, логический тип данных <strong>'boolean'</strong>, в отличие от многих остальных языков программирования, можно так же как и любую другую переменную переписать в другое значение. То есть, если раньше это была логическая переменная со значениями <strong>'true'</strong> и <strong>'false'</strong>, то после переписывания она легко может стать переменной <strong>'string'</strong> типа.</p>
        </div>
        <p class="main__par">
            <span class="tab">Следующий</span> тип переменных – <strong>undefined</strong> (от англ. неопределенный). Это переменная с неопределенным (не заданным) значением. То есть, если в обычных видах переменных мы указывали <strong>'let *название_переменной* = *значение переменной*';</strong>, то в случае с <strong>'undefined'</strong> у нас будет задаваться только имя переменной, без её значения – <strong>'var *имя_переменной*';</strong>. В этом случае, результат обращения к этой переменной по имени будет рождать результат со значением <strong>'undefined'</strong>, что наглядно видно, например, в консоли браузера.<br><br>
            <span class="tab">И</span> последняя переменная – это <strong>'null'</strong>. Это так же переменная с несуществующим значением, наподобие предыдущей. Сценарий использования этой переменной можно рассмотреть на примере игры. Предположим, что у нас есть некая компьютерная игра, где есть персонаж за которого играет некий человек по имени Петя. Объявим его: <strong>'let player1234 = "Petya"'</strong>. После смерти игрового персонажа этого человека по одной из причин, его персонаж необходимо обнулить (удалить) из игрового процесса. В этом случае полезно применить переменную с нулевым значением – <strong>'null'</strong>, что делается как и прежде – <strong>'player1234 = null;'</strong>.
        </p>
        <div class="faq__any faq__flex">
               <img src="/instruction/img/faq.png">
               <p>*для справки: имена переменных всегда пишутся <strong>без</strong> пробелов. Для наилучшего понимания при программировании и последующего чтения кода, их желательно писать следующим образом: первое слово в имени переменной всегда пишется с маленькой буквы, второе, третье и, если необходимо, все последующие, с большой.</p>
        </div>
        <div class="faq__any faq__flex">
               <img src="/instruction/img/faq.png">
               <p>*для справки: так же еще одно немаловажное замечание по поводу имен переменных состоит в том, что имя любой объявленной переменной в JavaScript необходимо начинать с любой маленькой буквы латинского алфавита, символа нижнего подчеркивания или символа доллара. Другие символы запрещены и будут рождать ошибку при исполнении кода.</p>
        </div>
        <div id="built__methods">&nbsp;</div>
        <h1 class="main__head">Встроенные методы</h1>
        <p class="main__par">
            <span class="tab">Что</span> такое метод в языке программирования? Метод – это некий объем кода, состоящий из одной, нескольких или многих строк, помеченный каким-то именем, который в последствии можно вызывать (обращаться к нему). Это практически то же самое, что и переменная. Так же у метода существует такое понятие как "параметры". Параметр метода – это то значение, которое мы передаем внутрь метода для того, чтобы код в последствии мог к нему обращаться. Параметр метода пишется в круглых скобках.<br><br>
            <span class="tab">Далее</span> мы рассмотрим некоторые абстрактные методы в JavaScript для лучшего понимания.
        </p>
        <ul class="list">
            <li>Такие методы как <strong>'console.log()'</strong> и <strong>'alert()'</strong> мы уже рассматривали, но всё равно поместим их в список;</li>
            <li>Еще один метод – <strong>'prompt("")'</strong> (от англ. – подсказка). Таким образом, к примеру, при загрузке веб-страницы можно вывести сообщение с полем ввода, с вопросом "Как Вас зовут?" – <strong>'prompt("Как Вас зовут?");'</strong>. Точно так же, как и другие переменные в JavaScript, переменную <strong>'prompt'</strong> можно перезаписать, присвоив ей другое значение. К примеру, это может выглядеть так: <strong>'let firstName = "Vasya"; firstName = prompt("Как Вас зовут"); console.log(firstName);'</strong>. В этом случае мы обхявили переменную <strong>'firstName'</strong>, присвоили ей значение <strong>'Vasya'</strong>, а затем, когда в браузере появится окно с полем ввода и мы введем туда другое значение (своё имя, при условии, что нас зовут не Вася), переменная перепишется на новое значение, о чем будет выведено сообщение в консоль.</li>
         </ul>
         <div id="order__operators">&nbsp;</div>
         <h1 class="main__head">Порядок операторов</h1>
         <p class="main__par">
            <span class="tab"><button onclick="window.open('https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/Operator_Precedence#table')" class="button">Здесь</button></span>, чтобы не создавать в этой инструкции гигантскую таблицу, вы можете ознакомиться с распределением приоритетов различных операторов в языке JavaScript на сайте MDN.
         </p>
         <div id="if__else">&nbsp;</div>
         <h1 class="main__head">Условные операторы. If/Else</h1>
         <p class="main__par">
            <span class="tab">Важнейшая</span> концепция <strong>любого</strong> языка программирования – это условия. При помощи условий в языках программирования принимаются решения. Условный оператор записывается при помощи двух слов: <strong>'if'</strong> (от англ. если) и <strong>'else'</strong> (от англ. еще, иначе, в ином случае). Рассмотрим наглядно.<br><br>
            <span class="tab">К</span> примеру, объявим две переменные: <strong>let userName = "Ivan";</strong> и <strong>'let userAge = 15;'</strong>. Код дальнейшего условия записывается таким образом: <strong>'if(userAge >= 18) { console.log(userName + " is adult."); }'</strong>. Если после этого начать выполнять код и открыть консоль, то мы не получим никакого результата. Не получим мы его потому что в этом случае утверждение ложно, так как Ивану меньше 18ти лет. Код выполняться не будет. Этот код можно продолжить (ранее объявленные переменные прописывать не будем): <strong>let userName = "Ivan";</strong> и <strong>'let userAge = 15;'</strong>. <strong>'if(userAge >= 18) { console.log(userName + " is adult.";) }'</strong>.<br><br>
            <span class="tab"><strong>'else if(userAge &lt; 10) { console.log(userName + " is a child"); }'</strong></span>. Веток <strong>'else if'</strong> может быть сколько угодно. То есть, каждый раз, после того, как мы прописали какие-то условия <strong>'else'</strong> после <strong>'if'</strong>, мы всегда после этого можем добавить неограниченное количество <strong>'else if'</strong>, включающих в себя новые условия. Мы можем добавить еще одно условие (учитывая ранее написанный код): <strong>'else if(userAge > 10 && userAge &lt; 18)' { console.log(userName + " is a teenager"); }</strong>. В этом случае, мы добавили <strong>'else if'</strong>, где с помощью оператора <strong>'и'</strong> добавляются сразу два условия.
         </p>
         <div class="faq__any faq__flex">
               <img src="/instruction/img/faq.png">
               <p>*для справки: мы уже познакомились с новым типом оператора <strong>'и'</strong>, который обозначается как <strong>'&&'</strong>. Так же существует еще один немаловажный логический оператор <strong>'или'</strong>, он обозначается как <strong>'||'</strong>. В случае применения этого логического оператора, выражение считается истинным, если хотя бы одно из перечисленных между <strong>'или' (||)</strong> выражений истинно.</p>
         </div>
         <div id="ternary">&nbsp;</div>
         <h1 class="main__head">Тернарный оператор</h1>
         <p class="main__par">
            <span class="tab">Тернарный</span> оператор действует точно так же, как и оператор <strong>'if else'</strong>, но формат записи у него однострочный. То есть, мы можем записать оба условия и <strong>'if'</strong> и <strong>'else'</strong> в одной строке. Итак, вот как это работало с уже известными нам операторами <strong>'else if'</strong>. Давайте объявим две переменных:
         </p>
         <div class="code__block__any code__block__js">
            <p class="code__any code">
                let userName = "Jack";
            </p>
            <p class="code__any code">
                let userWeight = 87;
            </p>
            <p class="code__any code">
                if(userWeight > 90) {
            </p>
            <p class="code__any sub__code">
                console.log("У " + userName + " лишний вес.");
            </p>
            <p class="code__any code">
                } else {
            </p>
            <p class="code__any sub__code">
                console.log("У " + userName + " нормальный вес.");
            </p>
            <p class="code__any code">
                }
            </p>
         </div>
         <p class="main__par">
            <span class="tab">Однако</span> в случае использования <strong>тернарного</strong> оператора это будет выглядеть так, просто и элегантно (оставим ранее объявленные переменные):
         </p>
         <div class="code__block__any code__block__js">
            <p class="code__any code break">
                userWeight > 90 ? console.log("У " + userWeight + " лишний вес.") : console.log("У " + userName + " нормальный вес.");
            </p>
        </div>
        <p class="main__par">
            <span class="tab">Эта</span> структура расшифровывается следующим образом. <strong>Тернарный</strong> потому что состоит из трех частей: из изначального условия, из части, когда условие принимает значение <strong>'true'</strong> и части (после двоеточия), когда условие принимает значение <strong>'false'</strong>. Удобство этого оператора в том, что мы можем его использовать сразу при присваивании какой-либо значения переменной. Причем можно еще больше упростить написание кода, введя еще одну переменную и далее, прямо на месте, снова использовать тернарный оператор, без дополнительных строк вывода в консоль, еще элегантнее:
        </p>
        <div class="code__block__any code__block__js">
            <p class="code__any code">
                let weightDescription;
            </p>
            <p class="code__any code">
                weightDescription = userWeight > 90 ? " лишний" : " нормальный";
            </p>
            <p class="code__any code">
                console.log("У " + userName + weightDescription + " вес.")
            </p>
        </div>
        <div id="switch">&nbsp;</div>
        <h1 class="main__head">Оператор Switch</h1>
        <p class="main__par">
            <span class="tab">Оператор</span> <strong>'switch'</strong> действует как механизм перехода к какой-либо ветке кода (switch от англ. переключатель).<br><br>
            <span class="tab">Для</span> работы оператора как обычно объявляется переменная (или несколько). Объявим переменную <strong>'JavaScript'</strong>. Далее, записывается сам оператор <strong>'switch'</strong>, после которого в скобках указывается объявленная переменная. После (внутри) оператора <strong>'switch'</strong> словом <strong>'case'</strong> (от англ. случай) указываются ветки. После <strong>'case'</strong> в кавычках записывается значение. После чего ставится двоеточие и далее мы можем записать то, что будет выполняться, если переменная <strong>'section'</strong> будет равна указанному в кавычках значению. К примеру для первого случая выведем в консоль сообщение "Вы изучаете раздел HTML". Для второго случая выведем в консоль сообщение "Вы изучаете раздел CSS". Для третьего "Вы изучаете раздел JavaScript". <strong>Важно</strong> после каждого случая <strong>'case'</strong> ставить ключевое слово <strong>'break'</strong> (от англ. прервать). Нужно это для того, чтобы в тех случаях, когда в значении <strong>'case'</strong> находится такое же значение, как и установленное в <strong>переменной</strong>, то выполнение кода завершается и программа выходит из оператора, не выполняя последующие ветки. Так же может быть и такой момент, что в переменной может быть указано значение, не совпадающее ни с одним из случаев внутри оператора <strong>'switch'</strong>. В этом случае необходимо исполнить какой-то код по умолчанию Для этого после последнего блока <strong>'case'</strong> создается <strong>'default'</strong>, после чего, так же, как и после <strong>'case'</strong>, ставится двоеточие и указывается то действие, которое будет выполняться. В нашем случае, тоже выведем сообщение в консоль. В этом случае <strong>'break'</strong> не требуется, так как <strong>'default'</strong> ставится последним.<br><br>
            <span class="tab">Вот</span> так будет выглядеть код:
        </p>
        <div class="code__block__any code__block__js">
            <p class="code__any code">
                let section = "javaScript";
            </p>
            <p class="code__any code">
                switch(section) {
            </p>
            <p class="code__any sub__code">
                case "html" :
            </p>
            <p class="code__any sub__sub__code">
                console.log("Вы изучаете раздел HTML");
            </p>
            <p class="code__any sub__code">
                break;
            </p>
            <p class="code__any sub__code">
                case "css" :
            </p>
            <p class="code__any sub__sub__code">
                console.log("Вы изучаете раздел CSS");
            </p>
            <p class="code__any sub__code">
                break;
            </p>
            <p class="code__any sub__code">
                case "javaScript" :
            </p>
            <p class="code__any sub__sub__code">
                console.log("Вы изучаете раздел JavaScript");
            </p>
            <p class="code__any sub__code">
                break;
            </p>
            <p class="code__any sub__code">
                default :
            </p>
            <p class="code__any sub__sub__code">
                console.log("Вы изучаете какой-то раздел");
            </p>
            <p class="code__any code">
                }
            </p>
        </div>
        <div class="faq__any faq__flex">
            <img src="/instruction/img/faq.png">
            <p>*для справки: в одном <strong>'case'</strong> может находиться несколько значений переменных, для которых будут выполняться одни и те же действия. Прописывается точно так же, как и первоначальная переменная, в конце ставится двоеточие. К примеру, если после первой строки <strong>'case'</strong> из кода выше, вместе со значением <strong>'html'</strong> указать второй <strong>'case'</strong>, а после него <strong>'html5'</strong>, то в консоль будет выводиться один и тот же результат.</p>
         </div>
         <p class="main__par">
            <span class="tab">Теперь</span> провернем всё то же самое, только уже с числами. Для примера обратимся к части уже ранее пройденного калькулятора лишнего веса. Снова объявим две переменные <strong>'age'</strong> и <strong>'groupNumber'</strong>. Но если мы в <strong>'switch'</strong> поставим переменную <strong>'age'</strong>, то в <strong>'case'</strong> мы будем проверять равенство какому-то числу, а не сравнивать число с интервалом чисел. Чтобы сделать это с оператором <strong>'switch'</strong>, нужно провернуть небольшой трюк. Для этого в качестве переменной (в скобках после оператора <strong>'switch'</strong>) напишем <strong>'true'</strong>. После чего пишем <strong>'case'</strong>, а в <strong>'case'</strong> уже прописываем условия. В этом случае будет сравниваться значение <strong>'true'</strong> (истина) с приведенным внутри <strong>'case'</strong> выражением. То есть, если <strong>'age >= 18 && age <=25'</strong> – это <strong>'true'</strong>, то в этом случае по значение переменной <strong>'switch(true)'</strong>, то <strong>'true'</strong> = <strong>'true'</strong> и переменной <strong>'groupNumber'</strong> присваивается значение <strong>'1'</strong>. Вот так будет выглядеть этот код:
         </p>
         <div class="code__block__any code__block__js">
            <p class="code__any code">
                let age = 20;
            </p>
            <p class="code__any code">
                let groupNumber;
            </p>
            <p class="code__any code">
                switch(true) {
            </p>
            <p class="code__any sub__code">
                case age >= 18 && age <=25 :
            </p>
            <p class="code__any sub__sub__code">
                groupNumber = 1;
            </p>
            <p class="code__any sub__sub__code">
                break;
            </p>
            <p class="code__any sub__code">
                case age >= 25 && age <=46 :
            </p>
            <p class="code__any sub__sub__code">
                groupNumber = 2;
            </p>
            <p class="code__any sub__sub__code">
                break;
            </p>
            <p class="code__any sub__code">
                default :
            </p>
            <p class="code__any sub__sub__code">
                groupNumber = 3;
            </p>
            <p class="code__any code">
                }
            </p>
        </div>
        <div id="while">&nbsp;</div>
        <h1 class="main__head">Цикл While</h1>
        <p class="main__par">
            <span class="tab">Циклы</span> в языках программирования нужны для многократного повторения одного и того же действия. Для начала мы посмотрим на цикл <strong>'while'</strong> (от англ. пока, до тех пор).<br><br>
            <span class="tab">Цикл</span> <strong>'while'</strong> чем-то похож на оператор <strong>'if'</strong>, в котором так же в скобках указывается условие: <strong>'while(условие)'</strong>. После чего открываются фигурные скобки и туда вписывается код, который должен выполнится несколько раз. Этот код будет выполняться до тех пор, пока условие прописанное в скобках истинно. Оператор <strong>'while'</strong> работает таким образом: сначала проверяется на истинность условие, прописанное в скобках после оператора. Затем, если условие не верно, выполняется тело цикла, прописанное между фигурными скобками. Далее, после выполнения кода в теле цикла, оператор снова проверяет истинность условия в круглых скобках после себя и так до тех пор, пока условие не будет ложным. То есть, условия выхода из цикла – это выражение в круглых скобках равняется <strong>'false'</strong>. К примеру, можно указать вывод изначальной переменной <strong>'x = 1'</strong> в консоль. Однако если сделать это без прочих условий, то код впадет в бесконечный цикл, что может привести к зависанию браузера и/или компьютера. Поэтому мы можем инкриминировать нашу переменную, прописав к ней <strong>'x++'</strong>. Код выглядит так (для начала объявим переменную):
        </p>
        <div class="code__block__any code__block__js">
            <p class="code__any code">
                let x = 1;
            </p>
            <p class="code__any code">
                while(x < 100) {
            </p>
            <p class="code__any sub__code">
                console.log(x);
            </p>
            <p class="code__any sub__code">
                x++
            </p>
            <p class="code__any code">
                }
            </p>
        </div>
        <p class="main__par">
            <span class="tab">Есть</span> и другой способ применения цикла. Например, мы можем вывести в консоль какое-то текстовое сообщение по символам. Давайте добавим еще две переменных:
        </p>
        <div class="code__block__any code__block__js">
            <p class="code__any code">
                let helloString = "Привет, Аня!"
            </p>
            <p class="code__any code">
                let count = 0;
            </p>
            <p class="code__any code">
                while(count < helloString.length) {
            </p>
            <p class="code__any sub__code">
                console.log(helloString[count]);
            </p>
            <p class="code__any sub__code">
                count++;
            </p>
            <p class="code__any code">
                }
            </p>
        </div>
        <div class="faq__any faq__flex">
               <img src="/instruction/img/faq.png">
               <p>*для справки: внутри цикла <strong>'while'</strong> можно размещать оператор <strong>'if'</strong>, который так же как и обычно будет проверять некие условия и выполнять какие-то действия. Здесь представлено выведение в консоль всех чисел, кратных пяти.
                <div class="code__block__any code__block__syntax" style="flex-basis: 140%;">
                    <p class="code__any code">
                        let count = 1;
                     </p>
                     <p class="code__any code">
                        while(count <= 30) {
                     </p>
                     <p class="code__any sub__code">
                        if(count % 5 === 0) {
                     </p>
                     <p class="code__any sub__sub__code">
                        console.log(сount);
                     </p>
                     <p class="code__any sub__code">
                        }
                    </p>
                     <p class="code__any sub__code">
                        count++
                     </p>
                     <p id="code__any code">
                        }
                    </p>
                </div>
         </div>
         <div id="for">&nbsp;</div>
         <h1 class="main__head">Цикл for</h1>
         <p class="main__par">
            <span class="tab">Цикл</span> <strong>'for'</strong> являет собой более удобный в записи и восприятии вариант цикла <strong>'while'</strong>. Всё дело в том, что все данные для цикла (в том числе даже объявление переменной) записываются прямо в строке самого цикла <strong>'for'</strong>, в круглых скобках. На примере предыдущей операции рассмотрим принцип его работы:
         </p>
         <div class="code__block__any code__block__js">
            <p class="code__any code">
                for(count = 1; count &lt;= 10; count++) {
            </p>
            <p class="code__any sub__code">
                console.log(count);
            <p class="code__any code">
                }
            </p>
        </div>
        <p class="main__par">
            <span class="tab">Для</span> лучшего понимания, давайте и здесь, с помощью цикла <strong>'for'</strong> устроим перебор символа строки. Теперь используем не <strong>'count'</strong> переменную, а переменную <strong>'i'</strong>. Переменная <strong>'i'</strong> в реальной жизни в циклах <strong>'for'</strong> используется практически постоянно. То есть, в цикле <strong>'for'</strong> указывается одна буква для счетчика, так как эта переменная больше нигде не используется, ей не нужно присваивать имя, которое будет что-то описывать. Рассмотрим код:
        </p>
        <div class="code__block__any code__block__js">
            <p class="code__any code">
                let helloString = "Привет, Аня!"
            </p>
            <p class="code__any code">
                for(i = 0; i < helloString.length; i++) {
            </p>
            <p class="code__any sub__code">
                console.log(helloString[i]);
            </p>
            <p class="code__any code">
                }
            </p>
        </div>
        <div class="faq__any faq__flex">
               <img src="/instruction/img/faq.png">
               <p>*для справки: внутри цикла <strong>'for'</strong> можно размещать оператор <strong>'if'</strong>, который так же как и обычно будет проверять некие условия и выполнять какие-то действия. Здесь представлено выведение в консоль всех чисел, кратных семи в диапазоне до 30.
                <div class="code__block__any code__block__syntax" style="flex-basis: 140%;">
                    <p class="code__any code">
                        for(i = 1; i <= 30; i++) {
                    </p>
                    <p class="code__any sub__code">
                        if(i % 7 === 0) {
                    </p>
                    <p class="code__any sub__sub__code">
                        console.log(i);
                    </p>
                    <p class="code__any sub__code">
                        }
                    </p>
                    <p class="code__any code">
                        }
                    </p>
                </div>
         </div>
         <div id="functions">&nbsp;</div>
         <h1 class="main__head">Функции</h1>
         <p class="main__par">
            <span class="tab">Функции</span> </strong> чем-то схожи с переменными. То есть, как говорилось выше, в переменную можно поместить какое-либо значение, а затем, в последующих сценариях работы программы, при запросе этой переменной, мы можем получить это значение. В <strong>функциях</strong>можно хранить не значение, а целый код. То есть, функция – это как бы переменная (контейнер) для кода. Потом, соответственно, обратившись к функции программы по имени, в любом месте кода программы, мы можем запустить этот кусок кода.<br><br>
            <span class="tab">Код</span> организовывается следующим образом. Сначала пишется слово <strong>'function'</strong>, после которого всегда ставятся круглые скобки (в них могут помещаться аргументы функции). Затем, как и в предыдущих примерах, открываются фигурные скобки, в которых записывается само тело функции. То есть тот код, который будет выполняться, когда мы будем обращаться к этой функции в другом месте программы по её имени. Если записать функцию подобно циклам или операторам, то код работать не будет (функция – название функции – круглые скобки – фигурные скобки – тело функции (к примеру, вывод чего-либо в консоль)). Потому что в таком случае мы не обращаемся к функции, а просто определяем её. То есть мы создали функцию, прописали её внутренний код (тело), который эта функция должна выполнять, но мы не обращаемся к этой функции, чтобы она начала свою работу.<br><br>
            <span class="tab">Чтобы</span> запустить функцию (обратиться к ней), нужно просто прописать её имя, а сразу после обязательно поставить круглые скобки с точкой с запятой в конце.<br><br>
            <span class="tab">Вот</span> так может выглядеть ваш код:
         </p>
         <div class="code__block__any code__block__js">
            <p class="code__any code">
                function hello() {
            </p>
            <p class="code__any sub__code">
                console.log("Hello World!");
            </p>
            <p class="code__any code">
                }
            </p>
            <p class="code__any code">
                function();
            </p>
        </div>
        <p class="main__par">
            <span class="tab">Теперь</span> функция полностью готова. Далее в коде, мы можем несколько раз обращаться к этой функции и код будет выполняться ровно столько раз, сколько мы к ней обратимся.<br><br>
            <span class="tab">Вы</span> можете подумать, зачем же всё так усложнять? Можно же просто несколько раз прописать <strong>'console.log()'</strong> с нужными нам данными и тогда всё будет работать точно так же. Но не всё так просто. К примеру, если мы пропишем другую функцию:
        </p>
        <div class="code__block__any code__block__js">
            <p class="code__any code">
                function complexHello() {
            </p>
            <p class="code__any sub__code">
                console.log("Привет, меня зовут Глеб. Мне 24 года. Я из Ульяновска.");
            </p>
            <p class="code__any sub__code">
                console.log("До свидания!");
            </p>
            <p class="code__any code">
                }
            </p>
            <p class="code__any code">
                complexHello();
            </p>
        </div>
        <p class="main__par">
            <span class="tab">То</span> есть, надеюсь, становится понятно, что чем длиннее и сложнее код, тем проще поместить его в некий "контейнер", в данном случае, в виде функции и выполнять его автоматизированно.<br><br>
            <span class="tab">Функция</span> может содержать множество строк самого различного кода. То есть, принцип чем-то похож на контейнер <strong>'div'</strong> из <strong>HTML</strong>, который мы наполняем каким-то содержимым, с которым в последствии можно работать, обратившись к нему, например, из <strong>CSS</strong>.
        </p>
        <div id="function_param">&nbsp;</div>
        <h1 class="main__head">Параметры (аргументы) функции</h1>
        <p class="main__par">
            <span class="tab">В</span> предыдущей главе мы выводили через функцию в консоль некий текст приветствия. Вызывая эту функцию, мы будем выводить в консоль один и тот же текст. Но мы можем модифицировать эту функцию так, чтобы мы могли передавать текст приветствия в качестве параметра функции и в консоль уже выводился бы тот текст, который мы туда (в консоль) передадим. Для этого мы передадим функцию <strong>параметра</strong> или <strong>аргумента</strong>. Вернемся к нашему примера с функцией <strong>'complexHello'</strong> и в данном случае, в качестве параметра подходит <strong>'text'</strong>. Соответственно, далее в <strong>'console.log()'</strong> мы указываем не какую-то определенную строку текста, а, соответственно, этот параметр – <strong>'text'</strong>. И теперь, вместо этого параметра, мы можем передавать функции <strong>'console.log'</strong> любой текст. Код будет выглядеть следующим образом:
        </p>
        <div class="code__block__any code__block__js">
            <p class="code__any code">
                function complexHello() {
            </p>
            <p class="code__any sub__code">
                console.log(text);
            </p>
            <p class="code__any code">
                }
            </p>
            <p class="code__any code">
                complexHello("Привет, меня зовут Глеб. Мне 24 года. Я из Ульяновска.");
            </p>
        </div>
        <p class="main__par">
            <span class="tab">В</span> качестве параметра функции мы можем передавать не только текст. Например, мы можем создать функцию, вычисляющую квадрат какого-то числа. Для этого, как обычно, создадим функцию и присвоим ей параметр <strong>'number'</strong>. После чего, поместим в тело этой функции <strong>'console.log(number);'</strong>, которая будет выводить в качестве результата эту функцию. А затем, мы можем эту функцию вызвать и передавать ей значение цифры, квадрат которой требуется получить. Код будет выглядеть следующим образом:
        </p>
        <div class="code__block__any code__block__js">
            <p class="code__any code">
                function square(number) {
            </p>
            <p class="code__any sub__code">
                console.log(number * number);
            </p>
            <p class="code__any code">
                }
            </p>
            <p class="code__any code">
                square(2);
            </p>
        </div>
        <p class="main__par">
            <span class="tab">Параметр</span>, передаваемый в функцию, может быть не один. Например, давайте создадим другую функцию, вычисляющую площадь прямоугольника. Площадь прямоугольника равна ширине умноженной на высоту. Поэтому, параметры функции мы так и назовем: <strong>'width'</strong> и (через запятую) <strong>'height'</strong>. После чего, в теле функции, прописываем <strong>'console.log(width * height)';</strong>. И далее мы можем вызывать эту функцию с различными параметрами сторон этого треугольника, например 2 и 3. Код будет выглядеть следующим образом: 
        </p>
        <div class="code__block__any code__block__js">
            <p class="code__any code">
                function area(width, height) {
            </p>
            <p class="code__any sub__code">
                console.log("Площадь прямоугольника =" + width * height + " сантиметров квадратных");
            </p>
            <p class="code__any code">
                }
            </p>
            <p class="code__any code">
                area(2, 3);
            </p>
        </div>
        <p class="main__par">
            <span class="tab">Как</span> можно заметить, полезность функции заключается не только в том, что мы сокращаем общее количество строк кода, но и в том, что мы можем передавать ей разные параметры в зависимости от которых код будет выполняться с разным результатом. Это очень важное свойство функций, которое можно и нужно использовать в своих программах.<br><br>
            <span class="tab">Параметров</span> у функции может быть любое количество, но в обычной жизни их как правило не бывает больше трех-четырех. На примере текста приветствия это снова можно представить таким образом:
        </p>
        <div class="code__block__any code__block__js">
            <p class="code__any code">
                function complexHello(helloText, name, age) {
            </p>
            <p class="code__any sub__code">
                console.log(helloText + " Меня зовут " + name + ". Мне " + age + " лет.");
            </p>
            <p class="code__any code">
                }
            </p>
            <p class="code__any code">
                complexHello("Здравствуйте!", "Иван", 46);
            </p>
        </div>
        <p class="main__par">
            <span class="tab">Этот</span> код позволяет подставлять в функцию различные параметры в реальном времени. То есть, мы можем несколько раз обращаться к функции, меня её параметры и выводить, к примеру, различные приветствия.<br><br>
            <span class="tab">В</span> итоге думаю становится понятно, что аргументы функции – это всё те же, хоть и локальные, но концептуально переменные. Исходя из этого, параметры функции можно называть как угодно.
        </p>
        <div id="function__returns">&nbsp;</div>
        <h1 class="main__head">Возвращаемые значения функций</h1>
        <p class="main__par">
            <span class="tab">В</span> качестве примера давайте рассмотрим уже изученную выше функцию по расчету площади прямоугольника. Эта функция, в качестве входного параметра, получает <strong>'number'</strong>, а затем умножает этот <strong>'number'</strong> на себя же и выводит в консоль. То есть, функцию можно рассмотреть как некий черный ящик: мы передаем что-то в этот ящик, а затем функция внутри себя как-то эту переданную информацию обрабатывает. Но что если мы хотим использовать далее в программе результат того, что выполнила функция? В рассматриваемом примере – это квадрат значения <strong>'number'</strong> – то есть, вычисление площади прямоугольника. Если мы пойдем по известному нам пути, попытаемся объявить переменную <strong>'let x = square(2)'</strong> (square() от ранее рассмотренной функции – квадрат числа), и пропишем отображение в консоли. В этом случае, первая строка с переменной работать будет, то есть, будет вычисляться квадрат от числа 2, так как работает функция. Но вот <strong>'console.log(x)'</strong> будет выводить значение <strong>'undefined'</strong>. То есть, мы присвоили значение переменной <strong>'x'</strong>, но эта функция в данном случае не возвращает никакого значения – она просто проделывает какую-то работу. Но можно сделать и так, чтобы данные после работы функции выдавались как выходные. Делается это очень просто:
        </p>
        <div class="code__block__any code__block__js">
            <p class="code__any code">
                function square(number) {
            </p>
            <p class="code__any sub__code">
                return number * number;
            </p>
            <p class="code__any code">
                }
            </p>
        </div>
        <p class="main__par">
            <span class="tab">После</span> прописывания <strong>'return'</strong> нам становится доступно присвоение результата работы функции какой-то другой переменной.<br><br>
            <span class="tab">Есть</span> еще один сценарий использования функции внутри другой функции. В данном случае функции <strong>'square'</strong>. Создадим новую функцию, которая посредствам вычислений будет сообщать нам, большой ли квадрат. В качестве параметра бы будем использовать сторону квадрата <strong>'side'</strong>. Внутри функции объявим переменную <strong>'squareArea'</strong>, которая посредствам функции будет заниматься вычислением площади квадрата – возведением стороны квадрата в квадрат. Поэтому эту переменную мы можем приравнять к уже объявленной функции, которая этим занимается – <strong>'square'</strong> со значением <strong>'side'</strong>. Ниже мы можем использовать оператор <strong>'if'</strong>, который будет выяснять: если площадь квадрата больше установленного нами значения, то квадрат большой. И если да, то эта функция будет возвращать <strong>'true'</strong>. А в другом случае, соответственно, <strong>'false'</strong>. А после выведем в консоль функцию, с параметром, к примеру "2": <strong>'console.log(isSquareBig(2))';</strong> Код будет выглядеть следующим образом:
        </p>
        <div class="code__block__any code__block__js">
            <p class="code__any code">
                function square(number) {
            </p>
            <p class="code__any sub__code">
                return number * number;
            </p>
            <p class="code__any code">
                }
            </p>
            <p class="code__any code">
                function isSquareBig(side) {
            </p>
            <p class="code__any sub__code">
                let squareArea = square(side);
            </p>
            <p class="code__any sub__code">
                if(squareArea > 100) {
            </p>
            <p class="code__any sub__sub__code">
                return true;
            </p>
            <p class="code__any sub__code">
                } else {
            </p>
            <p class="code__any sub__sub__code">
                return false;
            </p>
            <p class="code__any sub__code">
                }
            </p>
            <p class="code__any code">
                }
            </p>
            <p class="code__any code">
                console.log(isSquareBig(2));
            </p>
        </div>
        <div id="statements">&nbsp;</div>
        <h1 class="main__head">Statements vs. Expressions</h1>
        <p class="main__par">
            <span class="tab">Есть</span> два способа создания функции. Первый способ мы уже рассмотрели, он называется <strong>Statement</strong> или <strong>объявление функции</strong>. То есть, запись в форме <strong>'function название_функции() {}'</strong>. Но есть второй способ – способ создания функции в выражении – <strong>Expression</strong>. Для наглядности давайте создадим реальную функцию и посмотрим, как её можно реализовать двумя способами. В функции мы будем передавать два параметра: название и вид животного и в зависимости от того, какое это животное, мы будем выводить в консоль имя этого животного и звук, который оно издает. То есть, если мы введем параметры "Имя 'Ричард'" и "Вид 'собака'", то в консоль должно выводиться "Ричард гавкает". Код в первом случае будет выглядеть следующим образом:
        </p>
        <div class="code__block__any code__block__js">
            <p class="code__any code">
                function animalVoice(animal, animalName) {
            </p>
            <p class="code__any sub__code">
                if(animal === "dog") {
            </p>
            <p class="code__any sub__sub__code">
                return animalName + " гавкает.";
            </p>
            <p class="code__any sub__code">
                } else if(animal === "cat") {
            </p>
            <p class="code__any sub__sub__code">
                return animalName + " мяукает.";
            </p>
            <p class="code__any sub__code">
                } else if(animal === "pig") {
            </p>
            <p class="code__any sub__sub__code">
                return animalName + " хрюкает.";
            </p>
            <p class="code__any sub__code">
                } else {
            </p>
            <p class="code__any sub__sub__code">
                return animalName + " издает какие-то звуки.";
            </p>
            <p class="code__any sub__code">
                }
            </p>
            <p class="code__any code">
                }
            </p>
            <p class="code__any code">
                console.log(animalVoice("dog", "Ричард"));
            </p>
        </div>
        <p class="main__par">
            <span class="tab">А</span> вот второй способ – <strong>Expression</strong>:
        </p>
        <div class="code__block__any code__block__js">
            <p class="code__any code">
                let animalVoice = function(animal, animalName) {
            </p>
            <p class="code__any sub__code">
                if(animal === "dog") {
            </p>
            <p class="code__any sub__sub__code">
                return animalName + " гавкает.";
            </p>
            <p class="code__any sub__code">
                } else if(animal === "cat") {
            </p>
            <p class="code__any sub__sub__code">
                return animalName + " мяукает.";
            </p>
            <p class="code__any sub__code">
                } else if(animal === "pig") {
            </p>
            <p class="code__any sub__sub__code">
                return animalName + " хрюкает.";
            </p>
            <p class="code__any sub__code">
                } else {
            </p>
            <p class="code__any sub__sub__code">
                return animalName + " издает какие-то звуки.";
            </p>
            <p class="code__any sub__code">
                }
            </p>
            <p class="code__any code">
                }
            </p>
            <p class="code__any code">
                console.log(animalVoice("dog", "Ричард"));
            </p>
        </div>
        <p class="main__par">
            <span class="tab">Как</span> видно из кода – работа функций в обоих способах абсолютно идентична. Единственное отличие, как вы могли заметить по первой строке, состоит в том, что при объявлении функции как переменной, эту функцию можно обнулить, если присвоить этой переменной другое значение. Это в дальнейшем функционально может пригодиться в программе. 
        </p>
        <div id="func_ex">&nbsp;</div>
        <h1 class="main__head">Различные примеры реализации функций и рефакторинг</h1>
        <p class="main__par">
            <span class="tab">В</span> первом примере мы рассмотрим, как создать функцию, вычисляющую, является ли число нечетным или нет. Если число нечетное, то в консоль выводится <strong>'true'</strong>, а если четное, то <strong>'false'</strong>. Код будет выглядеть следующим образом:
        </p>
        <div class="code__block__any code__block__js">
            <p class="code__any code">
                function isNumberOdd(number) {
            </p>
            <p class="code__any sub__code">
                if(number % 2 === 0) {
            </p>
            <p class="code__any sub__sub__code">
                return false;
            </p>
            <p class="code__any sub__code">
                } else {
            </p>
            <p class="code__any sub__sub__code">
                return true;
            </p>
            <p class="code__any sub__code">
                }
            </p>
            <p class="code__any code">
                }
            </p>
        </div>
        <div class="faq__any faq__flex">
            <img src="/instruction/img/faq.png">
            <p>*для справки: для лучшего понимания оператора <strong>'%'</strong>, строка <strong>'if(number % 2 === 0)'</strong> буквально означает, что "если, при делении на "2" переменной <strong>'number'</strong> остаток равен "0", то...</p>
        </div>
         <div class="faq__any faq__flex">
            <img src="/instruction/img/faq.png">
            <p class="faq_p">*для справки: кроме того, у обращения к функциям есть два варианта. На примере консоли первый вариант будет выглядеть так: <strong>'let x = isNumberOdd(11)';</strong>, а затем вывести в консоль, соответственно <strong>'console.log(x);'</strong>. И второй вариант: <strong>'console.log(isNumberOdd(11));'</strong>.</p>
         </div>
         <p class="main__par">
            <span class="tab">Еще</span> бонусом можно было бы отметить, что в программировании существует такое понятие как <strong>'рефакторинг'</strong>. Сразу написать идеальный код бывает довольно сложно, особенно если код сам по себе тоже сложен, поэтому написанный код часто можно многократно улучшить, оптимизировав его. Это, разумеется, будет давать прирост в скорости его работы, но так же и положительно сказываться на его читаемости. На примере ранее описанной функции <strong>'isNumberOdd'</strong>, можно показать, насколько сильно можно укоротить код:
         </p>
         <div class="code__block__any code__block__js">
            <p class="code__any code">
                function isNumberOdd(number) {
            </p>
            <p class="code__any sub__code">
                return % 2 !== 0;
            </p>
            <p class="code__any code">
                }
            </p>
        </div>
        <p class="main__par">
            <span class="tab">То</span> есть, сначала будет вычисляться значение логического выражения после <strong>'return'</strong> и если остаток от деления <strong>% 2</strong> <strong>НЕ</strong> равен нулю (неравенство обозначается оператором <strong>'!=='</strong>), то будет возвращаться <strong>'true'</strong> и на этом работа функции завершается. Быстро и элегантно.
        </p>
        <p class="main__par">
            <span class="tab">Во</span> втором примере мы посмотрим на функцию, вычисляющую факториал числа:
        </p>
        <div class="code__block__any code__block__js">
            <p class="code__any code">
                function factorial(naturalNumber) {
            </p>
            <p class="code__any sub__code">
                if(naturalNumber < 0) {
            </p>
            <p class="code__any sub__sub__code">
                return 0;
            </p>
            <p class="code__any sub__code">
                }
            </p>
            <p class="code__any sub__code">
                let result = 1;
            </p>
            <p class="code__any sub__code">
                for(i = 1; i <= naturalNumber; i++) {
            </p>
            <p class="code__any sub__sub__code">
                result = result * i;
            </p>
            <p class="code__any sub__code">
                }
            </p>
            <p class="code__any sub__code">
                return result;
            </p>
            <p class="code__any code">
                }
            </p>
        </div>
        <p class="main__par">
            <span class="tab">А</span> теперь, смотря на код выше, давайте разберемся, как работает эта функция.<br><br>
            <span class="tab">В</span> начале проверяется, ввел ли пользователь корректное значение. То есть, ввел ли пользователь натуральное число, чтобы факториал сработал. Например, мы можем договориться, что если пользователь ввел отрицательное значение, то мы возвращаем из функции значение <strong>0</strong>. Так как сам факториал не может возвращать <strong>0</strong>, следовательно, возвращенный <strong>0</strong> будет сигнализировать о том, что пользователь ввел некорректное значение.<br><br>
            <span class="tab">Далее</span> к самому факториалу. Сначала <strong>'i = 1'</strong>, точно так же, как и объявленная переменная <strong>'result = 1'</strong>. То есть, исходя из логики работы цикла, переменной <strong>'result'</strong> будет присвоено значение <strong>1 * 1</strong>, что будет равняться <strong>единице</strong>.<br><br>
            <span class="tab">Если</span> передать в параметр функции значение, к примеру, <strong>3</strong>, то <strong>'i < 3'</strong>, следовательно, запускается цикл. Так как из-за <strong>'i++'</strong> цикл продолжается, следовательно, <strong>i = 2</strong>. В <strong>'result'</strong> находится <strong>1</strong>, <strong>1 * 2 = 2</strong>, после чего <strong>'result'</strong> присваивается <strong>2</strong>. Далее снова идет проверка в цикле. <strong>i</strong> всё еще меньше заданного значения функции <strong>3</strong>, поэтому снова срабатывает <strong>'i++'</strong> и теперь <strong>i = 3</strong>. В <strong>'result'</strong> всё еще находится <strong>2</strong> – <strong>2 * 3 = 6</strong>. Число <strong>6</strong> присваивается <strong>'result'</strong>, после чего снова срабатывает <strong>i++</strong> и <strong>i</strong> теперь равна <strong>4</strong> и в этом случае мы выходим из цикла, так как <strong>4 > 3</strong>, где <strong>3</strong> – установленное значение функции. И в самом конце мы возвращаем <strong>'result'</strong>.
        </p>
        <p class="main__par">
            <span class="tab">И</span> в последнем, третьем примере мы рассмотрим, как с помощью функции JavaScript можно автоматически менять текстовые символы. Для примера возьмем функцию, которая будет заменять все пробелы на символы нижнего подчеркивания – <strong>_</strong>.
        </p>
        <div class="code__block__any code__block__js">
            <p class="code__any code">
                function changeSpaceToUnderscore(text) {
            </p>
            <p class="code__any sub__code">
                let resultText = text.replace(/ /g, "_");
            </p>
            <p class="code__any sub__code">
                return resultText;
            </p>
            <p class="code__any code">
                }
            </p>
        </div>
        <p class="main__par">
            <span class="tab">Здесь</span> всё довольно просто. Мы создаем функцию с параметром <strong>'text'</strong>. Затем, внутри этой функции, мы объявляем переменную <strong>'resultText'</strong>, которая равна параметру объявленной функции <strong>'text'</strong>, но с методом <strong>'replace()'</strong>, который в JavaScript и занимается заменой символов. После метода <strong>'replace'</strong> в скобках между двумя слешами указывается то, что мы хотим заменить, после чего обязательно ставится символ <strong>'g'</strong> и после запятой в кавычках указывается то, <strong>НА ЧТО</strong> мы хотим заменить.
        </p>
        <div id="area__of__vis">&nbsp;</div>
        <h1 class="main__head">Область видимости переменных</h1>
        <p class="main__par">
            <span class="tab">В</span> JavaScript есть два типа областей видимости переменных:
        </p>
        <ul class="list">
            <li>Local Scope</li>
            <li>Global Scope</li>
        </ul>
        <p class="main__par">
            <span class="tab">Каждая</span> функция создает новую область видимости. Понятие <strong>области видимости</strong> включает в себя некую <strong>доступность</strong> или <strong>видимость</strong> переменных. Эта область видимости определяет доступность переменных вне других конструкций программы.<br><br>
            <span class="tab">К</span> примеру, переменные определённые <strong>внутри</strong> некой функции не будут доступны <strong>за</strong> её пределами. Но это не работает для переменных, определенных снаружи относительно тела функции. В этом случае мы не только можем обращаться к внешним переменным, но и менять их значения. Такие переменные, декларированные за пределами каких-либо структур, называются <strong>глобальными</strong>. Внутри же функции предпочтение <strong>всегда</strong> отдается локальным одноименным переменным.
        </p>
        <div class="faq__any faq__flex">
            <img src="/instruction/img/faq.png">
            <p>*для справки: именно из-за понятия области видимости для циклов <strong>'for'</strong> и подобных структур, условия рекомендовано прописывать в формате переменной, как, например, <strong>'for(let i = 1; i < 10; i++) {}'</strong>. Всё потому что в случае, если объявить в цикле <strong>'i'</strong> без ключевого слова <strong>'let'</strong>, то в коде будет создаваться переменная глобального типа. Это, как можно понять, может серьезно повлиять на ход выполнения программы, если этой переменной случайно присвоится какое-то иное значение.</p>
        </div>
        <div id="massives">&nbsp;</div>
        <h1 class="main__head">Массивы</h1>
        <p class="main__par">
            <span class="tab">Массивы</span> – это одна из структур данных, которые существуют в языке JavaScript. Итак, что же это такое?<br><br>
            <span class="tab">Есть</span> такой способ. К примеру, у нас есть несколько цветов. Чтобы хранить значения этих цветов, как уже делали прежде, мы можем использовать переменные:
        </p>
        <div class="code__block__any code__block__js">
            <p class="code__any code">
                let color1 = "красный";
            </p>
            <p class="code__any code">
                let color2 = "оранжевый";
            </p>
            <p class="code__any code">
                let color3 = "желтый";
            </p>
            <p class="code__any code">
                let color4 = "зеленый";
            </p>
            <p class="code__any code">
                let color5 = "голубой";
            </p>
            <p class="code__any code">
                let color6 = "синий";
            </p>
            <p class="code__any code">
                let color7 = "фиолетовый";
            </p>
        </div>
        <p class="main__par">
            <span class="tab">Итак,</span> у нас есть семь цветов радуги – семь переменных. Но проблема в том, что эти переменные никак не связаны друг с другом. То есть, мы никак не отображаем, что все эти семь цветов относятся к цветам радуги. И именно в таком случае, когда нам нужно собрать какие-то данные в единую структуру, как и в случае с цветами радуги, нам и приходят на помощь массивы. Массивы данных создаются следующим образом:
        </p>
        <div class="code__block__any code__block__js">
            <p class="code__any code">
                let rainbowColors = ["красный", "оранжевый", "желтый", "зеленый", "голубой", "синий", "фиолетовый"];
            </p>
        </div>
        <p class="main__par">
            <span class="tab">И</span> теперь все цвета собраны воедино и мы можем обращаться к этим значениям по одному имени – по имени <strong>rainbowColors</strong>.<br><br>
            <span class="tab">Обращаться</span> затем к этому массиву данных можно следующим образом (для примера возьмем консоль): <strong>consol.log(rainbowColors[2, 3]);</strong>. В квадратных скобках указывается индекс элемента в массиве, то есть, его порядковый номер. Индексируются массивы начиная с нуля. Для</span> примера этот вывод в консоль можно скомбинировать еще и со строкой: <strong>'console.log("Небо " + [4] + " цвета");'</strong>.<br><br>
            <span class="tab">Можно</span> не только считывать данные из элемента массива, но и менять значения этих элементов. То есть, к примеру, если мы хотим изменить цвет <strong>"красный"</strong> на <strong>"оранжевый"</strong>, то мы можем сделать следующее: <strong>'rainbowColors[0] = "оранжевый";'</strong>.<br><br>
            <span class="tab">Ровно</span> так же можно вывести в консоль (или куда-либо еще) <strong>все</strong> элементы массива при помощи указания его имени: <strong>'console.log(rainbowColors);'</strong>.<br><br>
            <span class="tab">Так</span> же можно не только изменять какие-то элементы в массиве, но и добавлять в него новые. Но что делать, если мы не знаем, что у нас только семь элементов в массиве, а высчитать из них последний было бы затруднительно? Сделать это можно указать свойство массива <strong>'.length'</strong>. Это свойство равно количеству элементов, а именно: <strong>'rainbowColors[rainbowColors.length] = "темно-синий";'</strong>. Есть и другие способы создания массивов.<br><br>
            <span class="tab">Второй</span> способ создать массив выглядит следующим образом: <strong>'let emptyArray = [];'</strong>. При такой записи создается пустой массив, в которые затем можно поместить значения.<br><br>
            <span class="tab">Еще</span> одна, не слишком распространенная форма создания массива – это: <strong>'let emptyArray = new Array();'</strong> – осуществляется, как можно видеть, с помощью обращения к функции <strong>'array'</strong>. Повторюсь, такой способ не распространен.<br><br>
            <span class="tab">Конечно</span> же, массивы могут хранить не только строки, они могут хранить в себе любые значения. Можно так же создать массив с числами: <strong>'let numbers = [1, 5, 3, 2];'</strong>. Более того, JavaScript позволяет добавлять в массив значения разных типов: <strong>'let anyItems = [32, "Hello!", null]';</strong>.
        </p>
        <div id="massive__methods">&nbsp;</div>
        <h1 class="main__head">Методы массивов</h1>
        <p class="main__par">
            <span class="tab">У</span> массивов спаренные методы, такие как <strong>'push/pop'</strong>, <strong>'shift/unshift'</strong>, и есть одиночные <strong>indexOf</strong>, <strong>'slice'</strong>. Это основные методы для работы с массивами. По <button class="button" onclick="window.open('https://www.w3schools.com/jsref/jsref_obj_array.asp')">этой</button> ссылке можно перейти на сайт W3Schools и подробнее прочесть о самых разных методах для работы с массивами данных – их существует очень много. Но в основном используются те методы, речь о которых пойдет далее.<br><br>
            <span class="tab">Начнем</span> с метода <strong>Push</strong>. Создадим массив: <strong>'let names = ["Вася", "Саша", "Игорь", "Олег"];'</strong>. Далее, если мы хотим изменить массив, а именно, добавить в него какой-то элемент, мы можем воспользоваться либо технологией, описанной выше, либо прибегнуть к методу <strong>Push</strong>. Выглядит это следующим образом (воспроизведем это как полноценный код):
        </p>
        <div class="code__block__any code__block__js">
            <p class="code__any code">
                let names = "Вася", "Саша", "Игорь", "Олег"];
            </p>
            <p class="code__any code">
                names.push("Вячеслав");
            </p>
        </div>
        <p class="main__par">
            <span class="tab">После</span> чего, с помощью такого метода записи, в массив (в его конец) будет добавлен новый элемент.<br><br>
            <span class="tab">Кроме</span> того, метод <strong>'push'</strong> может возвращать значения. Вообще, метод – это, своего рода, функция. И мы можем извлечь из нее значение. Это можно реализовать следующим образом:
        </p>
        <div class="code__block__any code__block__js">
            <p class="code__any code">
                let names = "Вася", "Саша", "Игорь", "Олег"];
            </p>
            <p class="code__any code">
                let x = names.push("Вячеслав");
            </p>
            <p class="code__any code">
                console.log(names);
            </p>
            <p class="code__any code">
                console.log(x);
            </p>
        </div>
        <p class="main__par">
            <span class="tab">При</span> этом <strong>console.log();'</strong> в виде переменной <strong>'x'</strong> будет выводить число, означающее длину массива.<br><br>
            <span class="tab">Противоположностью</span> метода <strong>push</strong> является метод <strong>pop</strong>. Метод <strong>pop</strong> удаляет последний элемент в массиве. Он так же способен возвращать значения, но он возвращает не количество элементов, а значение того элемента, который он удалил, то есть последнего. Код для удаления из массива последнего элемента выглядит так: <strong>'names.pop();'</strong>.<br><br>
            <span class="tab">Следующая</span> пара методов – <strong>shift</strong> и <strong>unshift</strong>. По той же самой логике, что и предыдущие два массива, они используются для работы с элементами в начале массива. Метод <strong>unshift</strong> добавляет элемент, метод <strong>shift</strong> удаляет. 
            <span class="tab">Следующий</span> метод – <strong>indexOF</strong>. Он нужен для определения индекса элемента массива. Записывается следующим образом: <strong>'names.indexOf("Игорь");'</strong>. Как можно заметить, в качестве параметра этот метод принимает в себя конкретный элемент массива, а после чего возвращает его индекс. Если мы укажем какой-то элемент, которого нет в массиве, то будет возвращено значение <strong>-1</strong>. То есть, если нужно определить, существует ли введенный элемент в массиве, то это можно легко сделать при помощи этого метода. Есть еще один момент. Если в массиве присутствует два одинаковых элемента, то будет возвращено значение <strong>0</strong>. Мы можем использовать метод <strong>indexOf</strong>, к примеру, в следующий логике:
        </p>
        <div class="code__block__any code__block__js">
            <p class="code__any code">
                let toyota = ["Camry", 2018, "sedan", "black", true];
            </p>
            <p class="code__any code">
                let isSedan = toyota.indexOf("sedan") === -1 ? console.log("Тип кузова - не седан") : console.log("Тип кузова - седан");
            </p>
        </div>
        <p class="main__par">
            <span class="tab">В</span> этом случае метод <strong>indexOf</strong> проверяет в массиве, есть ли там характеристика автомобиля – седан. Если же такого элемента массива нет, то возвращается значение <strong>-1</strong>, что исходя из работы тернарного оператора, интерпретируется как <strong>false</strong> и срабатывает описанный вывод в консоль, что машина не является седаном.<br><br>
            <span class="tab">Последний</span> метод, который мы рассмотрим – это метод <strong>slice</strong>. Метод <strong>slice</strong> позволяет скопировать часть какого-то массива и присвоить её другой переменной, то есть создать другой массив из уже существующего. Например, <strong>let cars = ["Honda", "Toyota", "Peugeot", "Opel", "Mersedes", "BMW"];</strong>. И к примеру, мы хотим выбрать из этого массива только немецкие марки автомобилей, то есть, Opel, Mersedes и BMW. Для этого мы можем создать новый массив: <strong>'let germanCars = cars.slice(3, 5)';</strong>. В параметре метода в круглых скобках указываются индексы элементов, с которого мы начинаем "резать" массив, чтобы забрать его кусок и второй индекс, которым мы заканчиваем.
        </p>
        <div id="objects">&nbsp;</div>
        <h1 class="main__head">Объекты</h1>
        <p class="main__par">
            <span class="tab">В</span> JavaScript есть еще одна структура для хранения данных – это <strong>объекты</strong>. Пример массивов из предыдущей главы может хранить как данные одинакового типа (строки), так и данные разных типов (строки, числа, boolean, undefined, null). Этот способ хранения данных, по большому счету, валиден (корректен), однако не слишком удобен: чтобы получить доступ к какому-либо элементу из массива, нам нужно точно знать, на какой позиции расположено то или иное свойство. Поэтому для множества типов данных, которые принадлежат к какому-то объекту, в JavaScript и существует тип хранения данных <strong>объекты</strong>. В коде объекты записываются следующим образом <strong>'let carToyota = {}';</strong>. В фигурных скобках перечисляются свойства объекта. Но они будут сохраняться не по их индексу, а по так называемому <strong>ключу</strong> (строке). Соответственно, в объекте есть ключ и его значение, по которому считывается информация. Более развернуто посмотрим на код:
        </p>
        <div class="code__block__any code__block__js">
            <p class="code__any code">
                let carToyota = {
            </p>
            <p class="code__any sub__code">
                model: "Camry",
            </p>
            <p class="code__any sub__code">
                year: "2010",
            </p>
            <p class="code__any sub__code">
                carBody: "sedan",
            </p>
            <p class="code__any sub__code">
                color: "black",
            </p>
            <p class="code__any sub__code">
                hasAirbag: true
            </p>
            <p class="code__any code">
                }
            </p>
        </div>
        <p class="main__par">
            <span class="tab">Далее</span> мы можем обращаться к элементу объекта при помощи похожей записи, что мы рассматривали выше, только в этот раз используется не индекс, а название свойства обекта. На примере консоли: <strong>'console.log(carToyota["year"]);'</strong>. Но для обращения к свойству объекта не обязательно используется метод обращения, как к массиву – для этого есть специальная запись: <strong>'carToyota.year';</strong>. Это обращение к объекту по его ключу. То есть теперь нам не важно знать, на каком месте расположено то или иное свойство. Мы даже можем менять их местами – на результат это никак не повлияет. Есть небольшое отличие между двумя типами записей. В первом случае, когда элемент указывается в квадратных скобках, мы можем использовать переменную. Например, если мы создадим переменную с каким-либо свойством из массива, а затем обратимся к ней, то всё сработает корректно:
        </p>
        <div class="code__block__any code__block__js">
            <p class="code__any code">
                let x = "Camry";
            </p>
            <p class="code__any code">
                console.log(carToyota[x]);
            </p>
        </div>
        <p class="main__par">
            <span class="tab">Но</span> если мы обратимся к <strong>'x'</strong> в формате записи <strong>'console.log(carToyota.x)'</strong>, то в результате мы получим значение <strong>'undefined'</strong>. В этом случае будет разыскиваться свойство с названием <strong>'x'</strong>, а не назначенная переменная.<br><br>
            <span class="tab">В</span> объектах точно так же можно менять одни свойства на другие. Например, цвет: <strong>'carToyota.color = "red";</strong>.<br><br>
            <span class="tab">Как</span> и массив, объект точно так же можно вызвать. Например, в консоль: <strong>'console.log(carToyota);'</strong>.<br><br>
            <span class="tab">Для</span>объектов так же существует не один способ их создания. В первом способе, который мы рассмотрели выше, мы сразу прописываем все поля. Но есть второй способ:
        </p>
        <div class="code__block__any code__block__js">
            <p class="code__any code">
                let carMazda = {};
            </p>
            <p class="code__any code">
                carMazda.year = 2018;
            </p>
            <p class="code__any code">
                carMazda.model = "CX7";
            </p>
            <p class="code__any code">
                carMazda.carBody = "crossover";
            </p>
        </div>
        <p class="main__par">
            <span class="tab">И</span> еще один способ, как и при создании массивов – при помощи функции. Код выглядит следующим образом:
        </p>
        <div class="code__block__any code__block__js">
            <p class="code__any code">
                let carOpel = new Object();
            </p>
            <p class="code__any code">
                carOpel.body = "Hatchback";
            </p>
            <p class="code__any code">
                carOpel.year = 2018;
            </p>
            <p class="code__any code">
                carOpel.color = "blue";
            </p>
        </div>
        <div id="objects__massives">&nbsp;</div>
        <h1 class="main__head">Массивы или объекты</h1>
        <p class="main__par">
            <span class="tab">Так</span> что же выбрать? Какие данные лучше отображать в массивах, а какие в объектах?<br><br>
            <span class="tab">В</span> массивах лучше хранить данные одного вида (типа), то есть однообразные данные. Конечно, не воспрещается хранить в массивах и разнообразные данные, однако способ массивов для этих целей не представляется удобным. К примеру, массив с различными названиями цветов, где, конечно же, будут только цвета и ничего больше: <strong>let colors = ["red", "orange", "yellow", "white", "blue"];</strong>. Если же мы хотим сохранять данные разных типов (как в выше описанном примере с автомобилем), то лучше использовать способ объектов. Как например, информация о человеке: 
        </p>
        <div class="code__block__any code__block__js">
            <p class="code__any code">
                let personIvan = {
            </p>
            <p class="code__any sub__code">
                firstName: "Иван",
            </p>
            <p class="code__any sub__code">
                lastName: "Иванов",
            </p>
            <p class="code__any sub__code">
                age: 24,
            </p>
            <p class="code__any sub__code">
                isMarried: false,
            </p>
            <p class="code__any code">
                }
            </p>
        </div>
        <p class="main__par">
            <span class="tab">Но</span> кроме того, и массивы и объекты могут хранить в себе другие массивы и/или объекты. Например, массив <strong>'numbers'</strong> (числа), может хранить в себе какие-то массивы с какими-то числами: <strong>'let numbers = [[1,2,3], [4,5,6], [7,8,9,10]];'</strong>. А далее, чтобы обратиться к этому массиву, к примеру, через консоль, нужно сначала указать индекс массива в массиве, а затем индекс самого элемента в выбранном массиве: <strong>'condole.log(numbers[1][2]);'</strong>.<br><br>
            <span class="tab">Объекты</span> с массивами можно конфигурировать по-разному. К примеру, объекты могут содержать в себе массивы. Вернемся к нашему примеру с <strong>'personIvan'</strong>:
        </p>
        <div class="code__block__any code__block__js">
            <p class="code__any code">
                let personIvan = {
            </p>
            <p class="code__any sub__code">
                firstName: "Иван",
            </p>
            <p class="code__any sub__code">
                lastName: "Иванов",
            </p>
            <p class="code__any sub__code">
                age: 24,
            </p>
            <p class="code__any sub__code">
                isMarried: false,
            </p>
            <p class="code__any sub__code">
                pets: ["cat", "dog", "humster"]
            </p>
            <p class="code__any code">
                }
            </p>
        </div>
        <p class="main__par">
            <span class="tab">А</span> чтобы обратиться к одному из элементов массива, нужно: <strong>'console.log(personIvan.pets[1]);'</strong>.<br><br>
            <span class="tab">Объекты</span> могут хранить массивы, а массивы могут хранить объекты. К примеру, мы хотим сделать базу данных о продавцах автомобилей:
        </p>
        <div class="code__block__any code__block__js">
            <p class="code__any code">
                let sellers = [
            </p>
            <p class="code__any sub__code">
                {
            </p>
            <p class="code__any sub__sub__code">
                firstName: "Иван",
            </p>
            <p class="code__any sub__sub__code">
                firstName: "Иванов",
            </p>
            <p class="code__any sub__sub__code">
                regDate: "09.08.2019",
            </p>
            <p class="code__any sub__sub__code">
                hasDiscount: false,
            </p>
            <p class="code__any sub__sub__code">
                age: 25
            </p>
            <p class="code__any sub__code">
                },
            </p>
            <p class="code__any sub__code">
                {
            </p>
            <p class="code__any sub__sub__code">
                firstName: "Gleb",
            </p>
            <p class="code__any sub__sub__code">
                lastName: "Glebov",
            </p>
            <p class="code__any sub__sub__code">
                regDate: "01.01.2010",
            </p>
            <p class="code__any sub__sub__code">
                hasDiscount: true,
            </p>
            <p class="code__any sub__sub__code">
                age: 34
            </p>
            <p class="code__any sub__code">
                }
            </p>
            <p class="code__any code">
                ]
            </p>
        </div>
        <p class="main__par">
            <span class="tab">То</span> есть, как можно заметить, у нас есть массив и внутри этого массива есть два объекта (можно создавать сколько угодно объектов). Как же нам обратиться к полям этих объектов? Есть два способа. Мы можем обратиться ко всему объекту, к примеру, в консоли: <strong>'console.log(sellers[1]);'</strong>. Или мы можем обратиться только к какой-то конкретной строке: <strong>'console.log(sellers[1].hasDiscount);'</strong>.<br><br>
            <span class="tab">В</span> реальной жизни мы можем создавать базы данных, а затем обращаться к конкретным элементам в них. Например, создать базу данных об автомобилях в автосалоне, а затем вывести только те автомобили, которые были проданы. Для этого, собственно, создадим базу данных. А затем создадим цикл, где будет высчитываться длина выводимой информации. Выглядеть это будет следующим образом:
        </p>
        <div class="code__block__any code__block__js">
            <p class="code__any code">
                let cars = [
            </p>
            <p class="code__any sub__code">
                {
            </p>
            <p class="code__any sub__sub__code">
                carProd: "Mersedes",
            </p>
            <p class="code__any sub__sub__code">
                carModel: "SL900",
            </p>
            <p class="code__any sub__sub__code">
                color: "black",
            </p>
            <p class="code__any sub__sub__code">
                carYear: 2020,
            </p>
            <p class="code__any sub__sub__code">
                isSelled: true
            </p>
            <p class="code__any sub__code">
                },
            </p>
            <p class="code__any sub__code">
                {
            </p>
            <p class="code__any sub__sub__code">
                carProd: "Toyota",
            </p>
            <p class="code__any sub__sub__code">
                carModel: "Camry",
            </p>
            <p class="code__any sub__sub__code">
                color: "blue",
            </p>
            <p class="code__any sub__sub__code">
                carYear: 2019,
            </p>
            <p class="code__any sub__sub__code">
                isSelled: true
            </p>
            <p class="code__any sub__code">
                },
            </p>
            <p class="code__any sub__code">
                {
            </p>
            <p class="code__any sub__sub__code">
                carProd: "BMW",
            </p>
            <p class="code__any sub__sub__code">
                carModel: "X7",
            </p>
            <p class="code__any sub__sub__code">
                color: "white",
            </p>
            <p class="code__any sub__sub__code">
                carYear: 2021,
            </p>
            <p class="code__any sub__sub__code">
                isSelled: false
            </p>
            <p class="code__any sub__code">
                },
            </p>
            <p class="code__any sub__code">
                {
            </p>
            <p class="code__any sub__sub__code">
                carProd: "Audi",
            </p>
            <p class="code__any sub__sub__code">
                carModel: "A8L",
            </p>
            <p class="code__any sub__sub__code">
                color: "black",
            </p>
            <p class="code__any sub__sub__code">
                carYear: 2022,
            </p>
            <p class="code__any sub__sub__code">
                isSelled: false
            </p>
            <p class="code__any sub__code">
                }
            </p>
            <p class="code__any code">
                ];
            </p>
            <p class="code__any sub__code">
                for(let i = 0; i < cars.length; i++) {
            </p>
            <p class="code__any sub__code">
                if(cars[i].isSelled === false) {
            </p>
            <p class="code__any sub__sub__code">
                console.log(cars[i]);
            </p>
            <p class="code__any sub__code">
                }
            </p>
            <p class="code__any code">
                }
            </p>
        </div>
        <p class="main__par">
            <span class="tab">Для</span> работы с массивами можно использовать не только цикл <strong>for</strong>. Так же можно использовать цикл <strong>forEach</strong> (от англ. для каждого), код выглядит следующим образом:
        </p>
        <div class="code__block__any code__block__js">
            <p class="code__any code">
                cars.forEach(function(car) {
            </p>
            <p class="code__any sub__code">
                if(car.isSelled === false) {
            </p>
            <p class="code__any sub__sub__code">
                console.log(car);
            </p>
            <p class="code__any sub__code">
                }
            </p>
            <p class="code__any code">
                }
            </p>
        </div>
        <div id="objects__methods">&nbsp;</div>
        <h1 class="main__head">Методы объектов</h1>
        <p class="main__par">
            <span class="tab">Внутри</span> объектов можно прописывать функции, выполняющие те или иные действия. Например, вычисление скидки в зависимости от длительности регистрации пользователя. Рассмотрим это используя вышеприведенный пример с продавцами автомобилей. Если пользователь зарегистрирован на сайте меньше двух лет, то он не имеет никакой скидки. Если от двух до пяти лет, то у него есть скидка 20%, а если больше пяти, то 30%. И далее вызвать метод этого объекта в консоль. Код будет выглядеть следующим образом:
        </p>
        <div class="code__block__any code__block__js">
            <p class="code__any code">
                let carSeller1 = {
            </p>
            <p class="code__any sub__code">
                firstName: "Игорь",
            </p>
            <p class="code__any sub__code">
                lastName: "Курушин",
            </p>
            <p class="code__any sub__code">
                regYear: 2017,
            </p>
            <p class="code__any sub__code">
                hasDiscount: true,
            </p>
            <p class="code__any sub__code">
                discountCalculation: function(year) {
            </p>
            <p class="code__any sub__sub__code">
                let numberOfYears = 2022 - year;
            </p>
            <p class="code__any sub__sub__code">
                if(numberOfYears <= 2) {
            </p>
            <p class="code__any sub__sub__sub__code">
                discount = 0;
            </p>
            <p class="code__any sub__sub__code">
                } else if(numberOfYears > 2 && numberOfYears <= 5) {
            </p>
            <p class="code__any sub__sub__sub__code">
                discount = 20;
            </p>
            <p class="code__any sub__sub__code">
                } else if(numberOfYears > 5) {
            </p>
            <p class="code__any sub__sub__sub__code">
                discount = 30;
            </p>
            <p class="code__any sub__sub__code">
                }
            </p>
            <p class="code__any sub__code">
                return discount;
            </p>
            <p class="code__any sub__code">
                }
            </p>
            <p class="code__any code">
                }
            </p>
            <p class="code__any code break">
                console.log(carSeller1.discountCalculation(2019));
            </p>
        </div>
        <div id="this">&nbsp;</div>
        <h1 class="main__head">'this' в методе объекта</h1>
        <p class="main__par">
            <span class="tab">Как</span> можно заметить, в выше рассмотренном методе функции мы используем значение, которое можно получить из самого объекта. В данном примере внутриобъектной функции, мы используем параметр <strong>'year'</strong>, то есть год регистрации пользователя. Но так как в самом объекте уже есть свойство с годом регистрации, то нам необязательно использовать для функции параметр <strong>'year'</strong>. Мы можем обратиться непосредственно к свойству <strong>'regYear'</strong> внутри объекта через функцию. К этому свойству объекта внутри функции мы можем обратиться используя ключевое слово <strong>'this'</strong>. Выглядеть в этом случае и объект, и функция будут почти полностью идентично, поэтому не будем переписывать код рассмотренный выше. Отметим только, что теперь параметр функции указываться не будет – скобки после слова <strong>'function'</strong> будут оставаться пустыми, а объявленная нами переменная <strong>'numberOfYears'</strong> будет теперь выглядеть так: <span class="break">'let numberOfYears = this.regYear';</span></strong>. Теперь, чтобы получить результат выполнения функции, не нужно искусственно прописывать в коде вызова консоли параметр функции – функция будет брать данные для своей работы непосредственно из свойства объекта, то есть, из года регистрации пользователя.<br><br>
            <span class="tab">Но</span> мы можем пойти и еще дальше. Например, если выше описанный объект имеет свойство <strong>discount</strong>, в котором эта скидка указывается, например, по умолчанию скидка будет равна 0. А далее в коде мы можем объявить переменную <strong>'discount'</strong> и присвоить ей значение выше описанной функции с методом <strong>'this'</strong> и далее мы можем переменной <strong>'carSeller1.discount'</strong> присвоить значение переменной <strong>'discount'</strong>. То есть, мы присваиваем полю <strong>discount</strong> в объекте, значение, которое мы вычисляем с помощью выше описанной функции:
        </p>
        <div class="code__block__any code__block__js">
            <p class="code__any code">
                <span class="break">let discount = carSeller1.discountCalculation();</span>
            </p>
            <p class="code__any code">
                carSeller1.discount = discount;
            </p>
        </div>
        <p class="main__par">
            <span class="tab">Но</span> можно записать еще короче и сделать так, чтобы код обращался к объекту (carSeller1), затем к его свойству (discount) и отождествлял его с объектом (carSeller1), затем функцией (discountCalculation();). А затем вывести в консоль весь объект. В этом случае, будет выведен весь объект, а в нём автоматически прописываться вычисленный функцией процент скидки, в зависимости от года регистрации на сайте:
        </p>
        <div class="code__block__any code__block__js">
            <p class="code__any code">
                <span class="break">carSeller1.discount = carSeller1.discountCalculation();</span>
            </p>
        </div>
        <p class="main__par">
            <span class="tab">Но</span> можно пойти еще дальше по пути оптимизации. Для этого мы можем больше не использовать <strong>'return'</strong> в функции, а обратиться к полю объекта <strong>discount</strong>. Сделать это можно с помощью <strong>'this.discount = discount;'</strong>. То есть, мы присваиваем свойству значения <strong>discount</strong> присваиваем значение внутренней переменной <strong>'discount'</strong>. Теперь мы можем не присваивать полю ничего дополнительного – весь функционал будет осуществляться внутри объекта. Присвоение свойству <strong>discount</strong> нового значения при помощи свойства <strong>regYear</strong>. Итак, весь код для справки будет выглядеть так, для лучшего понимания, снова запишем:
        </p>
        <div class="code__block__any code__block__js">
            <p class="code__any code">
                let carSeller1 = {
            </p>
            <p class="code__any sub__code">
                firstName: "Игорь",
            </p>
            <p class="code__any sub__code">
                lastName: "Курушин",
            </p>
            <p class="code__any sub__code">
                regYear: 2010,
            </p>
            <p class="code__any sub__code">
                discount: 0,
            </p>
            <p class="code__any sub__code">
                calculateDiscount: function() {
            </p>
            <p class="code__any sub__sub__code">
                let discount;
            </p>
            <p class="code__any sub__sub__code">
                let numberOfYears = 2022 - this.regYear;
            </p>
            <p class="code__any sub__sub__code">
                if(numberOfYears <= 2) {
            </p>
            <p class="code__any sub__sub__sub__code">
                discount = 0;
            </p>
            <p class="code__any sub__sub__code">
                } else if(numberOfYears > 2 && numberOfYears <= 5) {
            </p>
            <p class="code__any sub__sub__sub__code">
                discount = 20;
            </p>
            <p class="code__any sub__sub__code">
                } else if(numberOfYears > 5) {
            </p>
            <p class="code__any sub__sub__sub__code">
                discount = 30;
            </p>
            <p class="code__any sub__sub__code">
                }
            </p>
            <p class="code__any sub__code">
                this.discount = discount;
            </p>
            <p class="code__any sub__code">
                }
            </p>
            <p class="code__any code">
                }
            </p>
            <p class="code__any code break">
                <span class="break">carSeller1.calculateDiscount();</span>
            </p>
            <p class="code__any code break">
                <span class="break">console.log(carSeller1);</span>
            </p>
        </div>
        <div id="dom">&nbsp;</div>
        <h1 class="main__head">DOM</h1>
        <p class="main__par">
            <span class="tab">Как</span> можно понять, JavaScript нужен, конечно, совсем не для того, чтобы выполнять какие-то игрушечные абстрактные задачи вроде выведения в консоль вычисления площади прямоугольника или содержимого массивов. JavaScript нужен для взаимодействия, а главное – управления HTML и CSS содержимым на веб-странице. Делается это с помощью понятия <strong>DOM</strong>, что означает <strong>Document Object Model</strong> (от англ. Объектная Модель Документа).
        </p>
        <div id="dom__selectors">&nbsp;</div>
        <h1 class="main__head">DOM. Селекторы</h1>
        <p class="main__par">
            <span class="tab">Для</span> доступа к различным HTML-элементам с помощью стандарта <strong>DOM</strong> точно так же, как и в случае с <strong>CSS</strong> используются <strong>селекторы</strong>. Существует несколько видов селекторов:
        </p>
        <ul class="list">
            <li>document.getElementById();</li>
            <li>document.getElementsByClassName();</li>
            <li>document.getElementsByTagName();</li>
            <li>document.querySelector();</li>
             <li>document.querySelectorAll();</li>
        </ul>
        <p class="main__par">
            <span class="tab">Начнем</span> с первого селектора – <strong>'document.getElementById();'</strong>. С помощью этого селектора, к примеру, можно заполнить любой тег на странице, которых до этого был пустым, допустим, параграф, где написано - "Привет, Мир!". Поскольку, как можно заметить, если попытаться развернуть и перевести название селектора (это будет "Получить элемент по ID"), то этому параграфу нужно своевременно (до выполнения кода), присвоить ID, по которому этот код будет выполняться. Выглядеть код будет так:<br>
            <span class="break tab"><strong>'document.getElementById("paragraph").innerHTML = "Привет, Мир!";'</strong></span>.<br><br><br><br>
            <span class="tab">Следующий</span> селектор <strong>'document.getElementByClassName();'</strong> – находит все элементы по имени указанного класса. То есть, мы можем присвоить HTML-элементам какие-то классы, а затем этот селектор способен возвращать их для дальнейшей с ними работы, например, изменения/добавления контента. Проще говоря, этот селектор занимается примерно тем же, что и классы в HTML – собирает в себя другие элементы, объединяя в группу. Принцип его работы состоит только в том, чтобы собрать по HTML-коду все элементы с прописанным (указанным) в селекторе классом, а затем возвратить (передать) эту информацию для дальнейшей работы кому-нибудь другому. Схема применения может выглядеть следующим образом:
        </p>
        <div class="code__block__any code__block__HTML">
            <p class="code__any code">
                &lt;!DOCTYPE html&gt;
            </p>
            <p class="code__any code">
                &lt;html lang="ru"&gt;
            </p>
            <p class="code__any code">
                &lt;head&gt;
            </p>
            <p class="code__any sub__code">
                &lt;meta charset="UTF-8"&gt;
            </p>
            <p class="code__any sub__code">
                &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
            </p>
            <p class="code__any sub__code">
                &lt;title&gt;DOM&lt;/title&gt;
            </p>
            <p class="code__any code">
                &lt;/head&gt;
            </p>
            <p class="code__any code">
                &lt;body&gt;
            </p>
            <p class="code__any sub__code">
                &lt;h2&gt;Поиск HTML элементов по имени класса&lt;/h2&gt;
            </p>
            <p class="code__any sub__code">
                &lt;p&gt;Привет, Мир!&lt;/p&gt;
            </p>
            <p class="code__any sub__code">
                &lt;p class="intro">DOM очень полезен.&lt;/p&gt;
            </p>
            <p class="code__any sub__code">
                &lt;p class="intro">Этот пример демонстрирует метод getElementByClassName.&lt;/p&gt;
            </p>
            <p class="code__any sub__code">
                &lt;p id="demo">&lt;/p&gt;
            </p>
            <p class="code__any sub__code">
                &lt;script&gt;
            </p>
            <p class="code__any sub__sub__code">
                let x = document.getElementByClassName("intro");
            </p>
            <p class="code__any sub__sub__code">
                document.getElementById("demo").innerHTML = 'Первый параграф (индекс 0) с классом="intro": ' + x[0].innerHTML;
            </p>
            <p class="code__any sub__code">
                &lt;/script&gt;
            </p>
            <p class="code__any code">
                &lt;/body&gt;
            </p>
            <p class="code__any code break">
                &lt;/html&gt;
            </p>
        </div>
        <div class="faq__any faq__flex">
               <img src="/instruction/img/faq.png">
               <p>*для справки: метод <strong>'.innerHTML'</strong> отвечает за отображение выбранного HTML-элемента. С помощью него, к примеру, можно обратиться, то есть прочесть и/или вывести контент любого тега и/или заменить его.
               </p>
        </div>
        <p class="main__par">
            <span class="tab">Принцип</span> работы этого кода довольно прост. В HTML мы создаем два параграфа заполненные текстом с классом <strong>'intro'</strong> и один пустой параграф с id <strong>'demo'</strong>. Далее мы объявляем переменную <strong>'x'</strong> и присваиваем ей значение в виде <span class="break"><strong>'document.getElementByClassName("intro");'</strong></span>, то есть переменная <strong>'x'</strong> теперь представляет тот контент, который входит в класс <strong>'intro'</strong>. Как и все прочие перечисления индексов элементов в JS, селекторы при работе с DOM не стали исключением и тоже отсчитываются от ноля. Далее мы вставляем в пустой параграф с id <strong>'demo'</strong> текст <strong>'Первый параграф (индекс 0) с классом="intro": '</strong> с помощью <strong>'document.getElementById("demo")'</strong> и приплюсовываем ко всему этому переменную <strong>'x[0]'</strong> с индексом 0, так как у нас два параграфа с классом <strong>'intro'</strong>, а исчисляются индексы, как говорилось выше, начиная от ноля, а затем вставляем всё это в тот же пустой параграф.<br><br>
            <span class="tab">Выглядит</span> запутано, но глядя на код выше и вчитываясь в это запутанную инструкцию (пусть даже придется прочесть не один раз), всё непременно будет ясно.<br><br><br><br>
            <span class="tab">Следующий</span> селектор в нашем списке – это <strong>document.getElementByTagName();</strong>. Этот селектор по принципу своего действия очень похож на предыдущий, но с одним, как можно догадаться по названию, отличием: он находит в документе HTML-теги. Можно сказать, что у этого и предыдущего селектора буквально один и тот же принцип действия, только в этот раз мы бы подставляли не класс, а название тега: параграф, заголовок и/или другие.<br><br><br><br>
            <span class="tab">Следующий</span> селектор выбора элементов – <strong>'document.querySelector();'</strong>. Этот селектор работает уже <strong>не с HTML-тегами</strong>, а <strong>с селекторами CSS</strong>. Как говорилось выше, JS позволяет работать (манипулировать/взаимодействовать) не только с HTML, но и CSS. К примеру, если у нас есть заголовок в HTML с id 'header', то с помощью этого селектора мы можем обратиться к нему точно так же, как в CSS, то есть: <strong>'document.querySelector("#header");'</strong>. Это актуально и в случае обращения к классу. Важно отметить, что при выборе селектором <strong>'querySelector'</strong> класса будут выбираться не все элементы с соответствующими классами, а только <strong>первое</strong> совпадение.<br><br>
            <span class="tab">Чтобы</span> выбрать все элементы с одинаковыми нужными нам классами или тегами, существует вариация селектора <strong>'querySelector'</strong> – <strong>'querySelectorAll'</strong>.
        </p>
        <div id="dom__changing__content"></div>
        <h1 class="main__head">DOM. Изменение контента</h1>
        <p class="main__par">
            <span class="tab">Рассмотрим</span>, как можно манипулировать полученными с помощью селекторов объектами.<br><br>
            <span class="tab">Как</span> уже говорилось выше, есть способ обратиться к содержимому HTML-элемента. Это делается с помощью свойства <strong>'.innerHTML'</strong>. Но есть и второй способ – это свойство <strong>'.textContent'</strong>. В чем же разница? Разница в том, что свойство <strong>'.innerHTML'</strong> занимается не только отображением "сухого" текста, то есть, буквально содержимого тега, а вообще всего, что касается этого тега. То есть, если рассмотреть принцип его работы на примере, допустим, тега <strong>'ul'</strong> – неупорядоченного списка – то как результат работы свойства <strong>'.innerHTML'</strong> (его возвращения), мы получим всю структуру тега <strong>'ul'</strong> с его дочерними элементами, текстом и всем прочим (к примеру, тегом strong). Свойство <strong>'.textContent'</strong> же занимается буквальным отображением текстового содержимого, где не будет ничего, кроме текста, который содержит тег, к которому совершено обращение. По этой причине, при изменении текста с помощью свойства <strong>'.innerHTML'</strong> нужно указывать не только текст, но и сам тег, текст внутри которого требуется изменить.
        </p>
        <div id="dom__changing__styles">&nbsp;</div>
        <h1 class="main__head">DOM. Изменение стилей</h1>
        <p class="main__par">
            <span class="tab">Изменение</span> стилей с помощью DOM и JS провернуть довольно просто. Допустим, в HTML документе у нас есть заголовок, у этого заголовка есть id="header". Чтобы изменить его стиль с помощью JS, код будет выглядеть следующим образом (для удобства запишем функцию с методом (селектором) как переменную):
        </p>
        <div class="code__block__any code__block__js">
            <p class="code__any code">
                let h1 = document.getElementById("header");
            </p>
            <p class="code__any code">
                h1.style.color = "red";
            </p>
        </div>
        <p class="main__par">
            <span class="tab">Этим</span> кодом мы через JS обратились по id к заголовку и стилизовали его, сделав его цвет красным.<br><br>
            <span class="tab">Кроме</span> того, исходя из концепции DOM, JS позволяет добавлять не существовавшие ранее классы. Для этого существует метод <span class="break"><strong>'.classList.add("название_нового_класса");'</strong></span>. У добавления/создания чего-либо, конечно, есть и обратное действие, для этого есть метод<span class="break"><strong>'.classList.remove("название_удаляемого_класса");'</strong></span>. 
            <span class="tab">Еще</span> один метод, который часто используют для добавления/удаления классов – это <span class="break"><strong>'.classList.toggle("название_класса");'</strong></span>. Этот метод работает как некий переключатель – при первом срабатывании он "включает" новый класс, создавая его, при втором, соответственно, "выключает", удаляя.
        </p>
        <div class="faq__any faq__flex">
               <img src="/instruction/img/faq.png">
               <p>*для справки: разумеется, используя все перечисленные методы для добавления и/или удаления классов, нужно использовать селекторы обращения к элементам. То есть, используя один из представленных выше методов, полная конструкция будет выглядеть так: <span class="break"><strong>'document.getElementById("некий_id").classList.toggle("некий_класс");'</strong></span>.
               </p>
        </div>
        <div id="dom__changing__attributes"></div>
        <h1 class="main__head">DOM. Изменение атрибутов</h1>
        <p class="main__par">
            <span class="tab">Концепцию</span> манипуляции с атрибутами было бы удобно рассмотреть с точки зрения такого явления в веб-разработке, как "Image Gallery" – галереи изображений. То есть, некой структуры (блока) на сайте, который включает в себя серию (набор) неких изображений, относящихся к тематике сайта. Эти изображения по нажатию, например, на некую кнопку перелистывания, требуется каким-то образом менять. Для этого и применяется методы изменения атрибутов.<br><br>
            <span class="tab">По</span> <button class="button" onclick="window.open('img.gallery.html')">этой</button> кнопке можно перейти на страницу, где можно увидеть готовую галерею изображений, а если открыть код страницы, то можно увидеть посредствам какого функционала она реализована.<br><br>
            <span class="tab">Итак</span>, для начала нам нужно добавить в HTML разметку наши изображения:
        </p>
        <div class="div__cats">
            <div class="cat"><img id="cats" src="/instruction/img/cat1.jpeg"></div>
            <div class="cat"><img id="cats" src="/instruction/img/cat2.jpeg"></div>
            <div class="cat"><img id="cats" src="/instruction/img/cat3.jpeg"></div>
            <div class="cat"><img id="cats" src="/instruction/img/cat4.jpeg"></div>
            <div class="cat"><img id="cats" src="/instruction/img/cat5.jpeg"></div>
        </div>
        <p class="main__par">
            <span class="tab">И</span> теперь, с помощью JS, мы можем воздействовать на них. Для начала нам нужно с помощью одного из уже известных селекторов обратиться к этим изображениям:
        </p>
        <div class="code__block__any code__block__js">
            <p class="code__any code">
                let cats = document.querySelector("#cats");
            </p>
            <p class="code__any code">
                cats[0].getAttribute("src");
            </p>
            <p class="code__any code">
                cats[0].setAttribute("src", "img/cat2.jpeg");
            </p>
        </div>
        <p class="main__par">
            <span class="tab">Как</span> видно из кода, с помощью объявленной переменной <strong>'cats'</strong> и индекса (порядкового номера) "0" мы обращаемся к атрибуту <strong>'src'</strong> первого изображения и получаем его. Затем мы меняем значение этого атрибута с помощью метода <strong>'.setAttribute'</strong>, у которого используется не только значение <strong>'src'</strong>, но и то значение, которое требуется заменить. В данном случае, это путь к новому изображению – <strong>'img/cat2.jpeg'</strong>.<br>
            <span class="tab">Точно</span> так же, мы можем менять и любой другой атрибут, к примеру атрибут ссылки – тега <strong>'a'</strong>:
        </p>
        <div class="code__block__any code__block__js">
            <p class="code__any code">
                let link = document.querySelector("#link");
            </p>
            <p class="code__any code">
                link[0].setAttribute("href", "http://ya.ru");
            </p>
        </div>
        <p class="main__par">
            <span class="tab">В</span> этом случае, если у нас есть некая ссылка с ID "link", у которой уже будет прописан некий URL, то он будет заменен на тот, что мы прописали, то есть на ya.ru.
        </p>
        <div id="dom__events">&nbsp;</div>
        <h1 class="main__head">DOM. Events</h1>
        <p class="main__par">
            <span class="tab">Что</span> такое "events"? Events в переводе с английского – события. То есть, мы можем изменять объекты DOM структуры с помощью JS по каким-то событиям. Схема организации реакции на какие-либо события выглядит следующим образом. Для начала нам, конечно, нужно выбрать какой-то элемент, с которым мы и будем работать. Затем, нужно добавить так называемого  <strong>Event Listener</strong> – прослушивателя события. Он через точку записывается после обращения к элементу, а после него в круглых скобках и кавычках пишется, непосредственно событие. Самое распространенное, к примеру <strong>'click'</strong>. Вторым элементом указывается функция, в которой мы пишем код, который будет запускаться, когда будет кликнут выбранный нами элемент. Ну а дальше всё как обычно из принципа работы функции. К примеру, изменим цвет заголовка на красный. Рассмотрим это на практике. Допустим, у нас есть элемент заголовка – <strong>h1</strong> с id "test". Код JS будет выглядеть следующим образом:
        </p>
        <div class="code__block__any code__block__js">
            <p class="code__any code">
                let h1 = document.getElementById("test");
            </p>
            <p class="code__any code">
                h1.addEventListener("click", function() {
            </p>
            <p class="code__any sub__code">
                this.style.color = (this.style.color == 'red') ? 'rgb(232, 230, 230)' : 'red';
            </p>
            <p class="code__any code">
                });
            </p>
        </div>
        <h1 class="main__head" id="head__toggle">Тестовый заголовок, меняющий цвет по нажатию!</h1>
        <script type="text/javascript">				 
            let colorToggle = document.getElementById("head__toggle");
            colorToggle.addEventListener("click", function() {
                this.style.color = (this.style.color == 'red') ? 'rgb(232, 230, 230)' : 'red';
                this.style.transition = '.5s ease-in-out';
            });
         </script>
         <p class="main__par">
            <span class="tab">Для</span> одного элемента мы можем устанавливать несколько <strong>Event Listener</strong>.<br><br>
            <span class="tab">Точно</span> такой же функционал, как и со сменой цвета заголовка из примера выше, мы можем цеплять и, к примеру, к кнопкам. Для наглядности и простоты, кнопка тоже будет менять цвет элемента. По нажатию она будет менять цвет фона всей страницы! А код будет выглядеть следующим образом (HTML-код мы поместим в синюю рамку, а JS-код в красную:
         </p>
         <div class="code__block__any code__block__HTML">
            <p class="code__any code">
                &lt;button class="button" id="button_test"&gt;Сменить цвет!&lt;/button&gt;
            </p>
            <p class="code__any code">
                this.style.transition = '.5s ease-in-out';
            </p>
        </div>
        <div class="code__block__any code__block__js">
            <p class="code__any code">
                let button = document.getElementById("button_test");
            </p>
            <p class="code__any code">
                let container = document.getElementById("container");
            </p>
            <p class="code__any code">
                let body = document.getElementById('body');
            </p>
            <p class="code__any code">
                let isButtonApplied = false;
            </p>
            <p class="code__any code">
                button.addEventListener("click", function() {
            </p>
            <p class="code__any sub__code">
                if(isButtonApplied === false) {
            </p>
            <p class="code__any sub__sub__code">
                container.style.background = "black";
            </p>
            <p class="code__any sub__sub__code">
                container.style.transition = 'background 2.5s ease-in-out';
            </p>
            <p class="code__any sub__sub__code">
                button.style.boxShadow = "0 0 10px rgba(255, 255, 255, 1)";
            </p>
            <p class="code__any sub__sub__code">
                body.style.transition = "color 3.5s ease-in-out";
            </p>
            <p class="code__any sub__sub__code">
                body.style.color = "red";
            </p>
            <p class="code__any sub__sub__code">
                setTimeout(() => {body.style.background = 'rgba(0, 0, 0, .9)', body.style.transition = 'background 1s ease-in-out';}, 2500);
            </p>
            <p class="code__any sub__sub__code">
                isButtonApplied = true;
            </p>
            <p class="code__any sub__code">
                } else if (isButtonApplied === true) {
            </p>
            <p class="code__any sub__sub__code">
                container.style.background = "linear-gradient(90deg, rgba(224, 0, 255, 0.5) -15%, rgba(179, 90, 195, 0.5) 48%, rgba(20, 138, 227, 0.5) 100%)";
            </p>
            <p class="code__any sub__sub__code">
                container.style.transition = 'background 2.5s ease-in-out';
            </p>
            <p class="code__any sub__sub__code">
                button.style.boxShadow = "0 0 15px rgba(0, 0, 0, 1)";
            </p>
            <p class="code__any sub__sub__code">
                body.style.color = "rgba(232, 230, 230, 1)";
            </p>
            <p class="code__any sub__sub__code">
                body.style.transition = "color 3.5s ease-in-out";
            </p>
            <p class="code__any sub__sub__code">
                setTimeout(() => {body.style.transition = 'background 1s ease-in-out', body.style.background = 'linear-gradient(90deg, rgba(59, 9, 121, 1) -40%, rgba(147, 0, 255, 1) 48%, rgba(207, 0, 255, 0.5) 100%)';}, 2500);
            </p>
            <p class="code__any sub__sub__code">
                isButtonApplied = false;
            </p>
            <p class="code__any sub__code">
                }
            </p>
            <p class="code__any code">
                });
            </p>
        </div>
        <div style="display: flex; justify-content: center; align-items: center; margin-block: 5rem;">
            <button class="button" id="button_test" style=" width: 10em; height: 4em; min-width: 200px; font-size: 2rem; box-shadow: 0 0 10px rgba(0, 0, 0, 1);">Сменить цвет!</button>
        </div>
        <script type="text/javascript">
            let button = document.getElementById("button_test");
            let container = document.getElementById("container");
            let body = document.getElementById('body');
            let isButtonApplied = false;
            button.addEventListener("click", function() {
                if(isButtonApplied === false) {
                    container.style.background = "black";
                    container.style.transition = 'background 2.5s ease-in-out';

                    button.style.boxShadow = "0 0 10px rgba(255, 255, 255, 1)";

                    body.style.transition = "color 3.5s ease-in-out";
                    body.style.color = "red";

                    setTimeout(() => {body.style.background = 'rgba(0, 0, 0, .9)', body.style.transition = 'background 1s ease-in-out';}, 2500);
                    
                    isButtonApplied = true;

                } else if(isButtonApplied === true) {
                    container.style.background = "linear-gradient(90deg, rgba(224, 0, 255, 0.5) -15%, rgba(179, 90, 195, 0.5) 48%, rgba(20, 138, 227, 0.5) 100%)";
                    container.style.transition = 'background 2.5s ease-in-out';

                    button.style.boxShadow = "0 0 15px rgba(0, 0, 0, 1)";

                    body.style.color = "rgba(232, 230, 230, 1)";
                    body.style.transition = "color 3.5s ease-in-out";

                    setTimeout(() => {body.style.transition = 'background 1s ease-in-out', body.style.background = 'linear-gradient(90deg, rgba(59, 9, 121, 1) -40%, rgba(147, 0, 255, 1) 48%, rgba(207, 0, 255, 0.5) 100%)';}, 2500);
                    
                    isButtonApplied = false;
                }
            });
        </script>
        <div id="js__game">&nbsp;</div>
        <h1 class="main__head">Финал JS. Игра на реакцию</h1>
        <p class="main__par">
            <span class="tab">Внимательно</span> смотрите за кодом, как и обычно HTML-код мы разместим внутри синей рамки, JS-код в красной, а CSS будет в зеленой:
        </p>
        <div class="code__block__any code__block__HTML">
            <p class="code__any code">
                &lt;div id="shape"&gt;&lt;/div&gt;
            </p>
            <p class="code__any code">
                &lt;h3&gt;Время реакции &lt;span id="reactionTime"&gt;&lt;/span&gt;&lt;/h3&gt;
            </p>
        </div>
        <div class="code__block__any code__block__CSS">
            <p class="code__any code">
                #shape {
            </p>
            <p class="code__any sub__code">
                width: 150px;
            </p>
            <p class="code__any sub__code">
                height: 150px;
            </p>
            <p class="code__any sub__code">
                background-color: green;
            </p>
            <p class="code__any sub__code">
                display: none;
            </p>
            <p class="code__any sub__code">
                position: relative;
            </p>
            <p class="code__any sub__code">
                }
            </p>
        </div>
        <div class="code__block__any code__block__js">
            <p class="code__any code">
                let startTime = new Date().getTime();
            </p>
            <p class="code__any code">
                function getRandomColor() {
            </p>
            <p class="code__any sub__code">
                let letters = "0123456789ABCDEF".split('');
            </p>
            <p class="code__any sub__code">
                let color = "#";
            </p>
            <p class="code__any sub__code">
                for(let i = 0; i < 6; i++) {
            </p>
            <p class="code__any sub__sub__code">
                color += letters[Math.floor(Math.random() * 16)];
            </p>
            <p class="code__any sub__code">
                }
            </p>
            <p class="code__any sub__code">
                return color;
            </p>
            <p class="code__any code">
                let makeShapeVisible = function() {
            </p>
            <p class="code__any sub__code">
                let shape = document.getElementById("shape");
            </p>
            <p class="code__any sub__code">
                let top = Math.random() * 400;
            </p>
            <p class="code__any sub__code">
                let left = Math.random() * 700;
            </p>
            <p class="code__any sub__code">
                let width = Math.random() * 200 + 50;
            </p>
            <p class="code__any sub__code">
                shape.style.top = top + "px";
            </p>
            <p class="code__any sub__code">
                shape.style.left = left + "px";
            </p>
            <p class="code__any sub__code">
                shape.style.width = width + "px";
            </p>
            <p class="code__any sub__code">
                if(Math.random() > 0.3) {
            </p>
            <p class="code__any sub__sub__code">
                shape.style.borderRadius = "50%";
            </p>
            <p class="code__any sub__sub__code">
                shape.style.borderBottom = "0";
            </p>
            <p class="code__any sub__sub__code">
                shape.style.backgroundColor = getRandomColor();
            </p>
            <p class="code__any sub__code">
                } else if(Math.random() >= 0.3 && Math.random() <= 0.7) {
            </p>
            <p class="code__any sub__sub__code">
                shape.style.borderRadius = "0";
            </p>
            <p class="code__any sub__sub__code">
                shape.style.backgroundColor = getRandomColor();
            </p>
            <p class="code__any sub__sub__code">
                shape.style.borderRadius = "0";
            </p>
            <p class="code__any sub__code">
                } else if(Math.random() > 0.7) {
            </p>
            <p class="code__any sub__sub__code">
                shape.style.left = "0";
            </p>
            <p class="code__any sub__sub__code">
                shape.style.right = "0";
            </p>
            <p class="code__any sub__sub__code">
                shape.style.borderLeft = "50px solid transparent";
            </p>
            <p class="code__any sub__sub__code">
                shape.style.borderReft = "50px solid transparent";
            </p>
            <p class="code__any sub__sub__code">
                shape.style.borderBottom = "100px solid " + getRandomColor();
            </p>
            <p class="code__any sub__sub__code">
                shape.style.backgroundColor = "transparent";
            </p>
            <p class="code__any sub__code">
                }
            </p>
            <p class="code__any sub__code">
                shape.style.display = "block";
            </p>
            <p class="code__any sub__code">
                startTime = new Date().getTime();
            </p>
            <p class="code__any code">
                }
            </p>
            <p class="code__any code">
                setTimeout(makeShapeVisible, Math.random() * 1000);
            </p>
            <p class="code__any code">
                document.getElementById("shape").onclick = function() {
            </p>
            <p class="code__any sub__code">
                let shape = document.getElementById("shape");
            </p>
            <p class="code__any sub__code">
                shape.style.display = "none";
            </p>
            <p class="code__any sub__code">
                let finishTime = new Date().getTime();
            </p>
            <p class="code__any sub__code">
                let reactionTime = (finishTime - startTime) / 1000;
            </p>
            <p class="code__any sub__code">
                document.getElementById("reactionTime").innerHTML = reactionTime + " секунд";
            </p>
            <p class="code__any sub__code">
                setTimeout(makeShapeVisible, Math.random() * 1000);
            </p>
            <p class="code__any code">
                }
            </p>
        </div>
        <h3 class="main__head">Время реакции <span id="reactionTime"></span></h3>
        <div>
            <div id="shape"></div>
            <script type="text/javascript">
               let startTime = new Date().getTime();
               
               function getRandomColor() {
               
                   let letters = "0123456789ABCDEF".split('');
                   let color = "#";
               
                   for(let i = 0; i < 6; i++) {
                       color += letters[Math.floor(Math.random() * 16)];
                   }
                   return color;
               }
               
               let makeShapeVisible = function() {
               
                   let shape = document.getElementById("shape");
                   let top = Math.random() * 400;
                   let left = Math.random() * 150;
                   let width = Math.random() * 200 + 50;
                   shape.style.top = top + "px";
                   shape.style.left = left + "px";
                   shape.style.width = width + "px";
               
                   if(Math.random() > 0.3) {
                       shape.style.borderRadius = "50%";
                       shape.style.borderBottom = "0";
                       shape.style.backgroundColor = getRandomColor();
                   } else if(Math.random() >= 0.3 && Math.random() <= 0.7) {
                       shape.style.borderRadius = "0";
                       shape.style.backgroundColor = getRandomColor();
                       shape.style.borderRadius = "0";
                   } else if(Math.random() > 0.7) {
                       shape.style.left = "0";
                       shape.style.left = "0";
                       shape.style.borderLeft = "50px solid transparent";
                       shape.style.borderReft = "50px solid transparent";
                       shape.style.borderBottom = "100px solid " + getRandomColor();
                       shape.style.backgroundColor = "transparent";
                   }
               
                   shape.style.display = "block";
                   startTime = new Date().getTime();
               }
               
               setTimeout(makeShapeVisible, Math.random() * 1000);
               
               document.getElementById("shape").onclick = function() {
               
               let shape = document.getElementById("shape");
               shape.style.display = "block";
               
               let finishTime = new Date().getTime();
               let reactionTime = (finishTime - startTime) / 1000;
               document.getElementById("reactionTime").innerHTML = reactionTime + " секунд";
               setTimeout(makeShapeVisible, Math.random() * 1000);
               }
            </script>
            <br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>
        </div>
        <p class="main__par">
            <span class="tab">На</span> этом наше увлекательное путешествие по миру базовых знаний JavaScript подошло к концу. Помните, что всё, что здесь написано, лишь очень незначительная попытка показать, что из себя представляет этот язык, но никак не полное руководство по нему. Далее мы будем смотреть на популярную библиотеку JavaScript, которая называется <button onclick="window.location.href='/instruction/index.jquery.html'" class="button">jQuery</button>.
        </p>







    </div>



    <div id="bottom"></div>


    <footer>2023 &copy; Literarum</footer>
    <script src="/js/script.js"></script>
    <script src="/instruction/js/script.js"></script>
</body>
</html>