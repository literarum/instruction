<!DOCTYPE html>
<html lang="ru">
   <head>
      <meta charset="UTF-8">
      <meta name="viewport" content="width=device-width, initial-scale=1">
      <link rel="stylesheet" type="text/css" href="/instruction/css/style.css">
      <link rel="stylesheet" type="text/css" href="../css/style.css">
      <link rel="shortcut icon" href="/instruction/img/ico.png" type="image/png">
      <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.6.1/jquery.min.js"></script>
      <link rel="preconnect" href="https://fonts.googleapis.com">
      <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
      <link href="https://fonts.googleapis.com/css2?family=Caveat&display=swap" rel="stylesheet">
      <link rel="stylesheet" href="https://ajax.googleapis.com/ajax/libs/jqueryui/1.13.2/themes/smoothness/jquery-ui.css">
      <script src="https://ajax.googleapis.com/ajax/libs/jqueryui/1.13.2/jquery-ui.min.js"></script>
	  <link rel="stylesheet" href="/instruction/css/normalize.min.css">
      <script type="text/javascript">
         $(function(){
         	$('a[href^="#"]').click(function(){
         		var target = $(this).attr('href');
         		$('html, body').animate({scrollTop: $(target).offset().top}, 500);//800 - длительность скроллинга в мс
         		return false;
         	});
         });
      </script>
      <title>SOME MANUAL</title>
   </head>

   <body>


    
        <header class="header" id="header">
            <a href="#" class="header__logo"><img class="header__img" src="/instruction/img/logo.png" alt=""></a>
            <nav class="header__nav">
                <ul class="header__list">
                    <li class="header__item"><a href="#main_h1" class="header__link">К началу</a></li>
                    <li class="header__item"><a href="#table_of_contents_down" class="header__link">Вниз</a></li>
                    <li class="header__item"><a href="#clockers" class="header__link">Часы</a></li>
                </ul>
            </nav>
        </header>

        <p class="main_p", id="up">Make Web-Sites not War</p>

        <div class="nav__side">
            <div class="nav__up"><a href="#header">Up</a></div>
            <div class="nav__down"><a href="#table_of_contents_down">Down</a></div>
        </div>
  
        <div class="main_div">
  
            <div id="div_table_of_contents">
               <p id="table_of_contents_up"><a href="#table_of_contents_up" id="table_of_contents_up_a">Верхнее оглавление</a></p>
               <ul id="top_ul">
                  <li><a href="#table_of_contents_down" id="header_table">Нижнее оглавление</a></li>
                  <p id="table_up_down"><a href="#table_of_contents_downer" id="table_of_contents_upper">Нижняя часть оглавления</a></p>
                  <p id="table_up_down"><a href="#main_h1">Красивое слово "Инструкция"</a></p>
                  <p id="table_up_down"><a href="#introduction">Введение</a></p>
                  <li>
                     <a href="#tom1" id="header_table">Том I. HTML5</a>
                     <ul id="decor">
                        <li><a href="#general_html">Общие положения</a></li>
                        <li><a href="#lists">Списки и инструменты форматирования документа</a></li>
                        <li><a href="#tables">Таблицы</a></li>
                        <li><a href="#tags">Ссылки</a></li>
                        <li><a href="#forms">Формы</a></li>
                        <li><a href="#semant">Видео, аудио и семантические элементы</a></li>
                     </ul>
                  </li>
                  <li>
                     <a href="#tom2" id="header_table">Том II. CSS</a>
                     <ul id="decor">
                        <li><a href="#general_css">Общие положения</a></li>
                        <li><a href="#advanced_selectors">Немного о продвинутых селекторах</a></li>
                     </ul>
                  </li>
                  <li>
                     <a href="#tom3" id="header_table">Том III. JavaScript</a>
                     <ul id="decor">
                        <li><a href="#general_js">Общие положения</a></li>
                        <li><a href="#variables">Переменные в JavaScript</a></li>
                        <li><a href="#built_methods">Встроенные методы</a></li>
                        <li><a href="#order_operators">Порядок операторов в JavaScript</a></li>
                        <li><a href="#if_else">Условные операторы в JavaScript. If/Else</a></li>
                        <li><a href="#ternary">Тернарный оператор</a></li>
                        <li><a href="#switch">Оператор Switch</a></li>
                        <li><a href="#while">Цикл While</a></li>
                        <li><a href="#for">Цикл For</a></li>
                        <li>
                           <a href="#functions">Функции</a>
                           <ul>
                              <li><a href="#function_param">Параметры (аргументы) функции</a></li>
                              <li><a href="#returns">Возвращаемые значения функции</a></li>
                              <li><a href="#statements">Statemens vs. Expressions</a></li>
                              <li><a href="#func_ex">Различные примеры реализации функций</a></li>
                           </ul>
                        </li>
                        <li><a href="#area_of_vis">Область видимости переменных</a></li>
                        <li>
                           <a href="#massives">Массивы</a>
                           <ul>
                              <li><a href="#massive_methods">Методы массивов</a></li>
                           </ul>
                        </li>
                        <li><a href="#objects">Объекты</a></li>
                        <li><a href="#objects_massives">Массивы или объекты?</a></li>
                        <li>
                           <a href="#objects_methods">Методы объктов</a>
                           <ul>
                              <li><a href="#this">'this' в методе объекта</a></li>
                           </ul>
                        </li>
                        <li>
                           <a href="#dom">DOM</a>
                           <ul>
                              <li><a href="#dom_selectors">DOM. Селекторы</a></li>
                              <li><a href="#dom_changing_content">DOM. Изменение контента</a></li>
                              <li><a href="#dom_changing_styles">DOM. Изменение стилей</a></li>
                              <li><a href="#dom_changing_attributes">DOM. Изменение атрибутов</a></li>
                              <li><a href="#dom_events">DOM. Events</a></li>
                           </ul>
                        </li>
                        <li><a href="#js_game">Финал JS. Игра на реакцию на web-странице</a></li>
                     </ul>
                  </li>
                  <li>
                     <a id="header_table" href="#tom4">Том IV. jQuery</a>
                     <ul id="decor">
                        <li><a href="#jquery_basics">Общие положения</a></li>
                        <li><a href="#jquery_selector">Селектор</a></li>
                        <li><a href="#jquery_css_method">Метод css()</a></li>
                        <li><a href="#jquery_html_method">Метод html()</a></li>
                        <li><a href="#jquery_attr_method">Метод attr()</a></li>
                        <li><a href="#jquery_val_method">Метод val()</a></li>
                        <li><a href="#jquery_click_method">Метод click()</a></li>
                        <li><a href="#jquery_keypress_method">Метод keypress()</a></li>
                        <li><a href="#jquery_on_method">Метод on()</a></li>
                        <li><a href="#jquery_effects">Эффекты</a></li>
                        <li><a href="#shopping_list">Приложение "Список покупок"</a></li>
                     </ul>
                  </li>
                  <li>
                    <a id="header_table" href="#tom5">Том V. Bootstrap</a>
                     <ul id="decor">
                        <li><a href="#bootstrap__general">Общие положения</a></li>
                        <li><a href="#bootstrap__responsive_design">Responsive Design</a></li>
                        <li><a href="#bootstrap__grid">Grid</a></li>
                        <li><a href="#bootstrap__topography">Topography</a></li>
                        <li><a href="#bootstrap__nav__bar">Nav Bar</a></li>
                        <li><a href="#bootstrap__forms__tables">Формы и таблицы</a></li>
                        <li><a href="#"></a></li>
                        <li><a href="#"></a></li>
                        <li><a href="#"></a></li>
                        <li><a href="#"></a></li>
                        <li><a href=""></a></li>
                     </ul>
                  </li>
                  <li><a href="#bottomm" id="header_table">Конец</a></li>
                  <li><a href="#clockers" id="header_table">Часы</a></li>
                  <p id="table_up_down"><a href="#table_of_contents_up" id="table_of_contents_downer">Верхняя часть оглавления</a></p>
               </ul>
            </div>
  
            <div class="intro">
                <div class = "main_h1_1" id="main_h1">
                   <h1><span class="span__main__h1">это</span>Инструкция</h1>
                </div>
                <div class="main_h1_2">
                   <h1>или краткий (а иногда не очень краткий) справочник при обучении</h1>
                </div>
               <p class="post_pre_chap_6">
                  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Теперь, после того, как вы посмотрели на красивое слово "ИНСТРУКЦИЯ" и я выпендрился тем, что я умею делать в CSS, можно начать...<br>
                  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;На этой странице описаны некоторые базовые HTML и CSS элементы, которые в дальнейшем должны использоваться для форматирования текста, базовой разметки, верстки и стилизации всех элементов web-страницы. Здесь есть и базовые знания из JavaScript и jQuery, которые должны дать странице интерактивность. Если вы не захотите рассматривать CSS, то здесь есть раздел, посвященный Bootstrap – фреймворку, позволяющему маскимально быстро создавать адаптивные веб страницы, пользуясь только HTML. Кроме этого, в этом документе описаны не только базовые знания фронтенд разработки, но и начало бекэнда, но об этом позже...<br>
                  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Есть самонадеянная версия, что вам даже будет достаточно прочесть эту инструкцию (и используя её попробовать сделать что-то своими руками) для того, чтобы самостоятельно чему-то научиться (но это не точно).
               </p>
               <h3 id="introduction" class="pre_chap_6">Введение</h3>
               <p class = "post_pre_chap_6">
                  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Итак, раз уж это какая-никакая, но, допустим, инструкция, в таком случае, поговорим о том месте, где можно писать какой-то код. Строго говоря, место, где можно писать какой-то код никто строго не регламентирует: всё вполне выполнимо и в любом текстовом редакторе на вашем компьютере. Здесь встаёт только вопрос удобства, оптимизации и эффективности вашего труда, а он в этом деле далеко не на последнем месте. Учитывая это, мы выберем специальную среду, специальное место, в нашем случае, приложение, которое позволит нам писать код. Это место называется IDE (Integrated Development Environment) — интегрированная среда разработки или просто среда разработки.<br>
                  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;За свою скромную историю "айтишника" я пользовался двумя IDE — это Sublime Text и Visual Studio Code, но и та, и другая хороши. Sublime, к примеру, хорош своей простотой, минимализмом и "ненавязчивостью" в функционале. По моим ощущениям, он очень близок к обычному текстовому редактору, но с подсветкой синтаксиса и возможностью установки плагинов. VS Code хорош мощным функционалом по синхронизации изменений с внешними репозиториями (GIT), огромным сообществом разработчиков как самого приложения, так и программистов, которые сами работают в этой среде, а так же весьма и весьма гибкой настройкой. Но что самое приятное — VS Code полностью бесплатен. Строго говоря, горячо дискутировать над вопросом выбора IDE я не вижу большого смысла <del>VS Code лучше</del>, так как для меня это всё равно в каком-то смысле остается вкусовщиной, да и пришли мы сюда не за этим. Поскольку в последнее время я сам работаю в VS Code, то и рассказывать о начале работы тоже буду относительно этой среды. Мы сейчас опустим вопрос обширной пачки плагинов для комфортной работы (тоже доступны бесплатно), об этом можно и самостоятельно прочесть в интернете, что я рекомендую сделать в перспективе. Главное, что в VS Code и так по умолчанию встроен самый нужный для счастья плагин — это Emmet. Этот плагин позволяет автоматически дописывать за вас код, как попробуете сами — всё поймете. Теперь приступим.<br><br>
                  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Итак, для работы необходимо где-то взять IDE, иначе зачем я всё это говорил. Но сразу уточню, что раз уж вы дошли до того, что читаете эту инструкцию, то, я думаю, нагуглить то, что вас интересует вы вполне в состоянии, поэтому никаких ссылок я здесь приводить не буду. Скачать VS Code очень просто: вы пишете в поисковой строке "Скачать VS Code", переходите по первой ссылке и выбираете свою операционную систему. Далее следует установка — здесь всё как обычно, вы и так всё сами знаете. После успешной загрузки и установки программы, вы сразу можете приступить к работе.<br><br>
                  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Установив и открыв программу, вы обнаружите – перед вами самая настоящая IDE. Первое, что следует сделать — это создать репозиторий (общее хранилище) со всеми вашими файлами проекта — есть способ сделать это быстро и удобно. Для начала вы создаете папку где-то в дисковом пространстве вашего компьютера. Любую папку — она может называться как угодно, однако в программировании предпочтительнее называть любые файлы на английском языке. А дальше магия удобства: создав папку, вы просто перетаскиваете её в открытое окно VS Code. После этого программа определит, что в нее попала папка и позволит работать с ней. Далее вам нужно создать файл для HTML разметки.<br>
                  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Если вы обратили внимание, в левой части пространства VS Code есть вертикальное меню, где есть несколько значков: листы бумаги, лупа и так далее. У вас по умолчанию должен быть выбран первый, а если нет – нажмите на него. Откроется подменю, которое называется "Проводник". Ниже в нем находится структура вашего репозитория — все будущие файлы и папки, которые вы создадите и с которыми будете работать. Итак, вы должны перевести мышь в область проводника и в верхней его части нажать на иконку с листком бумаги и знаком "+". Если описание не слишком ясно – не торопитесь, посмотрите внимательнее. Одно я знаю наверняка одно: та кнопка, что вам нужна, находится прямо рядом с названием основной (корневой) папки вашего репозитория. Ищите. Нажав на кнопку "Создать файл", VS Code сразу предложит вам назвать его и вы немедленно называете его простым именем — "index.html". А .html, как можно догадаться, и есть формат документа языка разметки, который нам нужен. Voilà (вуаля), вы молодец и создали свой первый репозиторий и даже HTML-файл в нем. <del>Теперь нам нужно сделать ещё огромную кучу всего, это еще даже не вершина айсберга...</del> Теперь дело за малым, вы молодец, у вас всё прекрасно получается!<br><br>
                  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Создав файл в нужном нам расширении, вы окажетесь внутри него. VS Code умен и понимает, что если вы создали файл с каким-то расширением, то, скорее всего, вы хотите писать код именно на языке, которому это расширение и принадлежит. Удобно? Удобно. Идем дальше. Теперь, хвала небесам, у нас есть встроенный плагин Emmet, помните, я говорил выше? Благодаря нему мы можем сотворить еще одну небольшую магию. Нажмите на восклицательный знак, а затем на клавишу ENTER или TAB. Чудо! У вас развернулся базовый HTML шаблон, который должен выглядеть так:
                </p>
                <div id="code_block">
                  <p class="code">
                     &lt;!DOCTYPE html&gt;
                  </p>
                  <p class="code">
                     &lt;html lang="en"&gt;
                  </p>
                  <p class="sub_code">
                     &lt;head&gt;
                  </p>
                  <p class="sub_sub_code">
                     &lt;meta charset="UTF-8"&gt;
                  </p>
                  <p class="sub_sub_code">
                     &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt;
                  </p>
                  <p class="sub_sub_code">
                     &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
                  </p>
                  <p class="sub_sub_code">
                     &lt;title&gt;Document&lt;/title&gt;
                  </p>
                  <p class="sub_code">
                     &lt;/head&gt;
                  </p>
                  <p class="code">
                     &lt;body&gt;
                  </p>
                  <p class="code">

                  </p>
                  <p class="code">&lt;/body&gt;</p>
                  <p class="code">
                     &lt;/html&gt;
                  </p>
                </div>
                <p class="post_pre_chap_6">
                  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;А теперь не пугайтесь, я расскажу вам о том, что там написано, но для начала важно отметить один момент. Присмотритесь к структуре, которую вы только что создали. Вы можете заметить, что она состоит из элементов, которые заключены между символами <strong> &lt;</strong> ;&nbsp;&nbsp;и;&nbsp;&nbsp; <strong>&gt;</strong>. Эти элементы называются HTML-тегами или просто тегами. Некоторые (а в дальнейшем вы поймете, что почти все) имеют одинаковые (зеркальные) названия. То есть, зачастую есть так называемые открывающие теги, например, тег &lt;body&gt;, и у него есть закрывающий (зеркальный) брат — тег &lt;/body&gt;, только у закрывающего, как можно заметить, перед названием тега ставится знак "/". Не все теги в HTML являются зеркальными, однако бо́льшая их часть — да. Этот принцип стоит запомнить, он важен.<br><br>
                  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Итак, первая строка — это &lt;!DOCTYPE html&gt;. Внимательно присмотритесь к тому, что там написано. Ключевое слово DOCTYPE в файле HTML — это декларация типа документа. Это называется DTD (Document Type Definition — описание типа документа). Указание этого элемента важно и даже необходимо для того, чтобы браузер понимал, как следует интерпретировать текущую веб-страницу, так как HTML существует в нескольких версиях. Кроме того существует еще и язык XHTML (EXtensible HyperText Markup Language — расширенный язык разметки гипертекста), похожий на HTML, но различающийся с ним по синтаксису (способу написания кода). Так вот, чтобы браузер «не путался» и понимал, согласно какому стандарту отображать веб-страницу и необходимо в первой строке кода задавать &lt;!DOCTYPE html&gt;.<br><br>
                  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Далее идет &lt;html lang="en"&gt;. Как можно заметить, здесь применен тег &lt;html&gt; и он как раз-таки зеркальный. Внутри первого (открывающего) тега есть так называемый атрибут. Атрибуты используются для определения характеристик html-элементов и всегда помещаются внутри открывающего тега. Все атрибуты состоят из двух частей — это его имя и значение. Сразу скажу, что для и так большого количества тегов, существует не меньшее (огромное) количество самых разных атрибутов. В дальнейшем будут их примеры. Но возвращаясь к нашему разговору об &lt;html lang="en"&gt;... Как можно заметить, внутри этого тега присутствует атрибут <strong>'lang'</strong> со значением <strong>'en'</strong>. Это так называемый глобальный языковой атрибут, который помогает определить язык элемента. К примеру, текст документа может быть набран как на одном языке, так и содержать вставки на других языках, которые могут различаться по своим правилам оформления текста. Например, для русского, немецкого и английского языка характерны разные кавычки, в которые берется цитата. Чтобы указать язык, на котором написан текст внутри текущего элемента и применяется атрибут lang. Браузер использует его значение для правильного отображения некоторых символов.<br><br>
                  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Далее идет тег &lt;head&gt;, что буквально переводится как "голова". Тег &lt;head&gt; предназначен для хранения других элементов, цель которых — помочь браузеру в работе с данными. Также внутри контейнера &lt;head&gt; находятся метатеги, речь о некоторых из которых пойдет дальше. Они используются для хранения информации предназначенной для браузеров и поисковых систем. Например, механизмы поисковых систем обращаются к метатегам для получения описания сайта, ключевых слов и других данных. Иначе говоря, он предназначен для хранения служебной информации о странице. Тег &lt;head&gt; тоже является зеркальным и <strong>всегда</strong> располагается перед тегом &lt;body&gt;. Содержимое тега &lt;head&gt; не отображается напрямую на веб-странице, за исключением тега &lt;title&gt; устанавливающего заголовок окна веб-страницы.<br><br>
                  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Первым внутри тега &lt;head&gt; в нашей свежесозданной структуре находится тег &lt;meta&gt;. Это первый тег так называемых метаданных. Что такое метаданные? Это информация о другой информации, или данные, относящиеся к дополнительной информации о содержимом или объекте. Тег &lt;meta&gt; не является зеркальным. Внутри этого тега есть атрибут <strong>'charset'</strong> со значением <strong>UTF-8</strong>. Здесь всё просто: атрибут <strong>'charset'</strong> — это атрибут выбора кодировки, ну а его имя, как не сложно догадаться — это само название выбранной кодировки. На всякий случай уточню, что такое кодировка. Кодировка — это соответствие между визуальными символами и числами. Кодировки необходимы, так как компьютеры созданы для работы с числами и не понимают текст.<br><br>
                  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Следующая строка — &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt;. С тегом &lt;meta&gt; познакомиться мы уже успели выше, поэтому сразу перейдем к его атрибутам в этой строке. Первый атрибут — <strong>'http-equiv'</strong> со значением <strong>'X-UA-Compatible'</strong>. Атрибут <strong>'http-equiv'</strong> — это эквивалент заголовка HTTP-сервера (однако, имеющий более низкий приоритет перед заголовком, генерируемым самим сервером). Информация, содержащаяся в нём, добавляется в заголовок отклика HTTP и отсылается клиенту перед самой передачей HTML-документа. Не вдаваясь в слишком глубокие технические подробности скажу, что эта строка важна для работы с различными версиями Internet Explorer. Скажу даже больше: чтобы вас не грузить слишком уж большим объемом технической информации, я даже не буду расшифровывать все тезисы, которые я ввёл. Если вам интересно максимально подробно рассмотреть функции этих атрибутов с их значениями (и всё прочее), вы всегда можете воспользоваться гуглом.<br><br>
                  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Итак наша следующая остановка – строка кода &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;. Здесь всё просто. Этот тег указывает браузеру на то, чтобы в качестве ширины области просмотра использовалась ширина экрана устройства, а не значение браузера по умолчанию, которое обычно составляет 980px. Короче говоря, это строка кода отвечает за, если так можно выразиться, базовый уровень адаптивности.<br><br>
                  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Следующий тег – &lt;title&gt;. Здесь всё еще проще. Обращали внимание на то, что когда какая-нибудь вкладка открыта в вашем браузере, то она подписана каким-то названием, относящимся к теме сайта? Как правило, там буквально написано, что за сайт перед вами. К примеру, если открыть сайт youtube.com, то там буквально будет написано YouTube. В общем, если вы хотите как-то назвать ваш сайт на вкладке – пишите это в теге &lt;title&gt;.<br><br>
                  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;В качестве бонуса к тегу &lt;title&gt; можно описать еще одну строку кода, которая косвенным образом к нему тоже относится. Сразу скажу, что этой строки нет в созданном вами базовом шаблоне. Это строка – &lt;link rel="shortcut icon" href="/instruction/img/ico.png" type="image/png"&gt;. Как можно заметить, у нас есть тег &lt;link&gt;, а в переводе с английского "link" – это ссылка. Из этого можно сделать непротиворечивый вывод, что эта строка кода является неким путем (ссылкой) на какой-то внешний ресурс. Почему я сказал, что эта строка косвенным образом относится к тегу &lt;title&gt;, так это потому, что в данном случае она отвечает за присоединение иконки на ту же вкладку в вашем веб-браузере. То есть, рядом с названием сайта на вкладке, можно легко разместить какое-либо изображение, которое будет являться символом вашего сайта. У этого тега-ссылки, как можно заметить, есть атрибут <strong>'rel'</strong> – relationship (отношение). Он обозначает, что это за ссылка и на какой адрес она ведет. Работает это следующим образом: когда ссылка направляет пользователя на адрес, атрибут рассказывает поисковым системам, почему ссылка ведет на этот адрес. Например, ссылаться можно на файл стилей, который взаимодействует со страницей или, как я сказал выше – на иконку (логотип) сайта. У этого атрибута есть значение <strong>'shortcut icon'</strong>, что в переводе означает – значок ярлыка. Далее идет атрибут <strong>'href'</strong> – Hypertext Reference — гипертекстовая ссылка, а в виде значения значения этого атрибута буквально выступает путь к тому, к чему ведет эта ссылка: будь то внешний URL или локальный путь к картинке. Дальше идет атрибут <strong>'type'</strong>, который сообщает браузеру, к какому типу относится элемент. В данном случае у него указано значение <strong>'image/png'</strong>, а это означает, что используется тип изображения (image) в формате png.<br><br>
                  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;И последний тег, который есть у нас в шаблоне – это тег &lt;body&gt;. В этом теге находятся вся та информация, которую мы готовы разместить на нашей веб-странице – её и увидят пользователи. Тег, как можно заметить, зеркальный.<br><br>
                  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Теперь найдите созданный вами файл <strong>index.html</strong> у вас на компьютере и откройте его в удобном вам браузере. Серьезно, просто тыкните на него два раза. Это, как вы помните, файл вашей веб-страницы, HTML-код которого мы и будем в дальнейшем писать. Открыв этот файл в вашем браузере и разместив вкладку с ним рядом с этой инструкцией для удобного переключения между ними, вы можете снова вернуться в VS Code, чтобы начать писать код. Вот и всё, вы полностью подготовлены для начала работы. У вас есть среда разработки, репозиторий, где вы будете хранить файлы и папки вашего разрабатываемого проекта и даже удобный стартовый шаблон. А далее мы должны чем-то наполнить нашу веб-страницу, что делается по всё той же технологии – открывающих и закрывающих тегов, только уже других. Речь об этом и пойдет далее... Важно уточнить! Написав какой-то код просто нажмите <strong>ctrl</strong> + <strong>s</strong> на Windows или <strong>cmd</strong> (command) + <strong>s</strong> на macOS для сохранения. Затем, перейдите в ваш браузер, где открыт файл <strong>index.html</strong> и нажмите кнопку "обновить", кнопку <strong>F5</strong> на клавиатуре, если вы работаете на Windows или <strong>cmd</strong> + <strong>R</strong> на macOS.
               </p>
            </div>

            <div class="tom1">
               <h2 id="tom1">Том I. HTML5</h2>
            </div>
            <div class="html_block">
                <h3 class = "pre_chap_1" id="general_html">Общие положения</h3>
                <p class="post_pre_chap_6">
                  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;HTML5 зиждется на нескольких базовых тегах, которые формируют основную разметку и, применив которые, их вам может быть уже достаточно для разметки вашей первой, простой, но информативной web-страницы:</p>
                <p class="post_pre_chap_6">
                  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Итак, проблема: у вас есть текст, который вам необходимо разместить на вашем сайте. Как её решить? Для этого в HTML существует тег параграфов текста – тег <strong>&lt;p&gt;</strong>, который используется как контейнер для работы с текстом. А еще, это еще один зеркальный тег.<br>
                  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Быть может, я сейчас слегка перегну палку и говорить об этом еще рано, но я всё-таки напишу про это именно здесь. Когда вырастете – поймете и вам это пригодится, придете сюда, в начало, читать об этом. Итак, помните, как я говорил выше, что в HTML у тегов могут быть атрибуты? Вот и тег &lt;p&gt; исключением не является. У него есть атрибут <strong>'contenteditable'</strong> со значением после знака '=' <strong>'true'</strong>. Этот атрибут позволит вам превратить обычный параграф текста в редактируемый, это нужно для того, чтобы пользователь мог с ним взаимодействовать. С этой информацией, введенной пользователем, в дальнейшем можно взаимодействовать с помощью JavaScript. Но он так же может использоваться и с заголовками, и с тегами ненумерованных/нумерованных списков, однако о списках позже. В любом случае, поздравляю, вы разместили у себя на странице свой первый параграф текста.<br><br>
                  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Разместив на у себя на странице параграфы с текстом, нам может понадобиться разместить и заголовки к ним. Разумеется, в HTML это тоже предусмотрено – для этого есть теги с <strong>&lt;h1&gt; до &lt;h6&gt;</strong> – различные по значению для браузера, а так же, как я сказал, по размеру по умолчанию (от самого большого до самого малого). Эти теги тоже зеркальны.<br><br>
                  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;У тегов параграфов и заголовков есть еще один полезный под(суб)тег. Это тег <strong>&lt;span&gt;</strong>. Зачастую он применяется для дополнительной, внутристрочной стилизации текста, к примеру, для создания буквиц. Проще говоря, если вам будет нужно сделать так, чтобы ваш параграф текста выглядел одним образом, а одно лишь слово внутри этого параграфа было по стилю другим, то здесь вам и пригодится тег <strong>&lt;span&gt;</strong>. Записывается, кстати, просто, например, в параграфе: <span class="break"><strong>&lt;p&gt;&lt;span&gt;Какой-то&lt;/span&gt; текст&lt;/p&gt;</strong>.</span> И далее, помимо того, что находится в параграфе, вы можете заниматься отдельной стилизацией именно того, что заключено между тегами <strong>span</strong>.<br><br>
                  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Ещё одним из базовых тегов является <strong>не зеркальный</strong> тег <strong>&lt;img&gt;</strong> – image (от англ. изображение), он используется для добавления изображения на веб-страницу и у него есть два важных атрибута. Первый атрибут – это <strong>alt</strong>. Он позволяет отображать на странице содержимое добавленного изображения, если то, по тем или иным причинам, не будет загружено вместе с остальным контентом. Это так же необходимо и для пользователей с ограниченными возможностями – слабовидящих или незрячих людей. Их специальные программы – скринридеры – позволяют воспроизводить прочитанным вслух текстом содержимое фотографии. Поэтому то, что вы напишете в атрибуте <strong>'alt'</strong>, будет всерьез помогать людям с ограниченными возможностями воспринимать информацию с вашей веб-страницы. Второй атрибут – <strong>'src="  "'</strong>, в значении которого указывается путь к изображению. Поскольку мы работаем из репозитория, то все изображения для вашего веб-сайта рекомендуется размещать внутри него в папке с названием, к примеру, <strong>img</strong> или <strong>images</strong>. Исходя из того, что наш файл index.html у нас тоже создан и находится внутри репозитория, то путь к картинке прописать несложно. Репозиторий с нашим веб-сайтом назовём "test_site", представим, что скачали картинку со смешным котом и назвали её cat. При прописывании пути обязательно указывать расширение изображения (png, jpg, svg и так далее), и выглядеть это будет так:
                </p>
                <div id="code_block">
                  <p class="code">
                     ***
                  </p>
                  <p class="code">
                     &lt;body&gt;
                  </p>
                  <p class="sub_code">
                     <span class="break">&lt;img src="test_site/img/cat.png" alt="Крутой и мягкий кот, который спит в очень смешной позе"&gt;</span>
                  </p>
                  <p class="code">&lt;/body&gt;</p>
                  <p class="code">
                     ***
                  </p>
                </div>
                <p class="post_pre_chap_6">
                  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Вот и всё! Теперь вы можете создавать простейшие веб-сайты, где есть заголовки, тексты и даже картинки. Ну а с тем, что чуть посложнее, мы разберемся далее.
                </p>
                <h3 class = "chapter_1" id="lists">Списки и инструменты форматирования документа</h3>
                    <p class="post_pre_chap_6">
                     &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Как известно, списки бывают двух видов: нумерованные (упорядоченные) и не нумерованные (неупорядоченные). Основа у них проста и состоит из двух зеркальных тегов: тег <strong>&lt;ul&gt;</strong> для ненумерованного списка и <strong>&lt;ol&gt;</strong> для нумерованного. Для лучшего понимания и чтобы не путать их между собой, я рекомендую запомнить названия этих тегов с точки зрения слов, откуда они произошли. Первый вид списка – ненумерованный (<strong>&lt;ul&gt;</strong>) расшифровывается как "unordered list" (от англ. unordered list – не упорядоченный список). Второй вид списка – нумерованный (<strong>&lt;ol&gt;</strong>) расшифровывается как "ordered list" (от англ. ordered list – упорядоченный список). Как можно догадаться, название этих тегов – это есть первые буквы названий видов списков – <strong>ul</strong> и <strong>ol</strong>. Но эти теги еще не сами списки, а только их основа, как некий контейнер.<br><br>
                     &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Любой список, нумерованный или ненумерованный, состоит из элементов. За это отвечает соответствующий тег – <strong>&lt;lu&gt;</strong>. Этот тег не стал исключением и у него тоже есть расшифровка – это "list item" (от англ. list item – элемент списка). Структура создания списков в таком случае получается простой (одинаково работает для обоих видов списка, только меняйте теги):
                  </p>
                  <div id="code_block">
                     <p class="code">
                        ***
                     </p>
                     <p class="code">
                        &lt;body&gt;
                     </p>
                     <p class="sub_code">
                        &lt;ul&gt;
                     </p>
                     <p class="sub_sub_code">
                        &lt;li&gt;Первый пункт списка&lt;/li&gt;
                     </p>
                     <p class="sub_sub_code">
                        &lt;li&gt;Второй пункт списка&lt;/li&gt;
                     </p>
                     <p class="sub_sub_code">
                        &lt;li&gt;Третий пункт списка&lt;/li&gt;
                     </p>
                     <p class="sub_code">
                        &lt;/ul&gt;
                     </p>
                     <p class="code">&lt;/body&gt;</p>
                     <p class="code">
                        ***
                     </p>
                  </div>
                  <div class="faq_all">
                     <div class="f_img_3">
                         <img class = "faq_img" class="faq_img3" src = "/instruction/img/faq.png">
                     </div>
                     <div class="p_faq3">
                         <p class="faq_p">*для справки: и нумерованные и не нумерованные списки можно формировать каскадно, вкладывая один в другой. <br>Для этого, уже по известной схеме, формируется список, а затем, как один из его пунктов после тега &lt;li&gt;, прописывается новый подсписок тегами &lt;ol&gt; или &lt;ul&gt;. Вот, например:</p>
                         <ul class="list_faq">
                             Список 1:
                             <li>Пункт 1;</li>
                             <li>Пункт 2;</li>
                             <li>Пункт 3;</li>
                             <ol>
                             Еще один список, но каскадно, где родительным элементом нового списка является пункт №3 не нумерованного списка:
                             <li>Пункт 1;</li>
                             <li>Пункт 2;</li>
                             <li>Пункт 3;</li>
                             </ol>
                         </ul>
                     </div>
                  </div>
                <p class="post_pre_chap_6">
                  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Ну а теперь элементы форматирования текста:
               </p>
                <hr class="first_hr">
                <ul class="list_3">
                    <li>&nbsp;Элемент <strong>'strong'</strong> (замена не рекомендованному тегу 'b' – "bold") – <strong>выделяет текст жирным</strong>, отмечая его важность для браузера;</li>
                    <li>&nbsp;Элемент <strong>'em'</strong> (замена не рекомендованному тегу 'i' – "italic") – <em>форматирует текст курсивом</em>, так же отмечая его важность для браузера;</li>
                    <li>&nbsp;Элемент <strong>'ins'</strong> – "inserted" – отвечает за создание <ins>подчеркнутого текста</ins>;</li>
                    <li>&nbsp;Элемент <strong>'sup'</strong> – "supertext" – отвечает за создание <sup>надстрочного текста</sup>, к примеру, для написания степеней умножения (&nbsp;2<sup>3</sup>&nbsp;) и прочих символов верхнего индекса;</li>
                    <li>&nbsp;Элемент <strong>'sub'</strong> – "subscript" – отвечает за создание <sub>подстрочного текста</sub> и прочих символов нижнего индекса;</li>
                    <li>&nbsp;Элемент <strong>'del'</strong> – "deleted" – отвечает за создание <del>зачеркнутого текста</del>;</li>
                </ul>
                <h3 class="chapter_2" id="tables">Таблицы</h3>
                <p class="post_chap_2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                    Для рисования таблиц в HTML так же существует определенный набор тегов, которые подобно тегам списка структурируются каскадно.
                </p>
                <p class="p_post_p_chap_2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                    Для начала перечислим эти элементы в порядке убывания важности:
                </p>
                <hr class="second_hr">
                <ul class="list_5">
                    <li>&nbsp;Элемент <strong>'thead'</strong> – table header (от англ. заголовок таблицы) – рекомендованный в HTML5 контейнер для помещения в него строки-заголовка таблицы. Является родительным элементом элемента <strong>'th'</strong>;</li>
                    <li>&nbsp;Элемент <strong>'tbody'</strong> – table body (от англ. тело таблицы) – рекомендованный в HTML5 контейнер для помещения в него тела (остальной части) таблицы. Является родительным элементом всех элементов <strong>'tr'</strong> и <strong>'td'</strong>, начиная с элемента <strong>'tr'</strong>. Такие разделения на блоки-контейнеры для информации, как в случае с заголовком и телом таблицы, прежде всего, нужны для структуризации. То есть для того, чтобы другие разработчики, читая написанный код, четко видели разграничение по частям таблицы, которая в коде может быть весьма объёмной;</li>
                    <li>&nbsp;Элемент <strong>'table'</strong> (от англ. таблица);</li>
                    <li>&nbsp;Элемент <strong>'tr'</strong> – table row (от англ. строка таблицы);</li>
                    <li>&nbsp;Элемент <strong>'td'</strong> – table data (от англ. данные таблицы);</li>
                    <ul class="sub_list_5">
                        <li>&nbsp;Разновидность элемента <strong>'td'</strong> – подэлемент <strong>'th'</strong> – table header (от англ. заголовок таблицы). При необходимости он превращает верхнюю строку таблицы в титульную строку (заголовок таблицы). При этом текст в этой строке выравнивается по центру и выделяется жирным шрифтом. Является дочерним элементом элемента <strong>'thead'</strong>;</li>
                    </ul>
                </ul>
                <p class="p_before_table">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                    Далее приступим к наглядной демонстрации и создадим таблицу.
                </p>
                <div class="table__div">
                    <table class="table1">
                        <thead>
                            <tr>
                                <th>Имя</th>
                                <th>Возраст</th>
                                <th>Рост</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>Вася</td>
                                <td>18</td>
                                <td>176</td>
                            </tr>
                            <tr>
                                <td>Коля</td>
                                <td>16</td>
                                <td>179</td>
                            </tr>
                            <tr>
                                <td>Саша</td>
                                <td>21</td>
                                <td>190</td>
                            </tr>
                        </tbody>
                        </table>
                </div>
                <h3 class="pre_chap_6" id="tags">Ссылки</h3>
                <p class="post_pre_chap_6">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;За создание ссылок внутри вашей веб-страницы отвечает зеркальный тег &lt;a&gt; – он является одним из важнейших элементов HTML и предназначен для создания ссылок. У тега &lt;a&gt; есть два предназначения: первое непосредственно относится к созданию ссылки, чтобы перевести вас ну другую веб-страницу, второе же устанавливает якорь. Якорем называется закладка внутри страницы, которую можно указать в качестве цели ссылки. При использовании ссылки, которая указывает на якорь, происходит переход к закладке внутри веб-страницы. К примеру, так устроено оглавление в на странице, которую вы сейчас читаете.<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Простейшим способом создать ссылку якорного типа было бы задать <strong>id</strong> в теге той части страницы, куда необходимо переместиться, а в теге ссылки – прописать <strong>href="#указанный_id"</strong>.<br><br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;У тега &lt;a&gt;, разумеется, тоже есть набор атрибутов и их довольно много. Важнейшим из них является атрибут <strong>href</strong>, в значении которого указывается URL (Universal Resource Locator – универсальный указатель ресурсов). То есть в этот атрибут указывается адрес документа, на который происходит переход. Адрес ссылки может быть абсолютным и относительным. Абсолютные адреса работают везде и всюду независимо от имени сайта или веб-страницы, где прописана ссылка. Относительные ссылки, как следует из их названия, построены относительно текущего документа или корня сайта. Короче говоря, абсолютной ссылкой было бы то, если бы я сейчас указал здесь ссылку на сайт google.com, а относительной ссылкой то, если бы я указал здесь путь к другому .html файлу.<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Еще одним полезным атрибутом является атрибут <strong>target</strong> со значением <strong>_blank</strong> – атрибут с этим значением позволит вам открывать ссылку в новой вкладке.<br><br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Так же интересно и то, что ссылки для загрузки файлов – это всё те же самые теги &lt;a&gt;, только уже с атрибутом <strong>download</strong>.</p>
               <div class="a__tag">
                  <span class="span__download">Вот, попробуйте нажать, если хотите себе кота: </span><a class="a__tag__id" download href="/instruction/img/cat_lol.jpeg">СКАЧАТЬ!</a>
               </div>               
                <div class="faq_all">
                    <div class="f_img_3_1">
                        <img class = "faq_img" src = "/instruction/img/faq.png">
                    </div>
                    <div class="p_faq3_1">
                        <p class="faq_p">*для справки: в HTML так же существует специальный тег <strong>'button'</strong>, который создает на странице кнопку. К этой кнопке затем можно привязать самые различные действия посредствам языка JavaScript, но в том числе и закреплять к ней ссылки.</p>
                    </div>
                </div>
                <h3 class="chapter_4" id="forms">Формы</h3>
                <p class="post_chap_4">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Элемент <strong>'form'</strong> (от англ. форма) – это тег создания блока форм, то есть полей ввода на web-странице. Использует в себе следующие теги:</p>
                <ul class="list_6">
                    <li>&nbsp;Тег <strong>'form'</strong> является "телом" формы;</li>
                    <li>&nbsp;Тег <strong>'input'</strong> (от англ. ввод), создает непосредственно само поле ввода данных для пользователя, как, например, логин и/или пароль. Соответственно, тегов <strong>'input'</strong> может быть столько, сколько нужно конечной форме;</li>
                </ul>
                <div class="faq_all">
                    <div class="f_img_4">
                        <img class = "faq_img" src = "/instruction/img/faq.png">
                    </div>
                    <div class="p_faq4">
                        <p class="faq_p">*для справки: тег <strong>'input'</strong> является самозакрывающимся, то есть для него не нужно второго закрывающего тега.</p>
                    </div>
                </div>
                <div class="faq_all">
                    <div class="f_img_5">
                        <img class = "faq_img" src = "/instruction/img/faq.png">
                    </div>
                    <div class="p_faq5">
                        <p class="faq_p">*для справки: чтобы прямоугольники полей ввода после прописывания тегов <strong>'input'</strong> расположились один под другим, их можно дополнительно заключить в теги параграфов <strong>'p'</strong>.</p>
                    </div>
                </div>
                <p class="form_description">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                    Между тегами <strong>'form'</strong> и перед тегом <strong>'input'</strong> можно размещать любой текст, указывающий на поле ввода. К примеру, можно подписать, что конкретно это поле ввода относится к вводу строки логина и/или пароля при регистрации на сайте.
                </p>
                <p class="form_description2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Вместе с тем тег <strong>'input'</strong> может регулироваться дополнительными атрибутами, ему можно задавать типы:
                <ul class="list_7">
                    <li class="li_input_type">&nbsp;Первый тип – это тип строки поиска – <strong>'search'</strong>. Да, строка поиска тоже формируется через форму.</li>
                    <li class="li_input_type">&nbsp;Второй тип текстовый – <strong>'text'</strong>. В тег <strong>'input'</strong> он включен по умолчанию и позволяет прописывать в нем текстовую информацию, например логины, электронные почты и прочее – любую тектсовую информацию, необходимую для формы;</li>
                    <li class="li_input_type">
                        &nbsp;Третий тип предназначен для введения паролей и по-английски так и называется <strong>'password'</strong>. Его особенность в том, что в поле ввода <strong>'input'</strong> при прописывании этого типа, символы скрываются.
                        <ul class="sub_list_7">
                            <li class="li_input_type">&nbsp;Тип принимает в себя атрибуты <strong>'minlength'</strong> и <strong>'maxlength'</strong>, чтобы указать минимальную и максимальную длину значения, которое может быть введено.</li>
                        </ul>
                    </li>
                    <li class="li_input_type">
                        &nbsp;Следующий немаловажный тип для формы – это <strong>'checkbox'</strong> – флажок или «чекбокс». Этот тип позволяет добавить возможность выбора одного или несколких элементов в форме, например, при регистрации на сайте. К примеру, когда нужно выбрать несколько книг, которые вам нравятся. 
                        <ul class="sub_list_7">
                            <li class="li_input_type">&nbsp;У <strong>'checkbox'</strong> cледует использовать атрибут <strong>'value'</strong> для определения значения, которое будет отдано этим элементом.</li>
                            <li class="li_input_type">&nbsp;Используйте атрибут <strong>'checked'</strong>, чтобы указать, должен ли флажок быть выставлен.</li>
                            <li class="li_input_type">&nbsp;Можно также использовать атрибут <strong>'indeterminate'</strong>, чтобы указать, что флажок находится в неопределённом состоянии (на большинстве платформ при этом рисуется горизонтальная линия поперёк флажка).</li>
                        </ul>
                    </li>
                    <li class="li_input_type">&nbsp;Следующий тип – это <strong>'color'</strong> – элемент управления цветом. Создает выпадающий список, позволяющий еще больше расширить возможности регистрационной формы, выбрав, к примеру, любимый цвет.</li>
                    <li class="li_input_type">&nbsp;Тип <strong>'month'</strong> – элемент управления для ввода месяца и года без часового пояса.</li>
                    <li class="li_input_type">&nbsp;Тип <strong>'date'</strong> – элемент управления для ввода даты (год, месяц и день, без времени).</li>
                    <li class="li_input_type">&nbsp;Тип <strong>'datetime'</strong> – продвинутый элемент относительно предыдущего; элемент управления для ввода даты и времени (час, минута, секунда и доля секунды) в соответствии с часовым поясом UTC.</li>
                    <li class="li_input_type">&nbsp;Тип <strong>'datetime-local'</strong> – элемент управления для ввода даты и времени без часового пояса.</li>
                    <li class="li_input_type">&nbsp;Тип <strong>'email'</strong> – поле для редактирования адреса электронной почты. Перед отправкой проверяется, что входное значение содержит либо пустую строку, либо один действительный адрес электронной почты. Соответствуют CSS псевдоклассам :valid and :invalid.</li>
                    <li class="li_input_type">
                        &nbsp;Тип <strong>'file'</strong> – элемент управления, который позволяет пользователю выбрать файл.
                        <ul class="sub_list_7">
                            <li class="li_input_type">&nbsp;Используйте атрибут <strong>'accept'</strong>, чтобы определить типы файлов, которые могут быть выбраны.</li>
                        </ul>
                    </li>
                    <li class="li_input_type">&nbsp;Тип <strong>'hidden'</strong> – элемент управления, который не отображается, но чьё значение будет отправлено на сервер.</li>
                    <li class="li_input_type">&nbsp;Тип <strong>'image'</strong> добавляет кнопку вставки изображения. Для этого типа нужно использовать уже известный атрибут <strong>'src'</strong>, чтобы определить путь к изображению.</li>
                    <li class="li_input_type">
                        &nbsp;Тип <strong>'radio'</strong> – это кнопка-переключатель, позволяющая выбрать одно значение из множественного выбора. К примеру, пол – мужской или женский.
                        <ul>
                            <li class="sub_list_8">Для корректной работы типа <strong>'radio'</strong>, когда в списке есть несколько значений, из которых требуется выбрать один, типу <strong>'radio'</strong> требуется дополнительно указывать атрибут <strong>'name'</strong>. Это позволит создать список, внутри которого можно выбирать только одно значение из многих.</li>
                        </ul>
                    </li>
                    <li class="li_input_type">&nbsp;Тип <strong>'submit'</strong> – кнопка отправки готовой формы.</li>
                    <li class="li_input_type">
                        <p>&nbsp;И последний тип, который мы здесь опишем, это тип <strong>'range'</strong>. Этот тип позволяет добавить на страницу ползунок выбора значений, подобно слайдеру для перемотки у окна видео или аудио-плеера. Этот тип в дальнейшем понадобится для его использования вместе с JavaScript для считывания из него данных и дальнейшей работы с ними.<br>Вместе с этой версией тега <strong>'input'</strong> могу использоваться такие атрибуты как:</p>
                        <ul>
                            <li class="sub_list_8">&nbsp;<strong>'min'</strong> – минимальное значение, предназначенное для установки ползунку минимального числового значения и считывания его в дальнейшем;</li>
                            <li class="sub_list_8">&nbsp;<strong>'max'</strong> – максимальное значение, предназначенное для установки ползунку максимального числового значения и считывания его в дальнейшем;</li>
                            <li class="sub_list_8">&nbsp;<strong>'step'</strong> – шаг ползунка между значениями, который будет отсчитывать установленное число;</li>
                        </ul>
                    </li>
                </ul>
                <div class="faq_all">
                    <div class="f_img_6">
                        <img class = "faq_img" class="faq_img6" src = "/instruction/img/faq.png">
                    </div>
                    <div class="p_faq6">
                        <p class="faq_p">*для справки: существует еще несколько типов, применимых к тегу <strong>'input'</strong>, о них можно почитать самостотельно по одной из сылок, представленных в нижней части документа.</p>
                    </div>
                </div>
                <p class="form_description3">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Но и это еще не всё! Тег <strong>'input'</strong> может регулироваться так же и дополнительными атрибутами такими как:
                <ul class="list_9">
                    <li class="li_input_type">&nbsp;<strong>'placeholder'</strong> – у тега <strong>'input'</strong> в типе <strong>'text'</strong>, <strong>'password'</strong>, <strong>'email'</strong> и подобных, позволяет добавить непосредственно в саму область поля ввода некий текст. К примеру, подсказку, что именно в это поле необходимо ввести логин/пароль/e-mail и так далее.</li>
                    <li class="li_input_type">&nbsp;<strong>'autofocus'</strong> – после загрузки web-страницы, атрибут позволяет "сфокусироваться" на нужном поле ввода, куда немедленно помещается курсор для ввода данных;</li>
                    <li class="li_input_type">&nbsp;Атрибут <strong>'pattern'</strong> – атрибут позволяет задать полю ввода необходимое (обязательное) количество символов, при не соблюдении которого форма не будет отправляться. Указывается как 'pattern = "[0-9]"', где принимается количество символов от нуля до девяти, соответственно. Используется, например, для полей ввода номеров телефона. Подробнее можно почитать на специальном HTML5Pattern, где очень подробно описаны самые различные паттерны;</li>
                    <li class="li_input_type">
                        <p>&nbsp;Атрибут <strong>'list'</strong> – элемент чем-то похож на тег <strong>'select'</strong>, однако позволяющий забирать для тега <strong>'input'</strong> какие-либо значения с возможностью выбора предложенных.</p>
                        <ul>
                            <li class="sub_list_0">&nbsp;Работа атрибута <strong>'list'</strong> в связке с тегом <strong>'input'</strong> организуется посрдествам дополнительной структуры данных с использованием тега <strong>'datalist'</strong>. В этот тег, аналогично с тегом <strong>'select'</strong>, каскадно встраиваются теги <strong>'option'</strong>, в которые закладываются варианты выпадающего списка формата <strong>'list'</strong>. Тегу <strong>'datalist'</strong> обязательно присваивается <strong>'id'</strong>, к которому затем будет обращаться тег <strong>'input'</strong> с атрибутом <strong>'list'</strong>.</li>
                        </ul>
                    </li>
                </ul>
                <p class="p_before_autocomplete0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                    Далее приступим к наглядной демонстрации функционала атрибута <strong>'list'</strong> на web-странице.
                </p>
                <div class="datalist">
                    <datalist id="colors">
                        <option>Красный</option>
                        <option>Зеленый</option>
                        <option>Синий</option>
                        <option>Черный</option>
                        </datalist>
                </div>
                <div class="autocomplete">
                    <p class="p_before_autocomplete1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                        Введите один из цветов или выберите из предложенных:
                        </p>
                </div>
                <div class="input_list">
                    <input type="text" list="colors">
                </div>
                <p class="p_before_form">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                    Далее приступим к наглядной демонстрации функционала формы на web-странице.
                </p>
                <form action="http://google.com" method="POST" class="form1">
                    <!-- <p class="p_name">Введите Ваше имя</p> -->
                    <p><input required type="text" name="name" class="name" placeholder="Введите Ваше имя"></p>
                    <!-- <p class="p_lastname">Введите Вашу фамилию</p> -->
                    <p><input required type="text" name="lastname" class="lastname" placeholder="Введите Вашу фамилию"></p>
                    <!-- <p class="p_middlename">Введите Ваше отчество</p> -->
                    <p><input required type="text" name="middlename" class="middlename" placeholder="Введите Ваше отчество"></p>
                    <!-- <p class="p_email">Введите Ваш e-mail</p> -->
                    <p><input required type="email" name="email" class="email" placeholder="Введите Ваш e-mail"></p>
                    <!-- <p class="p_password">Придумайте пароль</p> -->
                    <p><input required type="password" minlength="8" name="password" class="password" placeholder="Придумайте пароль"></p>
                    <!-- <p class="p_password2">Повторите пароль</p> -->
                    <p><input required type="password" minlength="8" name="password" class="password2" placeholder="Повторите пароль"></p>
                    <div class="radio_checkbox">
                        <div class="div__checkbox">
                            <p class="p_checkbox">Оставаться в системе</p>
                            <input type="checkbox" id="cb1">
                            <label class="label_checkbox" for="cb1"></label>
                        </div>
                        <div class="div__palette">
                        <p class="p_palette">Укажите Ваш любимый цвет</p>
                        <div class="palette">
                            <label class="label_color">
                                <input class="input_color" type="color" name="color">
                                <div class="circle"></div>
                            </label>
                        </div></div>
                        <div class="div_radio">
                        <p class="p_radio">Укажите Ваш пол</p>
                            <div class="male">
                            <input type="radio" name="rb" id="rb1" checked>Мужской
                            <label for="rb1"></label>
                            </div>
                            <div class="female">
                            <input type="radio" name="rb" id="rb2">Женский
                            <label for="rb2"></label>
                            </div>
                        </div>
                    </div>
                    <p><input type="submit" value="Завершить регистрацию!" class="submit"></p>
                </form>
                <div class="faq_all">
                    <div class="f_img_7">
                        <img class = "faq_img" src = "/instruction/img/faq.png">
                    </div>
                    <div class="p_faq7">
                        <p class="faq_p">*для справки: у полей ввода формы есть функционал для людей с ограниченными возможностями здоровья. Для слабовидящих или незрячих людей эта функция позволяет специальным программам правильно зачитывать содержимое формы, а для людей с ограниченными моторными функциями позволяет нажимать на любую область блока <strong>'input'</strong>, к примеру, на название поля ввода или прочие элементы, косвенно относящиеся к тому или иному полю ввода. За эту функцию отвечает зеркальный тег <strong>'label'</strong> – в него, как в контейнер, помещается <strong>'input'</strong>.</p>
                    </div>
                </div>
                <p class="p_before_select1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                    Отчасти к элементам заполнения формы (в некоторых случаях), можно отнести и элемент <strong>'select'</strong>. Однако функционал этого элемента часто может быть за пределами одних лишь форм, поэтому опишем его далее. Этот элемент позволяет создавать выпадающие списки на web-странице и выбирать одну из предложенных опций, к примеру, язык, регион проживания и прочее.
                </p>
                <p class="p_before_select2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                    Далее приступим к краткой демонстрации списка.
                </p>
                <div id="content">
                    <div class="select1">
                        <p>Выберите Ваш основной язык</p>
                    </div>
                    <div class="select2">
                        <p>Выберите страну происхождения</p>
                    </div>
                    <div class="select3">
                        <p>Выберите предпочитаемое гражданство</p>
                    </div>
                    <div class="select-wrapper">
                        <select>
                            <option>Русский</option>
                            <option>Английский</option>
                            <option>Испанский</option>
                        </select>
                        <div class="select-arrow-1"></div>
                    </div>
                    <div class="select-wrapper">
                        <div class="select-arrow-2"></div>
                        <select>
                            <option>Россия</option>
                            <option>Соединенные Штаты</option>
                            <option>Мексика</option>
                        </select>
                    </div>
                    <div class="select-wrapper">
                        <div class="select-arrow-3"></div>
                        <div class="select-arrow-3"></div>
                        <select>
                            <option>Русский</option>
                            <option>Американец</option>
                            <option>Мексиканец</option>
                        </select>
                    </div>
                </div>
                <h3 class="chapter_5" id="semant">Видео, аудио и семантические элементы.</h3>
                <p class="post_chap_5">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                    Разумеется, на web-страницу нужно размещать не только текстовую информацию, но еще и мультимедийную. Для этого в HTML существуют специальные теги <strong>'audio'</strong> и <strong>'video'</strong>. И <strong>'audio'</strong> и <strong>'video'</strong> теги представляют из себя некий контейнер, внутри которого, посредствам тега <strong>'source'</strong>, где прописывается имя/путь к файлу и атрибута <strong>'type'</strong> (= "video/'формат'"" или = "audio/'формат'"), к ним прикрепляется соответствующий аудио/видео файл.
                </p>
                <div class="faq_all">
                    <div class = "f_img_8">
                        <img class = "faq_img", class = "faq_img8" src = "/instruction/img/faq.png">
                    </div>
                    <div class = "p_faq8">
                        <p class = "faq_p">*для справки: регулирование размеров окна вставляемого видео осуществляется посредствам атрибутов, прописываемых тегу <strong>'video'</strong> и/или <strong>'audio'</strong>:
                        <div class = "list_1">
                            <ul>
                            <li>&nbsp;Атрибут <strong>'width'</strong> задает окну видео необходимую длину;</li>
                            <br>
                            <li>&nbsp;Атрибут <strong>'height'</strong> задает окну видео необходимую высоту;</li>
                            </ul>
                        </div>
                        <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Для добавления элементов управления вставленным видео в тег <strong>'video'</strong> прописывается атрибут <strong>'controls'</strong>.</p>
                    </div>
                </div>
                <p class="p_post_p_chap_2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                    В HTML5 есть специальные теги, позволяющие логически делить страницу на составные части, что удобно как при программировании, так и при чтении кода. По своей сути, эти элементы не отличаются от элемента <strong>'div'</strong>, как контейнера, но нужны для грамотной расстановки блоков информации.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Это такие элементы как:
                </p>
                <hr class="third_hr">
                <ul class="list_8">
                    <li class="li_semant">&nbsp;Элемент <strong>'article'</strong>, то есть статья. Используется, соответсвенно, для помещения в него материалов статей;</li>
                    <li class="li_semant">&nbsp;Элемент <strong>'header'</strong> – в него помещается верхний блок сайта, например, с меню навигации в верхней части и/или название сайта;</li>
                    <li class="li_semant">&nbsp;Элемент <strong>'footer'</strong> – это самая нижняя часть сайта, в этот элемент помещается документация, справки обратная связь, адреса и прочая подобная информация;</li>
                    <li class="li_semant">&nbsp;Элемент <strong>'section'</strong> – используется для разметки отделов внутри страницы;</li>
                    <li class="li_semant">&nbsp;Элемент <strong>'nav'</strong> используется для разметки панели навигации;</li>
                </ul>
                <div class="faq_all">
                    <div class = "f_img_9">
                        <img class = "faq_img", class = "faq_img9" src = "/instruction/img/faq.png">
                    </div>
                    <div class = "p_faq9">
                        <p class = "faq_p">*для справки: в HTML5 можно и самостоятельно создавать свои собственные теги. Для этого нужно использовать небольшой JavaScript код, строка которого будет выглядеть следующим образом (вместо апострофов нужно использовать стандартные открывающие/закрывающие символы):<br><br>
                            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="break">'script type="text/javascript"' document.createElement("название_своего_тега")'/script'</span>
                        </p>
                    </div>
                </div>
            </div>

            <div class="tom2" id="tom2">
                 <h2>Том II. CSS</h2>
            </div>
  
            <div class="css_block">
                <h3 class = "pre_chap_6" id="general_css">Общие положения</h3>
                   <p class="post_pre_chap_6">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Итак, если говоря об HTML мы знаем, что это HyperText Markup Language (Язык Гипертекстовой Разметки), который занимается тем, <strong>ЧТО</strong> находится у вас на странице. У CSS есть возможность установки едениц измерения набором способов: с помощью абсолютной виличины – в пикселях, с помощью процентов и с помощью едениц <strong>'em'</strong>. Размер одной еденицы <strong>'em'</strong>, вероятно, должен быть равен 16px. Смысл использования едениц <strong>'em'</strong> в установлении размеров шрифта состоит в том, что такой способ работает относительно всего текста. То есть, если мы увеличиваем размер всего блока текста, то внутренние элементы, к которым применен <strong>'em'</strong> будет увеличен относительно него. У способа <strong>'em'</strong> есть разновидность – это <strong>'rem'</strong>, то есть root – еденица измерения отсчитываемая от самого основного элемента – например, <strong>'body'</strong>. Еще одним довольно полезным вариантом регулировки размеров текста является еденица <strong>'vw'</strong> – viewbord width (от англ. ширина окна просмотра) – позволяет вариантивно менять размер текста, к которому применена данная величина, но в зависимости от размеров окна. Этот способ удобен для адаптивности к различным размерам экранов.
                   </p>
                <h3 class = "chapter_6" id="advanced_selectors">Немного о продвинутых селекторах.</h3>
                <p class="post_chap_6">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                   Здесь я приведу только некоторые виды продвинутых селекторов, которые помогают эффективнее обращаться к файлу стилей из HTML разметки.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Существуют такие виды продвинутых селекторов (или методов обращения) как:
                </p>
                <ul class="list_9">
                   <li>&nbsp;
                      У любой HTML конструкции, которая включает или может включать в себя дочерние элементы (например нумерованные или не нумерованные списки – <strong>'ul'</strong> и <strong>'ol'</strong> или <strong>'div'</strong> с тегами <strong>'p'</strong> внутри него) возможно использовать стилизацию конкретных дочерних элементов без создания класса к ним. Для этого, прописывая соответсвующее свойство элемента в .html документе, можно использовать его порядковый номер. На примере списка это выглядит как <strong>'ul:nth-of-type(номер)'</strong>, где <strong>'ul'</strong>, соответственно, элемент списка, <strong>'nth'</strong> – порядковое числительное, <strong>'-of-type'</strong> – у типа, в данном примере, списка. В скобках указывается порядковый номер элемента, к которому применяется стилизация.
                   </li>
                   <li>&nbsp;
                      Так же в CSS существоет такое понятие как <strong>"псевдоклассы"</strong>. Это явление удобно рассмотреть с точки зрения, к примеру, ссылок. Стандартное отображение ссылки после ее разметки в HTML обычно включает в себя подчеркнутый текст ссылки. Ссылка по умолчанию будет подчеркнута, но мы можем захотеть, чтобы она была подчеркнута только при наведении на нее указателя. Для этого после отключения подчеркнивания с помощью свойства CSS <strong>'text-decoration: none;'</strong>, мы затем можем присвоить этой ссылке псевдокласс. Выглядеть это будет как <strong>'a:hover'</strong> и прописать уже при этом условии <strong>'text-decoration: underline;'</strong> – то есть, уже только при наведении на ссылку, у нас будет одображаться её подчеркивание.
                   </li>
                </ul>
            </div>

            <div class="tom3" id="tom3">
                <h2>Том III. JavaScript</h2>
            </div>
          
            <div class="js_block">
                <h3 class = "pre_chap_6" id="general_js">Общие положения</h3>
                <div class = "post_pre_chap_6">
                   <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                      Как мы уже говорили выше в разделе "Элементы управления страницей" тома I, в HTML документе мы можем создавать кнопки. Делается это с помощью зеркального тега <strong>'button'</strong>. Соответственно, чтобы при нажатии добавленной нами кнопки выполнялся какой-то код, тегу <strong>'button'</strong> необходимо присвоить атрибут <strong>'onclick'</strong>. В этом атрибуте можно указать код JavaScript inline-способом, то есть, без создания дополнительного документа с кодом. К примеру, по нажатию кнопки вывести сообщение. Выглядеть это будет следубщим образом (как обычно, вместо опострафов при написании кода нужно будет указать открывающие и закрывающие символы): <strong>'button onclick="alert('Hello world!')"'</strong>. Точно таким же inline-способом (и всеми остальными, разумеется, тоже), с помощью JavaScript можно отправлять, к примеру, и сообщения в консоль браузера. Делается это с помощью кода <strong>'button onclick ="console.log('Hello Console!')"'</strong>.
                   </p>
                   <button id="button" onclick="alert('Не тыкай!'), console.log('Hello Console!')" id="button">Кнопка</button>
                </div>
                <div class="faq_all">
                   <div class="f_img_10">
                      <img class = "faq_img" src = "/instruction/img/faq.png">
                   </div>
                   <div class="p_faq10">
                      <p class="faq_p">*для справки: способы помещения кода JavaScript и взаимодействия его со страницей ничем не отличается от способов работы c CSS. У него точно так же есть способы <strong>inline</strong> – внутристрочный, <strong>internal</strong> – внутри HTML кода (документа), но отдельным блоком кода и <strong>external</strong> – создавая отдельный документ под JavaScript с расширением <strong>'js'</strong>.
                      <div class="faq_all">
                         <div class="sub_f_img_10">
                            <img class = "faq_img" src = "/instruction/img/faq.png">
                         </div>
                         <div class="sub_p_faq10">
                            <p class="faq_p">*для справки: вместе с тем, помещая JavaScript код методом <strong>internal</strong>, код по умолчанию будет выполняться при загрузке страницы. К примеру, той же командой <strong>'alert'</strong> из JavaScript можно уведомить пользователя о сборе файлов Cookies при входе на страницу.</p>
                         </div>
                      </div>
                   </div>
                </div>
                <h3 class = "pre_chap_6" id="variables">Переменные в JavaScript</h3>
                <div class = "post_pre_chap_6">
                   <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Как и в любом другом языке программирования в языке JavaScript есть переменные и типы данных.
                   <ul class="list_10">
                      <li>
                         Переменные являются неким логическим контейнером для хранения в них неких данных, к которым в дальнейшем можно обращаться. Переменные в языке JavaScript декларируются значением<strong>'var'<span id="let">'let'?!?!?!?!</span></strong> – variable (от англ. переменная). Далее ей присваивается значение (имя). Выглядеть это будет так: <strong>'var firstName = "Vasya"'</strong>. То есть, грубо говоря, вы объявляем: пусть значение <strong>'firstName'</strong> (то есть, имя) будет равняться (будет приравниваться) к значению <strong>'Vasya'</strong>, то есть, теперь мы ввели переменную <strong>'firstName'</strong>, которая равна <strong>'Vasya'</strong>. Далее, после объявления переменной, мы можем на нее, соответственно, сослаться. Например, как и раньше, вывести в консоль. Выглядеть это будет следующим образом: <strong>'console.log(firstName)'</strong>, после чего мы получим выведенное в консоль ранее установленное значение переменной – <strong>'Vasya'</strong>. Значения переменных после присваивания им одних значений могут быть переписаны на другие значения. Для этого уже не нужно заново создавать "коробку" с переменной, а достаточно просто написать её ранее объявленное название и через знак приравнивания прописать ее новое значение, например: <strong>'firstName = Petya;'</strong>. После объявления необходимых переменных их можно использовать в каких-то выражениях. Для этого объявим еще одну переменную – <strong>'var lastName = "Ivanov";'</strong>. Теперь, после того, как у нас есть некоторый набор переменных, их можно, к примеру, сложить. Для этого объявим еще одну переменную – <strong>'var fullName = firstName + lastName;'</strong>. Переменные в этом случае уже пишуться <strong>без кавычек</strong>! Как видно из кода, взаимодействие этих переменных осуществялется через операцию сложения. То есть, таким образом, мы получаем сумму двух переменных, в данном случае переменной <strong>'firstName'</strong> и <strong>'lastName'</strong>, то есть имя и фамилию вместе, что в сумме представляет собой ранее объявленную переменную <strong>'fullName'</strong>.
                      </li>
                      <li>
                         Следующий тип данных это <strong>'boolean'</strong>. <strong>'Boolean'</strong> являет собой логический тип данных, который принимает только два значения: <strong>'true'</strong> или <strong>'false'</strong> – ложь или правда.
                         <div class="faq_all">
                            <div class="f_img_10_5">
                               <img class = "faq_img" src = "/instruction/img/faq.png">
                            </div>
                            <div class="p_faq10_5">
                               <p class="faq_p">*для справки: логический тип данных <strong>'boolean'</strong> точно так же объявляется уже описанным "контейнером" <strong>'var'</strong>, но после его объявялния ему придается значение <strong>'true'</strong> или <strong>'false'</strong>. Кроме того, логический тип данных <strong>'boolean'</strong>, в отличие от многих остальных языков программирования, можно так же как и любую другую переменную переписать в другое значение. То есть, если раньше это была логическая переменная со значениями <strong>'true'</strong> и <strong>'false'</strong>, то после переписывания она легко может стать переменной <strong>'string'</strong> типа.</p>
                            </div>
                         </div>
                      </li>
                      <li>
                         Следующий тип переменной – <strong>'undefined'</strong> (от англ. неопределенный). Это переменная с неопределенным (не заданным) значением. То есть, если в обычных видах переменных мы указывали <strong>'var *название_переменной* = *значение переменной*';</strong>, то в случае с <strong>'undefined'</strong> у нас будет задаваться только имя переменной, без её значения – <strong>'var *имя_переменной*';</strong>. В этом случае, результат обращения к этой переменной по имени будет рождать результат со значением <strong>'undefined'</strong>, что наглядно видно, например, в консоли браузера.
                      </li>
                      <li>
                         И последняя переменная в списке – это <strong>'null'</strong>. Это так же переменная с несуществующим значением, наподобие предыдущей. Сценарий использования этой переменной можно рассмотреть на примере игры. Предположим, что у нас есть некая компьютерная игра, где есть персонаж за которого играет некий человек по имени Петя. Объявим его: <strong>'let player1234 = "Petya"'</strong>. После смерти игрового персонажа этого человека по одной из причин, его персонаж необходимо обнулить (удалить) из игрового процесса. В этом случае полезно применить переменную с нулевым значением – <strong>'null'</strong>, что делается как и прежде – <strong>'player1234 = null;'</strong>.
                      </li>
                   </ul>
                </div>
                <div class="faq_all">
                   <div class="f_img_11">
                      <img class = "faq_img" src = "/instruction/img/faq.png">
                   </div>
                   <div class="p_faq11">
                      <p class="faq_p">*для справки: имена переменных всегда пишутся <strong>без</strong> пробелов. Для наилучшего понимания при программировании и последующего чтения кода, их желательно писать следующим образом: первое слово в имени переменной всегда пишется с маленькой буквы, второе, третье и, если необходимо, все последующие, с большой.</p>
                   </div>
                </div>
                <div class="faq_all">
                   <div class="f_img_12">
                      <img class = "faq_img" src = "/instruction/img/faq.png">
                   </div>
                   <div class="p_faq12">
                      <p class="faq_p">*для справки: еще одно важное замечание по поводу имен переменных состоит в том, что имя любой объявленной переменной в JavaScript необходимо начинать с любой маленькой буквы латинского алфавита, символа нижнего подчеркивания или символа доллара. Другие символы запрещены и будут рождать ошибку при исполнении кода.</p>
                   </div>
                </div>
                <h3 class = "pre_chap_6" id="built_methods">Встроенные методы в JavaScript</h3>
                <div class = "post_pre_chap_6">
                <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Что такое метод в языке программирования? Метод – это некий объем кода, состоящий из одной, нескольких или многих строк кода, помеченный каким-то именем, который в последствии можно вызывать (обращатсья к нему). Это практически то же самое, что и переменная. Так же у метода существует такое понятие как "параметры". Параметр метода – это то значение, которое мы передаем внутрь метода для того, чтобы код в последствии мог к нему обращаться. Параметр метода пишется в круглых скобках.<br><br>Далее рассмотрим некоторые методы в JavaScript.</p>
                <ul class="list_11">
                   <li>
                      Такие методы как <strong>'console.log()'</strong> и <strong>'alert()'</strong> мы уже рассматривали, но всё равно поместим их в список;
                   </li>
                   <li>
                      Еще один метод – <strong>'prompt("")'</strong> (от англ. – подсказка). Таким образом, к примеру, при загрузке веб-страницы можно вывести сообщение с полем ввода, с вопросом "Как Вас зовут?" – <strong>'prompt("Как Вас зовут?");'</strong>. Точно так же, как и другие переменные в JavaScript, переменную <strong>'prompt'</strong> можно перезаписать, присвоив ей другое значение. К примеру, это может выглядеть так: <strong>'let firstName = "Vasya"; firstName = prompt("Как Вас зовут"); console.log(firstName);'</strong>. В этом случае мы обхявили переменную <strong>'firstName'</strong>, присвоили ей значение <strong>'Vasya'</strong>, а затем, когда в браузере появится окно с полем ввода и мы введем туда другое значение (своё имя, при условии, что нас зовут не Вася), переменная перепишется на новое значение, о чем будет выведено сообщение в консоль.
                   </li>
                </ul>
                <h3 class = "pre_chap_6" id="order_operators">Порядок операторов в JavaScript</h3>
                <div class="operators__a">
                    <a id="operators" href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/Operator_Precedence#table"><span class="here">Здесь</span></a>
                </div>
                <p id="p_operators">, чтобы не создавать в этой инструкции гигантскую таблицу, вы можете ознакомиться с распределением приоритетов различных операторов в языке JavaScript на сайте MDN.</p>
                <h3 class = "pre_chap_6" id="if_else">Условные операторы в JavaScript. If/Else.</h3>
                <p class="post_pre_chap_6">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                   Важнейшая концепция <strong>любого</strong> языка программирования – это условия. При помощи условий в языках программирования принимаются решения. Условный оператор записывается при помощи двух слов: <strong>'if'</strong> (от англ. если) и <strong>'else'</strong> (от англ. еще, иначе, в ином случае). Рассмотрим наглядно. К примеру, обявим две переменные: <strong>let userName = "Ivan";</strong> и <strong>'let userAge = 15;'</strong>. Код дальнейшего условия записывается таким образом: <strong>'if(userAge >= 18) { console.log(userName + " is adult."); }'</strong>. Если после этого начать выполнять код и открыть консоль, то мы не получим никакого результата. Не получим мы его потому что в этом случае утверждение ложно, так как Ивану меньше 18ти лет. Код выполняться не будет. Этот код можно продолжить (ранее объявленные переменные прописывать не будем): <strong>let userName = "Ivan";</strong> и <strong>'let userAge = 15;'</strong>. <strong>'if(userAge >= 18) { console.log(userName + " is adult.";) }'</strong>. <br> <strong>'else if(userAge < 10) { console.log(userName + " is a child"); }'</strong>. Веток <strong>'else if'</strong> может быть сколько угодно. То есть, каждый раз, после того, как мы прописали какие-то условия <strong>'else'</strong> после <strong>'if'</strong>, мы всегда после этого можем добавить неограниченное количество <strong>'else if'</strong>, включающих в себя новые условия. Мы можем добавить еще одно условие (учитывая ранее написанный код): <strong>'else if(userAge > 10 && userAge < 18)' { console.log(userName + " is a teenager"); }</strong>. В этом случае, мы добавили <strong>'else if'</strong>, где с помощью оператора <strong>'и'</strong> добавляются сразу два условия.
                </p>
                <div class="faq_all">
                   <div class="f_img_13">
                      <img class = "faq_img" src = "/instruction/img/faq.png">
                   </div>
                   <div class="p_faq13">
                      <p class="faq_p">*для справки: мы уже познакомились с новым типом оператора <strong>'и'</strong>, который обозначается как <strong>'&&'</strong>. Так же существует еще один немаловажный логический оператор <strong>'или'</strong>, он обозначается как <strong>'||'</strong>. В случае применения этого логического оператора, выражение считается истинным, если хотя бы одно из перечисленных между <strong>'или' (||)</strong> выражений истинно.</p>
                   </div>
                </div>
                <h3 class = "pre_chap_6" id="ternary">Тернарный оператор</h3>
                <p class="post_pre_chap_6">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Тернарный оператор действует точно так же, как и оператор <strong>'if else'</strong>, но формат записи у него однострочный. То есть, мы можем записать оба условия и <strong>'if'</strong> и <strong>'else'</strong> в одной строке. Итак, вот как это работало с уже известными нам операторами <strong>'else if'</strong>. Давайте объявим две переменных: 
                <div id="code_block">
                   <p class="code">
                      let userName = "Jack";
                   </p>
                   <p class="code">
                      let userWeight = 87;
                   </p>
                   <p class="code">
                      if(userWeight > 90) {
                   <p class="sub_code">
                      console.log("У " + userName + " лишний вес.");
                   </p>
                   <p id="scobe">}</p>
                   <p class="sub_sub_code">
                      else {
                   </p>
                   <p class="sub_sub_sub_code">
                      console.log("У " + userName + " нормальный вес.");
                   </p>
                   <p id="scobe">}</p>
                   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Однако в случае использования <strong>тернарного</strong> оператора это будет выглядеть так (оставим ранее объявленные переменные):
                   <p class="code">
                      userWeight > 90 ? console.log("У " + userWeight + " лишний вес.") : console.log("У " + userName + " нормальный вес.");
                   </p>
                   <br>
                   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Эта страктура расшифровается следуюшим образом. <strong>Тернарный</strong> потому что состоит из трех частей: из изначального условия, из части, когда условие принимает значение <strong>'true'</strong> и части (после двоеточия), когда условие принимает значение <strong>'false'</strong>. Удобство этого оператора в том, что мы можем его использовать сразу при присваивании какой-либо значения переменной. Причем можно еще больше упростить написание кода, введя еще одну переменную и далее, прямо на месте, снова использовать тернарный оператор, без дополнительных строк вывода в консоль:
                   <p class="code">
                      let weightDescription;
                   </p>
                   <p class="code">
                      weightDescription = userWeight > 90 ? " лишний" : " нормальный";
                   </p>
                   <p class="code">
                      console.log("У " + userName + weightDescription + " вес.")
                   </p>
                </div>
                <h3 class = "pre_chap_6" id="switch">Оператор Switch</h3>
                <p class="post_pre_chap_6">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Оператор <strong>'switch'</strong> действует как механизм перехода к какой-либо ветке кода (switch от англ. переключатель).<br>
                   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Для работы как обычно объявялется переменная(е). Объявим переменную <strong>'JavaScript'</strong>. Далее, записывается сам оператор <strong>'switch'</strong>, после которого в скобках указывается обявленная переменная. После (внутри) оператора <strong>'switch'</strong> словом <strong>'case'</strong> (от англ. случай) указываются ветки. После <strong>'case'</strong> в кавычках записывается значение. После чего ставится двоеточие и далее мы можем записать то, что будет выполняться, если переменная <strong>'section'</strong> будет равна указанному в кавычках значению. К примеру для первого случая выведем в консоль сообщение "Вы изучаете раздел HTML". Для второго случая выведем в консоль сообщение "Вы изучаете раздел CSS". Для третьего "Вы изучаете раздел JavaScript". <strong>Важно</strong> после каждого случая <strong>'case'</strong> ставить ключевое слово <strong>'break'</strong> (от англ. прервать). Нужно это для того, чтобы в тех случаях, когда в значении <strong>'case'</strong> находится такое же значение, как и установленное в <strong>переменной</strong>, то выполнение кода завершается и программа выходит из оператора, не выполняя последующие ветки. Так же может быть и такой момент, что в переменной может быть указано значение, не совпадающее ни с одним из случаев внутри оператора <strong>'switch'</strong>. В этом случае необходимо исполнить какой-то код по умолчанию Для этого после последнего блока <strong>'case'</strong> создается <strong>'default'</strong>, после чего, так же, как и после <strong>'case'</strong>, ставится двоеточие и указывается то действие, которое будет выполняться. В нашем случае, тоже выведем сообщение в консоль. В этом случае <strong>'break'</strong> не требуется, так как <strong>'default'</strong> ставится последним.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Вот так будет выглядеть код:
                <div id="code_block">
                   <p class="code">
                      let section = "javaScript";
                   </p>
                   <p class="code">
                      switch(section) {
                   </p>
                   <p class="sub_code">
                      case "html" :
                   </p>
                   <p class="sub_sub_sub_code">
                      console.log("Вы изучаете раздел HTML");
                   </p>
                   <p class="sub_sub_code">
                      break;
                   </p>
                   <p class="sub_code">
                      case "css" :
                   </p>
                   <p class="sub_sub_sub_code">
                      console.log("Вы изучаете раздел HTML");
                   </p>
                   <p class="sub_sub_code">
                      break;
                   </p>
                   <p class="sub_code">
                      case "javaScript" :
                   </p>
                   <p class="sub_sub_sub_code">
                      console.log("Вы изучаете раздел JavaScript");
                   </p>
                   <p class="sub_sub_code">
                      break;
                   </p>
                   <p class="sub_code">
                      default :
                   </p>
                   <p class="sub_sub_sub_code">
                      console.log("Вы изучаете какой-то раздел");
                   </p>
                   <p id="scobe">}</p>
                </div>
                <div class="faq_all">
                   <div class="f_img_14">
                      <img class = "faq_img" src = "/instruction/img/faq.png">
                   </div>
                   <div class="p_faq14">
                      <p class="faq_p">*для справки: в одном <strong>'case'</strong> может находиться несколько значений переменных, для которых будут выполняться одни и те же действия. Прописывается точно так же, как и первоначальная переменная, в конце ставится двоеточие. К примеру, если после первой строки <strong>'case'</strong> из кода выше, вместе со значением <strong>'html'</strong> указать второй <strong>'case'</strong>, а после него <strong>'html5'</strong>, то в консоль будет выводиться один и тот же результат.</p>
                   </div>
                </div>
                <p class="post_pre_chap_6">
                   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Теперь провернем всё то же самое, только уже с числами. Для примера обратимся к части уже ранее пройденного калькулятора лишнего веса. Снова объявим две переменные <strong>'age'</strong> и <strong>'groupNumber'</strong>. Но если мы в <strong>'switch'</strong> поставим переменную <strong>'age'</strong>, то в <strong>'case'</strong> мы будем проверять равенство какому-то числу, а не сравнивать число с интервалом чисел. Чтобы сделать это с оператором <strong>'switch'</strong>, нужно провернуть небольшой трюк. Для этого в качестве переменной (в скобках после оператора <strong>'switch'</strong>) напишем <strong>'true'</strong>. После чего пишем <strong>'case'</strong>, а в <strong>'case'</strong> уже прописываем условия. В этом случае будет сравниваться значение <strong>'true'</strong> (истина) с приведенным внутри <strong>'case'</strong> выражением. То есть, если <strong>'age >= 18 && age <=25'</strong> – это <strong>'true'</strong>, то в этом случае по значениею переменной <strong>'switch(true)'</strong>, то <strong>'true'</strong> = <strong>'true'</strong> и переменной <strong>'groupNumber'</strong> присваивается значение <strong>'1'</strong>. Вот так будет выглядеть этот код:
                <div id="code_block">
                   <p class="code">
                      let age = 20;
                   </p>
                   <p class="code">
                      let groupNumber;
                   </p>
                   <p class="code">
                      switch(true) {
                   </p>
                   <p class="sub_code">
                      case age >= 18 && age <=25 :
                   </p>
                   <p class="sub_sub_code">
                      groupNumber = 1;
                   </p>
                   <p class="sub_sub_code">
                      break;
                   </p>
                   <p class="sub_code">
                      case age >= 25 && age <=46 :
                   </p>
                   <p class="sub_sub_code">
                      groupNumber = 2;
                   </p>
                   <p class="sub_sub_code">
                      break;
                   </p>
                   <p class="sub_code">
                      default :
                   </p>
                   <p class="sub_sub_code">
                      groupNumber = 3;
                   </p>
                   <p id="scobe">}</p>
                </div>
                <h3 class = "pre_chap_6" id="while">Цикл While</h3>
                <p class="post_pre_chap_6">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Циклы в языках программирования нужны для многократного повторения одного и того же действия.<br>
                   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Для начала посмотрим на цикл <strong>'while'</strong> (от англ. пока, до тех пор). Цикл <strong>'while'</strong> чем-то похож на оператор <strong>'if'</strong>, в котором так же в скобках указывается условие: <strong>'while(условие)'</strong>. После чего открываются фигурные скобки и туда вписывается код, который должен выполнится несколько раз. Этот код будет выполняться до тех пор, пока условие прописанное в скобках истинно. Оператор <strong>'while'</strong> работает таким образом: сначала проверяется на истинность условие, прописанное в скобках после оператора. Затем, если условие не верно, выполняется тело цикла, прописанное между фигурными скобками. Далее, после выполнения кода в теле цикла, оператор снова проверяет истинность условия в круглых скобках после себя и так до тех пор, пока условие не будет ложным. То есть, условия выхода из цикла – это выражение в круглых скобках равняется <strong>'false'</strong>. К примеру, можно указать вывод изначальной переменной <strong>'x = 1'</strong> в консоль. Однако если сделать это без прочих условий, то код впадет в бесконечный цикл, что может привести к зависанию браузера и/или компьютера. Поэтому мы можем инкрементировать нашу переменную, прописав к ней <strong>'x++'</strong>.  Код выглядит так (для начала объявим переменную):
                <div id="code_block">
                   <p class="code">
                      let x = 1;
                   </p>
                   <p class="code">
                      while(x < 100) {
                   </p>
                   <p class="sub_code">
                      console.log(x);
                   </p>
                   <p class="sub_code">
                      x++
                   </p>
                   <p id="scobe">}</p>
                </div>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Есть и другой способ применения цикла. Например, мы можем вывести в консоль какое-то текстовое сообщение по символам. Давайте добавим еще две переменных:
                <div id="code_block">
                   <p class="code">
                      let helloString = "Привет, Аня!"
                   </p>
                   <p class="code">
                      let count = 0;
                   </p>
                   <p class="code">
                      while(count < helloString.length) {
                   </p>
                   <p class="sub_code">
                      console.log(helloString[count]);
                   </p>
                   <p class="sub_code">
                      count++;
                   </p>
                   <p id="scobe">}</p>
                </div>
                <div class="faq_all">
                   <div class="f_img_15">
                      <img class = "faq_img" src = "/instruction/img/faq.png">
                   </div>
                   <div class="p_faq15">
                      <p class="faq_p">*для справки: внутри цикла <strong>'while'</strong> можно размещать оператор <strong>'if'</strong>, который так же как и обычно будет проверять некие условия и воплнять какие-то действия. Здесь представлено выведение в консоль всех чисел, кратных пяти.
                      <p class="code">
                         let count = 1;
                      </p>
                      <p class="code">
                         while(count <= 30) {
                      </p>
                      <p class="sub_code">
                         if(count % 5 === 0) {
                      </p>
                      <p class="sub_sub_sub_code">
                         console.log(сount);
                      </p>
                      <p class="sub_code">}</p>
                      <p class="sub_code">
                         count++
                      </p>
                      <p id="scobe">}</p>
                   </div>
                </div>
                <h3 class = "pre_chap_6" id="for">Цикл For</h3>
                <p class="post_pre_chap_6">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Цикл <strong>'for'</strong> являет собой более удобный в записи и восприятии вариант цикла <strong>'while'</strong>. Всё дело в том, что все данные для цикла (в том числе даже объявление переменной) записываются прямо в строке самого цикла <strong>'for'</strong>, в круглых скобках. На примере предыдущей операции рассмотрим принцип его работы:
                <div id="code_block">
                   <p class="code">
                      for(count = 1; count <= 10; count++) {
                   </p>
                   <p class="sub_code">
                      console.log(count);
                   </p>
                   <p id="scobe">}</p>
                </div>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Для лучшего понимания, давайте и здесь, с помощью цикла <strong>'for'</strong> устроим перебор символа строки. Теперь используем не <strong>'count'</strong> переменную, а переменную <strong>'i'</strong>. Переменная <strong>'i'</strong> в реальной жизни в циклах <strong>'for'</strong> используется практически постоянно. То есть, в цикле <strong>'for'</strong> указывается одна буква для счетчика, так как эта переменная больше нигде не используется, ей не нужно присваивать имя, которое будет что-то описывать. Рассмотрим код:
                <div id="code_block">
                   <p class="code">
                      let helloString = "Привет, Аня!";
                   </p>
                   <p class="code">
                      for(i = 0; i < helloString.length; i++) {
                   </p>
                   <p class="sub_code">
                      console.log(helloString[i]);
                   </p>
                   <p id="scobe">}</p>
                </div>
                <div class="faq_all">
                   <div class="f_img_16">
                      <img class = "faq_img" src = "/instruction/img/faq.png">
                   </div>
                   <div class="p_faq16">
                      <p class="faq_p">*для справки: внутри цикла <strong>'for'</strong> можно размещать оператор <strong>'if'</strong>, который так же как и обычно будет проверять некие условия и воплнять какие-то действия. Здесь представлено выведение в консоль всех чисел, кратных семи.
                      <p class="code">
                         for(i = 1; i <= 30; i++) {
                      </p>
                      <p class="sub_code">
                         if(i % 7 === 0) {
                      </p>
                      <p class="sub_sub_sub_code">
                         console.log(i);
                      </p>
                      <p class="sub_code">}</p>
                      <p id="scobe">}</p>
                   </div>
                </div>
                <h3 class = "pre_chap_6" id="finctions">Функции</h3>
                <p class="post_pre_chap_6">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>Функции</strong> чем-то схожи с переменными. То есть, как говорилось выше, в переменную можно поместить какое-либо значение, а затем, в последующих сценариях работы программы, при запросе этой переменной, мы можем получить это значение. В <strong>функциях</strong>можно хранить не значение, а целый код. И потом, обратившись к функции программы по имени, в любом месте программы, мы можем запустить этот кусок кода. Код организовывается следующим образом. Сначала пишется слово <strong>'function'</strong>, после которого всегда ставятся круглые скобки. Затем, как и в предыдущих примерах, открываются фигурные скобки, в которых записывается само тело функции. То есть тот код, который будет выполняться, когда мы будем обращаться к этой функции в другом месте программы по её имени. Если записать функцию подобно циклам или операторам, то код работать не будет (функция – название функции – круглые скобки – фигурные скобки – тело функции (к примеру, вывод чего-либо в консоль)). Потому что в таком случае мы не обращаемся к функции, а просто определяем её. То есть мы создали функцию, прописали её тело, то есть, внутренний код, который эта функция должна выполнять, но мы не обращаемся к этой функции, чтобы она начала свою работу.<br>
                   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Чтобы запустить функцию (обратиться к ней), нужно просто прописать её имя, сразу после написать круглые скобки и обязательно поставить круглые скобки с точкой с запятой.<br>
                   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Вот так будет выглядеть код:
                <div id="code_block">
                   <p class="code">
                      function hello() {
                   </p>
                   <p class="sub_code">
                      console.log("Hello World!");
                   </p>
                   <p class="code">
                      function();
                   </p>
                   <p id="scobe">}</p>
                </div>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;После чего функция полностью готова. Далее в коде, мы можем несколько раз обращаться к этой функции и код будет выполняться ровно столько раз, сколько мы обратимся к этой функции.<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Вы подумаете, зачем всё так усложнять? Можно же просто несколько раз прописать <strong>'console.log()'</strong> с нужными нам данными и тогда всё будет работать точно так же. Но не всё так просто. Если мы пропишем другую функцию:
                <div id="code_block">
                   <p class="code">
                      function complexHello() {
                   </p>
                   <p class="sub_code">
                      console.log("Привет, меня зовут Глеб. Мне 24 года. Я из Ульяновска.");
                   </p>
                   <p class="sub_code">
                      console.log("До свидания!");
                   </p>
                   <p id="scobe">}</p>
                   <p class="code">
                      complexHello();
                   </p>
                </div>
                <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;То есть, становится понятно, что чем длиннее и сложнее код, тем проще поместить его в некий "контейнер", в данном случае, в виде функции и выполнять его автоматизированно. Функция может содержать множество строк самого различного кода. То есть, принцип чем-то похож на контейнер <strong>'div'</strong> из <strong>HTML</strong>, который мы наполняем каким-то содержимым, с которым в последствии можно работать, обратившись к нему, например, из <strong>CSS</strong>.</p>
                <h3 class = "pre_chap_6" id="function_param">Параметры (аргументы) функции.</h3>
                <p class="post_pre_chap_6">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;В предыдущей части мы выводили через функцию в консоль некий текст приветствия. Вызывая эту фукнцию, мы будем выводить в консоль один и тот же текст. Но мы можем модифицировать эту функцию так, чтобы мы могли передавать текст приветствия в качестве параметра функции и в консоль уже выводился бы тот текст, который мы туда (в консоль) передадим. Для этого мы передадим функцию <strong>параметра</strong> или <strong>аргумента</strong>. Вернумся к нашему примера с функцией <strong>'complexHello'</strong> и в данном случае, в качестве параметра подходит <strong>'text'</strong>. Соответсвенно, далее в <strong>'console.log()'</strong> мы указываем не какую-то определенную строку текста, а, соответственно, этот параметр – <strong>'text'</strong>. И теперь, вместо этого параметра, мы можем передавать функции <strong>'console.log'</strong> любой текст. Код будет выглядеть слудующим образом:
                <div id="code_block">
                   <p class="code">
                      function complexHello() {
                   </p>
                   <p class="sub_code">
                      console.log(text);
                   </p>
                   <p id="scobe">}</p>
                   <p class="code">
                      complexHello("Привет, меня зовут Глеб. Мне 24 года. Я из Ульяновска.");
                   </p>
                </div>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;В качестве параметра функции мы можем передавать не только текст. Например, мы можем создать функцию, вычисляющую квадрат какого-то числа. Для этого, как обычно, создадим функцию и присвоим ей параметр <strong>'number'</strong>. После чего, поместим в тело этой фунции <strong>'console.log(number);'</strong>, которая будет выводить в качестве результата эту функцию. А затем, мы можем эту функцию вызвать и передавать ей значение цифры, квадрат которой требуется получить. Код будет выглядеть слуюбдующим образом:
                <div id="code_block">
                   <p class="code">
                      function square(number) {
                   </p>
                   <p class="sub_code">
                      console.log(number * number);
                   </p>
                   <p id="scobe">}</p>
                   <p class="code">
                      square(2);
                   </p>
                </div>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Параметр, передаваемый в функцию, может быть не один. Например, давайте создадим другую функцию, вычисляющую площать прямоугольника. Площадь прямоугольника равна ширине умноженной на высоту. Поэтому, параметры функции мы так и назовем: <strong>'width'</strong> и (через запятую) <strong>'height'</strong>. После чего, в теле функции, как прописываем <strong>'console.log(width * height)';</strong>. И далее мы можем вызывать эту функцию с различными параметрами сторон этого треугольника, например 2 и 3. Код будет выглядеть следующим образом: 
                <div id="code_block">
                   <p class="code">
                      function area(width, height) {
                   </p>
                   <p class="sub_code">
                      console.log("Площадь прямоугольника =" + width * height + " сантиметров квадратных");
                   </p>
                   <p id="scobe">}</p>
                   <p class="code">
                      area(2, 3);
                   </p>
                </div>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Как можно заметить, полезность функции заключается не только в том, что мы сокращаем общее количество строк кода, но и в том, что мы можем передавать ей разные параметры в зависимости от которых код будет выполняться с разным результатом. Это очень важное свойство функций, которое можно использовать в своих программах.<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Параметров функции может быть любое количество, но в обычной жизни параметров как правило не бывает больше трех-четырех. На примере текста приветствия это снова можно представить таким образом:
                <div id="code_block">
                   <p class="code">
                      function complexHello(helloText, name, age) {
                   </p>
                   <p class="sub_code">
                      console.log(helloText + " Меня зовут " + name + ". Мне " + age + " лет.");
                   </p>
                   <p id="scobe">}</p>
                   <p class="code">
                      complexHello("Здравствуйте!", "Иван", 46);
                   </p>
                </div>
                <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Этот код позволяет подставлять в функцию различные параметры в реальном времени. То есть, мы можем несколько раз обращаться к функции, меня её параметры и выводить, к примеру, различные приветствия.</p>
                <h3 class = "pre_chap_6" id="returns">Возвращаемые значения функции</h3>
                <p class="post_pre_chap_6">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;В качестве примера давайте рассмотрим уже изученную выше функцию по рассчету площади прямоугольника. Эта функция, в качестве входного параметра, получает <strong>'number'</strong>, а затем умножает этот <strong>'number'</strong> на себя же и выводит в консоль. То есть, функцию можно рассмотреть как некий черный язик: мы передаем что-то в этот ящик, а затем функция внутри себя как-то эту переданную информацию обрабатывает. Но что если мы хотим использовать далее в программе результат того, что выполнила функция? В рассматриваемом примере – это, например, квадрат значения <strong>'number'</strong> – то есть, вычисление площади прямоугольника. Если мы пойдем по известному нам пути, попытаемся объявить переменную <strong>'let x = square(2)'</strong> (square() от ранее расмотренной функции – квадрат числа), и пропишем отображение в консоли. В этом случае, первая строка с переменной работать будет, то есть, будет вычисляться квадрат от числа 2, так как работает функция. Но вот <strong>'console.log(x)'</strong> будет выводить значение <strong>'undefined'</strong>. То есть, мы присвоили значение переменной <strong>'x'</strong>, но эта функция в данном случае не возвращает никакого значения – она просто проделывает какую-то работу. Но можно сделать и так, чтобы данные после работы функции выдавались как выходные. Делается это очень просто:
                <div id="code_block">
                   <p class="code">
                      function square(number) {
                   </p>
                   <p class="sub_code">
                      return number * number;
                   </p>
                   <p id="scobe">}</p>
                </div>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;После прописывания <strong>'return'</strong> нам становится доступно присвоение рузультата работы функции какой-то другой переменной.<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Есть еще один сценарий использования функции внутри другой функции. В данном случае функции <strong>'square'</strong>. Создадим новую функцию, которая посредствам вычислений будет сообщать нам, большой ли квадрат. В качестве параметра бы будем использовать сторону квадрата <strong>'side'</strong>. Внутри функции объявим переменную <strong>'squareArea'</strong>, которая посредствам функции будет заниматься вычислением площади квадрата – возведением стороны квадрата в квадрат. Поэтому эту переменную мы можем приравнять к уже объявленной функции, которая этим занимается – <strong>'square'</strong> со значением <strong>'side'</strong>. Ниже мы можем использовать оператор <strong>'if'</strong>, который будет выяснять: если площадь квадрата больше установленного нами значения, то квадрат большой. И если да, то эта функция будет возвращать <strong>'true'</strong>. А в другом случае, соответственно, <strong>'false'</strong>. А после выведем в консоль функцию, с параметром, к примеру "2": <strong>'console.log(isSquareBig(2))';</strong> Код будет выглядеть следующим образом:
                <div id="code_block">
                   <p class="code">
                      function square(number) {
                   </p>
                   <p class="sub_code">
                      return number * number;
                   </p>
                   <p id="scobe">}</p>
                   <p class="code">
                      function isSquareBig(side) {
                   </p>
                   <p class="sub_code">
                      let squareArea = square(side);
                   </p>
                   <p class="sub_code">
                      if(squareArea > 100) {
                   </p>
                   <p class="sub_sub_code">
                      return true;
                   </p>
                   <p class="sub_sub_sub_code">
                      } else {
                   </p>
                   <p class="sub_sub_sub_sub_code">
                      return false;
                   </p>
                   <p class="sub_sub_sub_code">}</p>
                   <p id="scobe">}</p>
                   <p class="code">
                      console.log(isSquareBig(2));
                   </p>
                </div>
                <h3 class = "pre_chap_6" id="statements">Statements vs. Expressions</h3>
                <p class="post_pre_chap_6">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Есть два способа создания функции. Первый способ мы уже рассмотрели, он называется <strong>Statement</strong> или <strong>объявление функции</strong>. То есть, запись в форме <strong>'function название_функции() {}'</strong>. Но есть второй способ – способ создания функции в выражении – <strong>Expression</strong>. Для наглядности давайте создадим реальную функцию и посмотрим, как её можно реализовать двумя способами. В функции мы будем передавать два параметра: название и вид животного и в зависимости от того, какое это животное, мы будем выводить в консоль имя этого животного и звук, который оно издает. То есть, если мы введем параметры "Имя 'Ричард'" и "Вид 'собака'", то в консоль должно выводиться "Ричард гавкает". Код в первом случае будет выглядеть следующим образом:
                <div id="code_block">
                   <p class="code">
                      function animalVoice(animal, animalName) {
                   </p>
                   <p class="sub_code">
                      if(animal === "dog") {
                   </p>
                   <p class="sub_sub_code">
                      return animalName + " гавкает.";
                   </p>
                   <p class="sub_sub_sub_sub_code">
                      } else if(animal === "cat") {
                   </p>
                   <p class="sub_sub_sub_sub_sub_code">
                      return animalName + " мяукает.";
                   </p>
                   <p class="sub_sub_sub_code">
                      } else if(animal === "pig") {
                   </p>
                   <p class="sub_sub_sub_sub_sub_code">
                      return animalName + " хрюкает.";
                   </p>
                   <p class="sub_sub_sub_code">
                      } else {
                   </p>
                   <p class="sub_sub_sub_sub_sub_code">
                      return animalName + " издает какие-то звуки.";
                   </p>
                   <p class="sub_sub_sub_code">}</p>
                   <p id="scobe">}</p>
                   <p class="code">
                      console.log(animalVoice("dog", "Ричард"));
                   </p>
                </div>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;А вот второй способ – <strong>Expression</strong>:
                <div id="code_block">
                   <p class="code">
                      let animalVoice = function(animal, animalName) {
                   </p>
                   <p class="sub_code">
                      if(animal === "dog") {
                   </p>
                   <p class="sub_sub_code">
                      return animalName + " гавкает.";
                   </p>
                   <p class="sub_sub_sub_sub_code">
                      } else if(animal === "cat") {
                   </p>
                   <p class="sub_sub_sub_sub_sub_code">
                      return animalName + " мяукает.";
                   </p>
                   <p class="sub_sub_sub_code">
                      } else if(animal === "pig") {
                   </p>
                   <p class="sub_sub_sub_sub_sub_code">
                      return animalName + " хрюкает.";
                   </p>
                   <p class="sub_sub_sub_code">
                      } else {
                   </p>
                   <p class="sub_sub_sub_sub_sub_code">
                      return animalName + " издает какие-то звуки.";
                   </p>
                   <p class="sub_sub_sub_code">}</p>
                   <p id="scobe">}</p>
                   <p class="code">
                      console.log(animalVoice("dog", "Ричард"));
                   </p>
                </div>
                <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Как видно из кода – работа функции в обоих споосбах идентична. Единственное отличие, что в дальнешем функционально может пригодиться в программе – это то, что при обявлении функции как переменной, эту функцию можно обнулить, если присвоить этой переменной другое значение.</p>
                <h3 class = "pre_chap_6" id="func_ex">Различные примеры реализации функций</h3>
                <p class="post_pre_chap_6">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;В первом примере мы рассмотрим, как создать функцию, вычисляющую, является ли число нечетным или нет. Если число нечетное, то в консоль выводится <strong>'true'</strong>, а если четное, то <strong>'false'</strong>. Код будет выглядеть следующим образом:
                <div id="code_block">
                   <p class="code">
                      function isNumberOdd(number) {
                   </p>
                   <p class="sub_code">
                      if(number % 2 === 0) {
                   </p>
                   <p class="sub_sub_code">
                      return false;
                   </p>
                   <p class="sub_sub_sub_code">
                      } else {
                   </p>
                   <p class="sub_sub_sub_sub_code">
                      return true;
                   </p>
                   <p class="sub_sub_sub_code">}</p>
                   <p id="scobe">}</p>
                </div>
                <div class="faq_all">
                   <div class="f_img_17">
                      <img class = "faq_img" src = "/instruction/img/faq.png">
                   </div>
                   <div class="p_faq17">
                      <p class="faq_p">*для справки: для лучшего понимания оператора <strong>'%'</strong>, строка <strong>'if(number % 2 === 0)'</strong> буквально означает, что "если, при делении на "2" переменной <strong>'number'</strong> остаток равен "0", то...</p>
                   </div>
                </div>
                <div class="faq_all">
                   <div class="f_img_18">
                      <img class = "faq_img" src = "/instruction/img/faq.png">
                   </div>
                   <div class="p_faq18">
                      <p class="faq_p">*для справки: кроме того, у обращения к функциям есть два варианта. На примере консоли первый вариант будет выглядеть так: <strong>'let x = isNumberOdd(11)';</strong>, а затем вывести в консоль, соответственно <strong>'console.log(x);'</strong>. И второй вариант: <strong>'console.log(isNumberOdd(11));'</strong>.</p>
                   </div>
                </div>
                <p class="post_pre_chap_6">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;А еще, в программировании существует такое понятие как <strong>'рефакторинг'</strong>. Сразу написать идеальный код бывает довольно сложно, поэтому написанный код часто можно многократно улучшить, оптимизировав его. На примере ранее описанной функции <strong>'isNumberOdd'</strong>, можно показать, насколько сильно можно укоротить код:
                <div id="code_block">
                   <p class="code">
                      function isNumberOdd(number) {
                   </p>
                   <p class="sub_code">
                      return % 2 !== 0;
                   </p>
                   <p id="scobe">}</p>
                </div>
                <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;То есть, сначала будет вычисляться значение логического выражения после <strong>'return'</strong> и если остаток от деления <strong>% 2</strong> <strong>НЕ</strong> равен нулю (неравенство обозначается оператором <strong>'!=='</strong>), то будет возвращаться <strong>'true'</strong>.</p>
                <p class="post_pre_chap_6">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Во втором примере мы посмотрим на функцию, вычисляющую факториал числа:
                <div id="code_block">
                   <p class="code">
                      function factorial(naturalNumber) {
                   </p>
                   <p class="sub_code">
                      if(naturalNumber < 0) {
                   </p>
                   <p class="sub_sub_code">
                      return 0;
                   </p>
                   <p class="sub_code">}</p>
                   <p class="sub_code">
                      let result = 1;
                   </p>
                   <p class="sub_code">
                      for(i = 1; i <= naturalNumber; i++) {
                   </p>
                   <p class="sub_sub_code">
                      result = result * i;
                   </p>
                   <p class="sub_code">}</p>
                   <p class="sub_code">
                      return result;
                   </p>
                   <p id="scobe">}</p>
                </div>
                <p class="post_pre_chap_6">
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Смотря на код выше, давайте разберемся, как работает эта функция.<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;В начале проверяется, ввел ли пользователь корректное значение. То есть, ввел ли пользователь натуральное число, чтобы факториал сработал. Например, мы можем договориться, что если пользователь ввел отрицательное значение, то мы возвращаем из функции значение <strong>0</strong>. Так как сам фактировал не может возвращать <strong>0</strong>, следовательно, возвращенный <strong>0</strong> будет сигнализировать о том, что пользователь ввел некорректное значение.<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Далее к самому факториалу. Сначала <strong>'i = 1'</strong>, точно так же, как и объявленная переменная <strong>'result = 1'</strong>. То есть, исходя из логики работы цикла, переменной <strong>'result'</strong> будет присвоено значение <strong>1 * 1</strong>, что будет равняться <strong>единице</strong>.<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Если передать в параметр функции значение <strong>3</strong>, то <strong>'i < 3'</strong>, следовательно, запускается цикл. Так как из-за <strong>'i++'</strong> цикл продолжается, следовательно, <strong>i = 2</strong>. В <strong>'result'</strong> находится <strong>1</strong>, <strong>1 * 2 = 2</strong>, после чего <strong>'result'</strong> присваивается <strong>2</strong>. Далее снова идет проверка в цикле. <strong>i</strong> всё еще меньше заданного значения функции <strong>3</strong>, поэтому снова срабатывает <strong>'i++'</strong> и теперь <strong>i = 3</strong>. В <strong>'result'</strong> всё еще находится <strong>2</strong> – <strong>2 * 3 = 6</strong>. Число <strong>6</strong> присваивается <strong>'result'</strong>, после чего снова срабатывает <strong>i++</strong> и <strong>i</strong> теперь равна <strong>4</strong> и в этом случае мы выходим из цикла, так как <strong>4 > 3</strong>, где <strong>3</strong> – установленное значение функции. И в самом конце мы возвращаем <strong>'result'</strong>.  
                </p>
                <p class="post_pre_chap_6">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;В третьем примере рассмотрим, как с помощью функции JavaScript можно автоматически менять текстовые символы. Для примера возьмем функцию, которая будет заменять все пробелы на символы нижнего подчеркивания – <strong>_</strong>.
                <div id="code_block">
                   <p class="code">
                      function changeSpaceToUnderscore(text) {
                   </p>
                   <p class="sub_code">
                      let resultText = text.replace(/ /g, "_");
                   </p>
                   <p class="sub_code">
                      return resultText;
                   </p>
                   <p id="scobe">}</p>
                </div>
                <p class="post_pre_chap_6">
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Здесь всё довольно просто. Мы создаем функцию с параметром <strong>'text'</strong>. Затем, внутри этой функции, мы объявляем переменную <strong>'resultText'</strong>, которая равна параметру объявленной функции <strong>'text'</strong>, но с методом <strong>'replace()'</strong>, который в JavaScript и занимается заменой символов. После метода <strong>'replace'</strong> в скобках между двумя слешами указывается то, что мы хотим заменить, после чего обязательно ставится символ <strong>'g'</strong> и после запятой в кавычках указывается то, <strong>НА ЧТО</strong> мы хотим заменить.</p>
                <h3 class = "pre_chap_6" id="area_of_vis">Область видимости переменных</h3>
                <p class="post_pre_chap_6">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;В JavaScript есть два типа областей видимости переменных:
                <ul class="list_8">
                   <li>Local Scope</li>
                   <li>Global Scope</li>
                </ul>
                <p class="post_pre_chap_6">
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Каждая функция создает новую область видимости. Понятие <strong>области видимости</strong> включает в себя некую <strong>доступность</strong> или <strong>видимость</strong> переменных. Эта область видимости определяет доступность переменных вне других конструкций программы.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;К примеру, переменные определённые <strong>внутри</strong> некой функции не будут доступны <strong>за</strong> её пределами. Но это не работает для переменных, определенных снаружи относительно тела функции. В этом случае мы не только можем обращаться к внешним функциям, но и менять их значения. Такие переменные, декларированные за пределами каких-либо структур, называются <strong>глобальными</strong>. Внутри же функции предпочтение <strong>всегда</strong> отдается локальным одноименным переменным.  
                </p>
                <div class="faq_all">
                   <div class="f_img_19">
                      <img class = "faq_img" src = "/instruction/img/faq.png">
                   </div>
                   <div class="p_faq19">
                      <p class="faq_p">*для справки: именно из-за понятия области видимости для циклов <strong>'for'</strong> и подобных структур, условия рекомендовано прописывать в формате переменной, как, например, <strong>'for(let i = 1; i < 10; i++) {}'</strong>. Всё потому что в случае, если объявить в цикле <strong>'i'</strong> без ключевого слова <strong>'let'</strong>, то в коде будет создаваться переменная глобального типа. Это, как можно понять, может серьезно повлиять на ход выполнения программы, если этой переменной случайно присвоится какое-то иное значение.</p>
                   </div>
                </div>
                <h3 class = "pre_chap_6" id="massives">Массивы</h3>
                <p class="post_pre_chap_6">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Массивы – это одна из структур данных, которые существуют в языке JavaScript. Итак, что же это такое?<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Есть такой способ. К примеру, у нас есть несколько цветов. Чтобы хранить значения этих цветов, как уже делали прежде, мы можем использовать переменные:
                <div id="code_block">
                   <p class="code">
                      let color1 = "красный";
                   </p>
                   <p class="code">
                      let color2 = "оранжевый";
                   </p>
                   <p class="code">
                      let color3 = "желтый";
                   </p>
                   <p class="code">
                      let color4 = "зеленый";
                   </p>
                   <p class="code">
                      let color5 = "голубой";
                   </p>
                   <p class="code">
                      let color6 = "синий";
                   </p>
                   <p class="code">
                      let color7 = "фиолетовый";
                   </p>
                </div>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Итак, у нас есть семь цветов радуги – семь переменных. Но проблема в том, что эти переменные никак не связаны друг с другом. То есть, мы никак не отображаем, что все эти семь цветов относятся к цветам радуги. И именно в таком случае, когда нам нужно собрать какие-то данные в единую структуру, как в случае с цветами радуги, нам и приходят на помощь массивы. Массивы данных создаются следующим образом:
                <div id="code_block">
                   <p class="code">
                      let rainbowColors = ["красный", "оранжевый", "желтый", "зеленый", "голубой", "синий", "фиолетовый"];
                   </p>
                </div>
                <p class="post_pre_chap_6">
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;И теперь все цвета собраны воедино и мы можем обращаться к этим значениям по одному имени – по имени <strong>rainbowColors</strong>.<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Обращаться затем к этому массиву данных можно следующим образом(для примера возьмем консоль): <strong>consol.log(rainbowColors[2, 3]);</strong>. В квадратных скобках указывается индекс эелемента в массиве, то есть, его порядковый номер. Индексируются массивы начиная с нуля.<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Для примера этот вывод в консоль можно скомбенировать еще и со строкой: <strong>'console.log("Небо " + [4] + " цвета");'</strong>.<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Можно не только считывать данные из элемента массива, но и менять значения этих элементов. То есть, к примеру, если мы хотим изменить цвет <strong>"красный"</strong> на <strong>"оранжевый"</strong>, то мы можем сделать следующее: <strong>'rainbowColors[0] = "оранжевый";'</strong>.<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Ровно так же можно вывести в консоль (или куда-либо еще) <strong>все</strong> элементы массива при помощи указания его имени: <strong>'console.log(rainbowColors);'</strong>.<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Так же можно не только изменять какие-то эелементы в массиве, но и добавлять в него новые. Но что делать, если мы не знаем, что у нас только семь эелементов в массиве, а высчитать из них последний было бы затруднительно? Сделать это можно указать свойство массива <strong>'.length'</strong>. Это свойство равно количеству элементов, а именно: <strong>'rainbowColors[rainbowColors.length] = "темно-синий";'</strong>. Есть и другие способы создания массивов.<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Второй споосб создать массив выглядит следующим образом: <strong>'let emptyArray = [];'</strong>. При такой записи создается пустой массив, в которые затем можно поместить значения.<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Еще одна, не слишком распространенная форма создания массива – это: <strong>'let emptyArray = new Array();'</strong> – осуществляется, как можно видеть, с помощью обращения к функции <strong>'array'</strong>. Повторюсь, такой способ не распространен.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Конечно же, массивы могут хранить не только строки, они могут хранить в себе любые значения. Можно так же создать массив с числами: <strong>'let numbers = [1, 5, 3, 2];'</strong>. Более того, JavaScript позволяет добавлять в массив значения разных типов: <strong>'let anyItems = [32, "Hello!", null]';</strong>.
                </p>
                <h3 class = "pre_chap_6" id="massive_methods">Методы массивов</h3>
                <p class="post_pre_chap_6">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Есть спаренные методы, такие как <strong>'push/pop'</strong>, <strong>'shift/unshift'</strong>, и есть одиночные <strong>indexOf</strong>, <strong>'slice'</strong>. Это основные методы для работы с массивами. По <a href="https://www.w3schools.com/jsref/jsref_obj_array.asp" id="methods">этой</a> ссылке можно перейти на сайт W3Schools и подробнее прочесть о самых разных методах для работы с массивами данных – их очень много. Но в основном используются те методы, речь о которых пойдет далее.<br>
                   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Начнем с метода <strong>Push</strong>. Создадим массив: <strong>'let names = ["Вася", "Саша", "Игорь", "Олег"];'</strong>. Далее, если мы хотим изменить массив, а именно, добавить в него какой-то элемент, мы можем воспользоваться либо технологией, описанной выше, либо прибегнуть к методу <strong>Push</strong>. Выглядит это следубщим образом (всопроизведем это как полноценный код):
                <div id="code_block">
                   <p class="code">
                      let names = "Вася", "Саша", "Игорь", "Олег"];
                   </p>
                   <p class="code">
                      names.push("Вячеслав");
                   </p>
                </div>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;После чего, с помощью такого метода записи, в массив (в конец) будет добавлен новый эелемент.<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Так же метот <strong>push</strong> может возвращать значения. Вообще, метот – это, своего рода, функция. И мы можем извлечь это значение. Это можно реализовать следующим образом:
                <div id="code_block">
                   <p class="code">
                      let names = "Вася", "Саша", "Игорь", "Олег"];
                   </p>
                   <p class="code">
                      let x = names.push("Вячеслав");
                   </p>
                   <p class="code">
                      console.log(names);
                   </p>
                   <p class="code">
                      console.log(x);
                   </p>
                </div>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;При этом <strong>console.log();'</strong> в виде переменной <strong>'x'</strong> будет выводить число, означающее длину массива.
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Противоположностью метода <strong>push</strong> является метод <strong>pop</strong>. Метод <strong>pop</strong> удаляет последний элемент в массиве. Он так же способен возвращать значения, но он возвращает не количество элементов, а значение того элемента, который он удалил, то есть последнего. Код для удаления из массива последнего элемента выглядит так: <strong>'names.pop();'</strong>.
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Следующая пара методов – <strong>shift</strong> и <strong>unshift</strong>. По той же самой логике, что и предыдущие два массива, они используются для работы с элементами в начале массива. Метод <strong>unshift</strong> добавляет элемент, метод <strong>shift</strong> удаляет. 
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Следующий метод – <strong>indexOF</strong>. Он нужен для определения индекса элемента массива. Записывается следующим образом: <strong>'names.indexOf("Игорь");'</strong>. Как можно заметить, в качестве параметра этот метод принимает в себя конкретный элемент массива, а после чего возвращает его индекс. Если мы укажем какой-то элемент, которого нет в массиве, то будет возвращено значение <strong>-1</strong>. То есть, если нужно определить, существует ли введенный элемент в массиве, то это можно легко сделать при помощи этого метода. Есть еще один момент. Если в массиве присутствует два одинаковых элемента, то дудет возвращено значение <strong>0</strong>. Мы можем использовать метод <strong>indexOf</strong>, к примеру, в следующий логике:
                <div id="code_block">
                   <p class="code">
                      let toyota = ["Camry", 2018, "sedan", "black", true];
                   </p>
                   <p class="code">
                      let isSedan = toyota.indexOf("sedan") === -1 ? console.log("Тип кузова - не седан") : console.log("Тип кузова - седан");
                   </p>
                </div>
                <p class="post_pre_chap_6">
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;В этом случае метод <strong>indexOf</strong> проверяет в массиве, есть ли там характеристика автомобиля – седан. Если же такого элемента массива нет, то возвращается значение <strong>-1</strong>, что исходя из работы тернарного оператора, интерпретируется как <strong>false</strong> и срабатывает описанный вывод в консоль, что машина не является седаном.
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Последний метод, который мы рассмотрим – это метод <strong>slice</strong>. Метод <strong>slice</strong> позволяет скопировать часть какого-то массива и присвоить её другой переменной, то есть создать другой массив из уже существующего. Например, <strong>let cars = ["Honda", "Toyota", "Peugeot", "Opel", "Mersedes", "BMW"];</strong>. И к примеру, мы хотим выбрать из этого массива только немецкие марки автомобилей, то есть, Opel, Mersedes и BMW. Для этого мы можем создать новый массив: <strong>'let germanCars = cars.slice(3, 5)';</strong>. В параметре метода в круглых скобках указываются индексы эелементов, с которого мы начинаем "резать" массив, чтобы забрать его кусок и второй индекс, которым мы заканчиваем.
                </p>
                <h3 class = "pre_chap_6" id="objects">Объекты</h3>
                <p class="post_pre_chap_6">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;В JavaScript есть еще одна структура для хранения данных – это <strong>объекты</strong>. Пример массивов из предыдущей главы может хранить как данные одинакового типа (строки), так и данные разных типов (строки, числа, boolean, undefined, null). Этот способ храннеия данных, по большому счету, валиден (корректен), однако не слишком удобен: чтобы получить доступ к какому-либо элементу из массива, нам нужно точно знать, на какой позиции расположено то или иное свойство. Поэтому для множетсва типов даннных, которые принадлежат к какому-то объекту, в JavaScript и существует тип хранения данных <strong>объекты</strong>. В коде объекты записываются следующим образом <strong>'let carToyota = {}';</strong>. В фигурных скобках перечисляются свойства объекта. Но они будут сохраняться не по их индексу, а по так называемому <strong>ключу</strong> (строке). Соответсвенно, в объекте есть ключ и его значение, по которому считывается информация. Более развернуто посмотрим на код:
                <div id="code_block">
                   <p class="code">
                      let carToyota = {
                   </p>
                   <p class="sub_code">
                      model: "Camry",
                   </p>
                   <p class="sub_code">
                      year: "2010",
                   </p>
                   <p class="sub_code">
                      carBody: "sedan",
                   </p>
                   <p class="sub_code">
                      color: "black",
                   </p>
                   <p class="sub_code">
                      hasAirbag: true
                   </p>
                   <p id="scobe">}</p>
                </div>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Далее мы можем обращаться к элементу объекта при помощи похожей записи, что мы рассматривали выше, только в этот раз используется не индекс, а название свойства обекта. На примере консоли: <strong>'console.log(carToyota["year"]);'</strong>. Но для обращения к свойству объекта не обязательно используется метод обращения, как к массиву – для этого есть специальная запись: <strong>'carToyota.year';</strong>. Это обращение к объекту по его ключу. То есть теперь нам не важно знать, на каком месте расположено то или иное свойство. Мы даже можем менять их местами – на результат это никак не повлияет. Есть небольшое отличие между двумя типами записей. В первом случае, когда элемент указывается в квадратных скобках, мы можем использовать переменную. Например, если мы создадим переменную с каким-либо свойством из массива, а затем обратимся к ней, то всё сработает корректно:
                <div id="code_block">
                   <p class="code">
                      let x = "Camry";
                   </p>
                   <p class="code">
                      console.log(carToyota[x]);
                   </p>
                </div>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Но если мы обратимся к <strong>'x'</strong> в формате записи <strong>'console.log(carToyota.x)'</strong>, то в результате мы получим значение <strong>'undefined'</strong>. В этом случае будет разыскиваться свойство с названием <strong>'x'</strong>, а не назначенная переменная.
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;В объектах точно так же можно менять одни свойства на другие. Например, цвет: <strong>'carToyota.color = "red";</strong>.
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Как и массив, объект точно так же можно вызвать. Например, в консоль: <strong>'console.log(carToyota);'</strong>.<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Для объектов так же существует не один способ их создания. В первом способе, который мы рассмотрели выше, мы сразу прописываем все поля. Но есть второй сопоб: 
                <div id="code_block">
                   <p class="code">
                      let carMazda = {};
                   </p>
                   <p class="code">
                      carMazda.year = 2018;
                   </p>
                   <p class="code">
                      carMazda.color = "blue";
                   </p>
                   <p class="code">
                      carMazda.model = "CX7";
                   </p>
                   <p class="code">
                      carMazda.carBody = "crossover";
                   </p>
                </div>
                <p class="post_pre_chap_6">
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;И еще один способ, как и при создании массивов – при помощи функции. Код выглядит следующим образом:</p>
                <div id="code_block">
                   <p class="code">
                      let carOpel = new Object();
                   </p>
                   <p class="code">
                      carOpel.body = "Hatchback";
                   </p>
                   <p class="code">
                      carOpel.year = 2018;
                   </p>
                   <p class="code">
                      carOpel.color = "blue";
                   </p>
                </div>
                <h3 class = "pre_chap_6" id="objects_massives">Массивы или объекты?</h3>
                <p class="post_pre_chap_6">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Так что же выбрать? Какие данные лучше отображать в массивах, а какие в объектах?<br>
                   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;В массивах лучше хранить данные одного вида (типа), то есть однообразные данные. Конечно, не воспрещается хранить в массивах и разнообразные данные, однако сопосб массивов для этих целей не представляется удобным. К примеру, массив с различными "цветами", где, конечно же, будут только цвета и ничего больше: <strong>let colors = ["red", "orange", "yellow", "white", "blue"];</strong>. Если же мы хотим сохранять данные разных типов (как в выше описанном примере с автомобилем), то лучше использовать способ объектов. Как например, информация о человеке: 
                <div id="code_block">
                   <p class="code">
                      let personIvan = {
                   </p>
                   <p class="sub_code">
                      firstName: "Иван",
                   </p>
                   <p class="sub_code">
                      lastName: "Иванов",
                   </p>
                   <p class="sub_code">
                      age: 24,
                   </p>
                   <p class="sub_code">
                      isMarried: false,
                   </p>
                   <p id="scobe">}</p>
                </div>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Но кроме того, и массивы и объекты могут хранить в себе другие массивы и/или объекты. Например, массив <strong>'numbers'</strong> (числа), может хранить в себе какие-то массивы с какими-то числами: <strong>'let numbers = [[1,2,3], [4,5,6], [7,8,9,10]];'</strong>. А далее, чтобы обратиться к этому массиву, к примеру, через консоль, нужно сначала указать индекс массива в массиве, а затем индекс самого элемента в выбранном массиве: <strong>'condole.log(numbers[1][2]);'</strong>.<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Обекты с массивами можно конфигурировать по-разному. К примеру, объекты могут содеражть в себе массивы. Вернемся к нашему примеру с <strong>'personIvan'</strong>:
                <div id="code_block">
                   <p class="code">
                      let personIvan = {
                   </p>
                   <p class="sub_code">
                      firstName: "Иван",
                   </p>
                   <p class="sub_code">
                      lastName: "Иванов",
                   </p>
                   <p class="sub_code">
                      age: 24,
                   </p>
                   <p class="sub_code">
                      isMarried: false,
                   </p>
                   <p class="sub_code">
                      pets: ["cat", "dog", "humster"]
                   </p>
                   <p id="scobe">}</p>
                </div>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;А чтобы обратиться к одному из элементов массива, нужно: <strong>'console.log(personIvan.pets[1]);'</strong>.<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Обекты могут хранить массивы, а массивы могут хранить объекты. К примеру, мы хотим сделать базу данных о продавцах автомобилей:
                <div id="code_block">
                   <p class="code">
                      let sellers = [
                   </p>
                   <p class="sub_code">{</p>
                   <p class="sub_sub_code">
                      firstName: "Иван",
                   </p>
                   <p class="sub_sub_code">
                      firstName: "Иванов",
                   </p>
                   <p class="sub_sub_code">
                      regDate: "09.08.2019",
                   </p>
                   <p class="sub_sub_code">
                      hasDiscount: false,
                   </p>
                   <p class="sub_sub_code">
                      age: 25
                   </p>
                   <p class="sub_code">},</p>
                   <p class="sub_code">{</p>
                   <p class="sub_sub_code">
                      firstName: "Gleb",
                   </p>
                   <p class="sub_sub_code">
                      firstName: "Glebov",
                   </p>
                   <p class="sub_sub_code">
                      regDate: "01.01.2010",
                   </p>
                   <p class="sub_sub_code">
                      hasDiscount: true,
                   </p>
                   <p class="sub_sub_code">
                      age: 34
                   </p>
                   <p class="sub_code">}</p>
                   <p id="scobe">]</p>
                </div>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;То есть, как можно заметить, у нас есть массив и внутри этого массива есть два объекта (можно создавать сколько угодно объектов). Как же нам обратиться к полям этих объектов? Есть два споосба. Мы можем обраться ко всему объекту, к примеру, в консоли: <strong>'console.log(sellers[1]);'</strong>. Или мы можем обратиться только к какой-то конкретной строке: <strong>'console.log(sellers[1].hasDiscount);'</strong>.
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;В реальной жизни мы можем создавать базы данных, а затем обращаться к конкретным элементам в них. Например, создать базу данных об автомобилях в автосалоне, а затем вывести только те автомобили, которые были проданы. Для этого, собственно, создадим базу данных. А затем создадим цикл, где будет высчитываться длина выводимой информации. Выглядеть это будет следуюющим образом:
                <div id="code_block">
                   <p class="code">
                      let cars = [
                   </p>
                   <p class="sub_code">{</p>
                   <p class="sub_sub_code">
                      carProd: "Mersedes",
                   </p>
                   <p class="sub_sub_code">
                      carModel: "SL900",
                   </p>
                   <p class="sub_sub_code">
                      color: "black",
                   </p>
                   <p class="sub_sub_code">
                      carYear: 2020,
                   </p>
                   <p class="sub_sub_code">
                      isSelled: true
                   </p>
                   <p class="sub_code">},</p>
                   <p class="sub_code">{</p>
                   <p class="sub_sub_code">
                      carProd: "Toyota",
                   </p>
                   <p class="sub_sub_code">
                      carModel: "Camry",
                   </p>
                   <p class="sub_sub_code">
                      color: "blue",
                   </p>
                   <p class="sub_sub_code">
                      carYear: 2019,
                   </p>
                   <p class="sub_sub_code">
                      isSelled: true
                   </p>
                   <p class="sub_code">},</p>
                   <p class="sub_code">{</p>
                   <p class="sub_sub_code">
                      carProd: "BMW",
                   </p>
                   <p class="sub_sub_code">
                      carModel: "X7",
                   </p>
                   <p class="sub_sub_code">
                      color: "white",
                   </p>
                   <p class="sub_sub_code">
                      carYear: 2021,
                   </p>
                   <p class="sub_sub_code">
                      isSelled: false
                   </p>
                   <p class="sub_code">},</p>
                   <p class="sub_code">{</p>
                   <p class="sub_sub_code">
                      carProd: "Audi",
                   </p>
                   <p class="sub_sub_code">
                      carModel: "A8L",
                   </p>
                   <p class="sub_sub_code">
                      color: "black",
                   </p>
                   <p class="sub_sub_code">
                      carYear: 2022,
                   </p>
                   <p class="sub_sub_code">
                      isSelled: false
                   </p>
                   <p class="sub_code">}</p>
                   <p id="scobe">];</p>
                   <p class="code">
                      for(let i = 0; i < cars.length; i++) {
                   </p>
                   <p class="sub_code">
                      if(cars[i].isSelled === false) {
                   </p>
                   <p class="sub_sub_code">
                      console.log(cars[i]);
                   </p>
                   <p class="sub_code">}</p>
                   <p id="scobe">}</p>
                </div>
                <p class="post_pre_chap_6">
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Для работы с массивами можно использовать не только цикл <strong>for</strong>. Так же можно использовать цикл <strong>forEach</strong> (от англ. для каждого), код выглядит следующим образом:</p>
                <div id="code_block">
                   <p class="code">
                      cars.forEach(function(car) {
                   </p>
                   <p class="sub_code">
                      if(car.isSelled === false) {
                   </p>
                   <p class="sub_sub_code">
                      console.log(car);
                   </p>
                   <p class="sub_code">}</p>
                   <p id="scobe">})</p>
                </div>
                <h3 class = "pre_chap_6" id="objects_methods">Методы объектов</h3>
                <p class="post_pre_chap_6">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Внутри объектов можно прописывать функции, выполняющие те или иные действия. Например, вычисление скидки в зависимости от длительности регистрации пользователя. Рассмотрим это используя вышеприведенный пример с продавцами автомобилей. Если пользователь зарегистрирован на сайте меньше двух лет, то он не имеет никакой скидки. Если от двух до пяти лет, то у него есть скидка 20%, а если больше пяти, то 30%. И далее вызвать метод этого объекта в консоль. Код будет выглядеть следующим образом:</p>
                <div id="code_block">
                   <p class="code">
                      let carSeller1 = {
                   </p>
                   <p class="sub_code">
                      firstName: "Игорь",
                   </p>
                   <p class="sub_code">
                      lastName: "Курушин",
                   </p>
                   <p class="sub_code">
                      regYear: 2017,
                   </p>
                   <p class="sub_code">
                      hasDiscount: true,
                   </p>
                   <p class="sub_code">
                      discountCalculation: function(year) {
                   </p>
                   <p class="sub_sub_code">
                      let discount;
                   </p>
                   <p class="sub_sub_code">
                      let numberOfYears = 2022 - year;
                   </p>
                   <p class="sub_sub_code">
                      if(numberOfYears <= 2) {
                   </p>
                   <p class="sub_sub_sub_sub_sub_code">
                      discount = 0;
                   </p>
                   <p class="sub_sub_code">} else if(numberOfYears > 2 && numberOfYears <= 5) {</p>
                   <p class="sub_sub_sub_sub_sub_code">
                      discount = 20;
                   </p>
                   <p class="sub_sub_code">} else if(numberOfYears > 5) {</p>
                   <p class="sub_sub_sub_sub_sub_code">
                      discount = 30;
                   </p>
                   <p class="sub_sub_code">}</p>
                   <p class="sub_sub_code">
                      return discount;
                   </p>
                   <p class="sub_code">}</p>
                   <p id="scobe">}</p>
                   <p class="code">
                      console.log(carSeller1.discountCalculation(2019));
                   </p>
                </div>
                <h3 class = "pre_chap_6" id="this">'this' в методе объекта</h3>
                <p class="post_pre_chap_6">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                   Как можно заметить, в выше рассмотренном методе функции мы используем значение, которое можно получить из самого объекта. В данном примере внутриобъектной функции, мы используем параметр <strong>'year'</strong>, то есть год регистрации пользователя. Но так как в самом объекте уже есть свойство с годом регистрации, то нам необязательно использовать для функции параметр <strong>'year'</strong>. Мы можем обратиться к обратиться непосредственно к свойству <strong>'regYear'</strong> внутри объекта через функцию. К этому свойству объекта внутри функции мы можем обратиться используя ключевое слово <strong>'this'</strong>. Выглядеть в этом случае и объект, и функция будут почти полностью идентично, поэтому не будем переписывать рассмотренный выше. Отметим только, что теперь параметр функции указываться не будет – скобки после слова <strong>'function'</strong> будут оставаться пустыми, а объявленная нами переменная <strong>'numberOfYears'</strong> будет теперь выглядеть так:<br>
                   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>'let numberOfYears = this.regYear';</strong>.<br>
                   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Теперь, чтобы получить результат выполнения функции, не нужно искусственно прописывать в коде вызова консоли параметр функции – функция будет брать данные для своей работы непосредственно из свойства объекта, то есть, из года регистрации пользователя.<br>
                   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Но мы можем пойти и еще дальше. Например, если выше описанный объект имеет свойство <strong>discount</strong>, в котором эта скидка указывается, например, по умолчанию скидка будет равна 0. А далее в коде мы можем объявить переменную <strong>'discount'</strong> и присвоить ей значение выше описанной функции с методом <strong>'this'</strong> и далее мы можем переменной <strong>'carSeller1.discount'</strong> присвоить значение переменной <strong>'discount'</strong>. То есть, мы присваиваем полю <strong>discount</strong> в объекте, значение, которое мы вычисляем с помощью выше описанной функции:
                <div id="code_block">
                   <p class="code">
                      let discount = carSeller1.discountCalculation();
                   </p>
                   <p class="code">
                      carSeller1.discount = discount;
                   </p>
                </div>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Но можно записать еще короче и сделать так, чтобы код обращался к объекту (carSeller1), затем к его свойству (discount) и отождествлял его с объектом (carSeller1), затем функцией (discountCalculation();). А затем вывести в консоль весь объект. В этом случае, будет выведен весь объект, а в нём автоматически прописываться вычисленный функцией процент скидки, в зависимости от года регистрации на сайте:
                <div id="code_block">
                   <p class="code">
                      carSeller1.discount = carSeller1.discountCalculation();
                   </p>
                </div>
                <p class="post_pre_chap_6">
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Но можно пойти еще дальше по пути оптимизации. Для этого мы можем больше не использовать <strong>'return'</strong> в функции, а обратиться к полю объекта <strong>discount</strong>. Сделать это можно с помощью <strong>'this.discount = discount;'</strong>. То есть, мы присваиваем свойству значения <strong>discount</strong> присваиваем значение внутренней переменной <strong>'discount'</strong>. Теперь мы можем не присваивать полю ничего дополнительного – весь функционал будет осуществляться внутри объекта. Присвоение свойству <strong>discount</strong> нового значения при помощи свойства <strong>regYear</strong>. Итак, весь код для справки будет выглядеть так, для лучшего понимания, снова запишем:</p>
                <div id="code_block">
                   <p class="code">
                      let carSeller1 = {
                   </p>
                   <p class="sub_code">
                      firstName: "Игорь",
                   </p>
                   <p class="sub_code">
                      lastName: "Курушин",
                   </p>
                   <p class="sub_code">
                      regYear: 2010,
                   </p>
                   <p class="sub_code">
                      discount: 0,
                   </p>
                   <p class="sub_code">
                      calculateDiscount: function() {
                   </p>
                   <p class="sub_sub_code">
                      let discount;
                   </p>
                   <p class="sub_sub_code">
                      let numberOfYears = 2022 - this.regYear;
                   </p>
                   <p class="sub_sub_code">
                      if(numberOfYears <= 2) {
                   </p>
                   <p class="sub_sub_sub_sub_sub_code">
                      discount = 0;
                   </p>
                   <p class="sub_sub_code">} else if(numberOfYears > 2 && numberOfYears <= 5) {</p>
                   <p class="sub_sub_sub_sub_sub_code">
                      discount = 20;
                   </p>
                   <p class="sub_sub_code">} else if(numberOfYear > 5) {</p>
                   <p class="sub_sub_sub_sub_sub_code">
                      discount = 30;
                   </p>
                   <p class="sub_sub_code">}</p>
                   <p class="sub_sub_code">
                      this.discount = discount;
                   </p>
                   <p class="sub_code">}</p>
                   <p id="scobe">}</p>
                   <p class="code">
                      carSeller1.calculateDiscount();
                   </p>
                   <p class="code">
                      console.log(carSeller1);
                   </p>
                </div>
                <h3 class = "pre_chap_6" id="dom">DOM</h3>
                <p class="post_pre_chap_6">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                   Как можно понять, JavaScript нужен, конечно, совсем не для того, чтобы выполнять какие-то игрушечные абстрактные задачи вроде выведения в консоль вычисления площади прямоугольника или содержимого массивов. JavaScript нужен для взаимодействия, а главное – управления HTML и CSS содержимым на веб-странице. Делается это с помощью понятия <strong>DOM</strong>, что означает <strong>Document Object Model</strong> (от англ. Объектная Модель Документа).
                </p>
                <h3 class = "pre_chap_6" id="dom_selectors">DOM. Селекторы</h3>
                <p class="post_pre_chap_6">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                   Для доступа к различным HTML-элементам с помощью стандарта <strong>DOM</strong> точно так же, как и в случае с <strong>CSS</strong> используются <strong>селекторы</strong>. Существует несколько видов селекторов:
                </p>
                <ul class="list_10">
                   <li>document.getElementById();</li>
                   <li>document.getElementsByClassName();</li>
                   <li>document.getElementsByTagName();</li>
                   <li>document.querySelector();</li>
                   <li>document.querySelectorAll();</li>
                </ul>
                <p class="post_pre_chap_6">
                   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Начнем с первого селектора – <strong>'document.getElementById();'</strong>. С помощью этого селектора, к примеру, можно заполнить любой тег на странице, которых до этого был пустым, допустим, параграф, где написано - "Привет, Мир!". Поскольку, как можно заметить, если попытаться развернуть и перевести название селектора (это будет "Получить элемент по ID"), то этому параграфу нужно своевременно (до выполнения кода), присвоить ID, по которому этот код будет выполняться. Выглядеть код будет так:<br>
                   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>'document.getElementById("paragraph").innerHTML = "Привет, Мир!";'</strong>.<br><br><br><br>
                   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Следующий селектор <strong>'ducument.getElementByClassName();'</strong> – находит все элементы по имени указанного класса. То есть, мы можем присвоить HTML-элементам какие-то классы, а затем этот селектор способен возвращать их для дальнейшей с ними работы, например, изменения/добалвения контента. Проще говоря, этот селектор занимается примерно тем же, что и классы в HTML – собирает в себя другие элементы, объединяя в группу. Принцип его работы состоит только в том, чтобы собрать по HTML-коду все эелементы с прописанным (указанным) в селекторе классом, а затем возвратить (передать) эту информацию для дальнейшей работы кому-нибудь другому. Схема применения может выглядеть следующим образом:
                <div id="code_block">
                   <p class="code">
                      &lt;!DOCTYPE html&gt;
                   </p>
                   <p class="code">
                      &lt;html lang="ru"&gt;
                   </p>
                   <p class="code">
                      &lt;head&gt;
                   </p>
                   <p class="sub_code">
                      &lt;meta charset="UTF-8"&gt;
                   </p>
                   <p class="sub_code">
                      &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
                   </p>
                   <p class="sub_code">
                      &lt;title&gt;DOM&lt;/title&gt;
                   </p>
                   <p class="code">
                      &lt;/head&gt;
                   </p>
                   <p class="code">
                      &lt;body&gt;
                   </p>
                   <p class="sub_code">
                      &lt;h2&gt;Поиск HTML элементов по имени класса&lt;/h2&gt;
                   </p>
                   <p class="sub_code">
                      &lt;p&gt;Привет, Мир!&lt;/p&gt;
                   </p>
                   <p class="sub_code">
                      &lt;p class="intro">DOM очень полезен.&lt;/p&gt;
                   </p>
                   <p class="sub_code">
                      &lt;p class="intro">Этот пример демонстрирует метод getElementByClassName.&lt;/p&gt;
                   </p>
                   <p class="sub_code">
                      &lt;p id="demo">&lt;/p&gt;
                   </p>
                   <p class="sub_code">
                      &lt;script&gt;
                   </p>
                   <p class="sub_sub_code">
                      let x = document.getElementByClassName("intro");
                   </p>
                   <p class="sub_sub_code">
                      document.getElementById("demo").innerHTML = 'Первый параграф (индекс 0) с классом="intro": ' + x[0].innerHTML;
                   </p>
                   <p class="sub_code">
                      &lt;/script&gt;
                   </p>
                   <p class="code">
                      &lt;/body&gt;
                   </p>
                   <p class="code">
                      &lt;/html&gt;
                   </p>
                </div>
                <div class="faq_all">
                   <div class="f_img_20">
                      <img class = "faq_img" src = "/instruction/img/faq.png">
                   </div>
                   <div class="p_faq20">
                      <p class="faq_p">*для справки: метод <strong>'.innerHTML'</strong> отвечает за отображение выбранного HTML-элемента. С помощью него, к примеру, можно обратиться, то есть прочесть и/или вывести контент любого тега и/или заменить его.
                      </p>
                   </div>
                </div>
                <p class="post_pre_chap_6">
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Принцип работы этого кода довольно прост. В HTML мы создаем два параграфа заполненные текстом с классом <strong>'intro'</strong> и один пустой параграф с id <strong>'demo'</strong>. Далее мы объявляем переменную <strong>'x'</strong> и присваиваем ей значение в виде <strong>'document.getElementByClassName("intro");'</strong>, то есть переменная <strong>'x'</strong> теперь представляет тот контент, который входит в класс <strong>'intro'</strong>. Как и все прочие перечисления индексов элементов в JS, селекторы при работе с DOM не стали исключением и тоже отсчитываются от ноля. Далее мы вставляем в пустой параграф с id <strong>'demo'</strong> текст <strong>'Первый параграф (индекс 0) с классом="intro": '</strong> с помощью <strong>'document.getElementById("demo")'</strong> и приплюсовываем ко всему этому переменную <strong>'x[0]'</strong> с индексом 0, так как у нас два параграфа с классом <strong>'intro'</strong>, а исчисляются индексы, как говорилось выше, начиная от ноля, а затем вставляем всё это в тот же пустой параграф.<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Выглядит запутано, но глядя на код выше и вчитываясь в это запутанную инструкцию (пусть даже придется прочесть не один раз), всё непременно будет ясно.<br><br><br><br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Следюущий селектор в нашем списке – это <strong>document.getElementByTagName();</strong>. Этот селектор по принципу своего действия очень похож на предыдущий, но с одним, как можно догадаться по названию, отличием: он находит в документе HTML-теги. Можно сказать, что у этого и предыдущего селектора буквально один и тот же принцип действия, только в этот раз мы бы подставляли не класс, а название тега: параграф, заголовок и/или другие.<br><br><br><br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Следующий селектор выбора элементов – <strong>'document.querySelector();'</strong>. Этот селектор работает уже <strong>не с HTML-тегами</strong>, а <strong>с селекторами CSS</strong>. Как говорилось выше, JS позволяет работать (манипулировать/взаимодействовать) не только с HTML, но и CSS. К примеру, если у нас есть заголовок в HTML с id 'header', то с помощью этого селектора мы можем обратиться к нему точно так же, как в CSS, то есть: <strong>'ducument.querySelector("#header");'</strong>. Это актуально и в случае обращения к классу. Важно отметить, что при выборе селектором <strong>'querySelector'</strong> класса будут выбираться не все элементы с соответсвующими классами, а только <strong>первое</strong> совпадение.<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Чтобы выбрать все элементы с одинаковыми нужными нам классами или тегами, существует вариация селектора <strong>'querySelector'</strong> – <strong>'querySelectorAll'</strong>.
                </p>
                <h3 class = "pre_chap_6" id="dom_changing_content">DOM. Изменение контента</h3>
                <p class="post_pre_chap_6">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Рассмотрим, как можно манипулировать полученными с помощью селекторов объектами.<br>
                   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Как уже говорилось выше, есть способ обратиться к содержимому HTML-элемента. Это делается с помощью свойства <strong>'.innerHTML'</strong>. Но есть и второй способ – это свойство <strong>'.textContent'</strong>. В чем же разница? Разница в том, что свойство <strong>'.innerHTML'</strong> занимается не только отображением "сухого" текста, то есть, буквально содержимого тега, а вообще всего, что касается этого тега. То есть, если рассмотреть принцип его работы на примере, допустим, тега <strong>'ul'</strong> – неупорядоченного списка – то как результат работы свойства <strong>'.innerHTML'</strong> (его возвращения), мы получим всю структуру тега <strong>'ul'</strong> с его дочерними элементами, текстом и всем прочим (к примеру, тегом strong). Свойство <strong>'.textContent'</strong> же занимается буквальным отображением тектсового содержимого, где не будет ничего, кроме текста, который содержит тег, к которому совершено обращение. По этой причине, при изменении текста с помощью свойства <strong>'.innerHTML'</strong> нужно указывать не только текст, но и сам тег, текст внутри которого требуется изменить.
                </p>
                <h3 class = "pre_chap_6" id="dom_changing_styles">DOM. Изменение стилей</h3>
                <p class="post_pre_chap_6">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                   Изменение стилей с помощью DOM и JS провернуть довольно просто. Допустим, в HTML документе у нас есть заголовок, у этого заголовка есть id="header". Чтобы изменить его стиль с помощью JS, код будет выглядеть следующим образом (для удобства запишем функцию с методом (селектором) как переменную):
                <div id="code_block">
                   <p class="code">
                      let h1 = document.getElementById("header");
                   </p>
                   <p class="code">
                      h1.style.color = "red";
                   </p>
                </div>
                <p class="post_pre_chap_6">
                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Этим кодом мы через JS обратились по id к заголовку и стилизовали его, сделав его цвет красным.<br>
                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Кроме того, исходя из концепции DOM, JS позволяет добавлять не сущестовавшие ранее классы. Для этого существует метод <strong>'.classList.add("навзание_нового_класса");'</strong>. У добавления/создания чего-либо, конечно, есть и обратное действие, для этого есть метод<span class="break"><strong>'.classList.remove("название_удаляемого_класса");'</strong></span>. 
                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Еще один метод, который часто используют для добавления/удаления классов – это <span class="break"><strong>'.classList.toggle("название_класса");'</strong></span>. Этот метод работает как некий переключатель – при первом срабатывании он "включает" новый класс, создавая его, при втором, соответственно, "выключает", удаляя.</p>
                <div class="faq_all">
                   <div class="f_img_21">
                      <img class = "faq_img" src = "/instruction/img/faq.png">
                   </div>
                   <div class="p_faq21">
                      <p class="faq_p">*для справки: разумеется, используя все перечисленные методы для добавления и/или удаления классов, нужно использовать селекторы обращения к элементам. То есть, используя один из представленных выше методов, полная конструкция будет выглядеть так: <strong>'document.getElementById("некий_id").classList.toggle("некий_класс");'</strong>.
                      </p>
                   </div>
                </div>
                <h3 class = "pre_chap_6" id="dom_changing_attributes">DOM. Изменение атрибутов</h3>
                <p class="post_pre_chap_6">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                   Концепцию манипуляции с атрибутами было бы удобно рассмотреть с точки зрения такого явления в веб-разработке, как "Image Gallery" – галереи изображений. То есть, некой структуры (блока) на сайте, который включает в себя серию (набор) неких изображений, относящихся к тематике сайта. Эти изображения по нажатию, например, на некую кнопку перелистывания, требуется каким-то образом менять. Для этого и применяется методика, описываемая далее.<br>
                   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Итак, для начала, как можно вспомнить из начала этой "инструкции" тома по HTML, нам нужно добавить на страницу некую фотографию, а лучше – набор фотографий. Пусть это будет пять фотографий котов.
                </p>
                <div id="div_cats">
                    <div class="cat"><img id="cats" src="/instruction/img/cat1.jpeg"></div>
                    <div class="cat"><img id="cats" src="/instruction/img/cat2.jpeg"></div>
                    <div class="cat"><img id="cats" src="/instruction/img/cat3.jpeg"></div>
                    <div class="cat"><img id="cats" src="/instruction/img/cat4.jpeg"></div>
                    <div class="cat"><img id="cats" src="/instruction/img/cat5.jpeg"></div>
                </div>
                <p class="post_pre_chap_6">
                   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>ПОДЦЕПИТЬ КОГДА-НИБУДЬ КАКУЮ-НИБУДЬ ГАЛЕРЕЮ ИЗОБРАЖЕНИЙ ДЛЯ КОТОВ!!!</strong> И теперь, с помощью JS, мы можем воздействовать на эти изображения. Для начала нам нужно с помощью одного из уже известных селекторов обратиться к этим изображениям:
                <div id="code_block">
                   <p class="code">
                      let cats = document.querySelector("#cats");
                   </p>
                   <p class="code">
                      cats[0].getAttribute("src");
                   </p>
                   <p class="code">
                      cats[0].setAttribute("src", "img/cat2.jpeg");
                   </p>
                </div>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Как видно из кода, с помощью объявленной переменной <strong>'cats'</strong> и индекса (порядкового номера) "0" мы обращаемся к атрибуту <strong>'src'</strong> первого изображения и получаем его. Затем мы меняем значение этого атрибута с помощью метода <strong>'.setAttribute'</strong>, у которого используется не только значение <strong>'src'</strong>, но и то значение, которое требуется заменить. В данном случае, это путь к новому изображению – <strong>'img/cat2.jpeg'</strong>.<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Точно так же, мы можем менять и любой другой атрибут, к примеру атрибут ссылки – тега <strong>'a'</strong>:
                <div id="code_block">
                   <p class="code">
                      let link = document.querySelector("#link");
                   </p>
                   <p class="code">
                      link[0].setAttribute("href", "http://ya.ru");
                   </p>
                </div>
                <p class="post_pre_chap_6">
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;В этом случае, если у нас есть некая ссылка с ID "link", у которой уже будет прописын некий URL, то он будет заменен на тот, что мы прописали, то есть на ya.ru.
                </p>
                <h3 class = "pre_chap_6" id="dom_events">DOM. Events</h3>
                <p class="post_pre_chap_6">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                   Что такое "events"? Events в переводе с англиского – события. То есть, мы можем изменять объекты DOM структуры с помощью JS по ккаким-то событиям. Схема орагнизации реакции на какие-либо события выглядит следующим образом. Для начала нам, конечно, нужно выбрать какой-то элемент, с которым мы и будем работать. Затем, нужно добавить так называемого  <strong>Event Listener</strong> – прослушивателя события. Он через точку записывается после обращения к элементу, а после него в круглых скобках и кавычках пишется, непосредственно событие. Самое распространенное, к примеру <strong>'click'</strong>. Вторым елементом указывается функция, в которой мы пишем код, который будет запускаться, когда будет кликнут выбранный нами элемент. Ну а дальше всё как обычно из принципа работы функции. К примеру, изменим цвет заголовка на красный. Рассмотрим это на практике. Допустим, у нас есть эелемент заголовка – <strong>h1</strong> с id "test". Код JS будет выглядеть следующим образом:
                <div id="code_block">
                   <p class="code">
                      let h1 = document.getElementById("test");
                   </p>
                   <p class="code">
                      h1.addEventListener("click", function() {
                   </p>
                   <p class="sub_code">
                      this.style.color = (this.style.color == 'black') ? 'red' : 'black';
                   </p>
                   <p class="code">
                      });
                   </p>
                </div>
                <h1 id="events_h1">Тестовый заголовок меняющий цвет по нажатию!</h1>
                <script type="text/javascript">				 
                   let h1Test = document.getElementById("events_h1");
                   h1Test.addEventListener("click", function() {
                       this.style.color = (this.style.color == 'white') ? 'red' : 'white';
                   });
                </script>
                <p class="post_pre_chap_6">
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Для одного элемента мы можем устанавливать несколько <strong>Event Listener</strong>.<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Точно такой же функционал, как и со сменой цвета заголовка из примера выше, мы можем цеплять и, к примеру, к кнопкам. Для наглядности и простоты, кнопка тоже будет менять цвет. По нажатию она будет менять цвет фона всей страницы! А код будет выглядеть следующим образом (HTML-код мы поместим в синюю рамку, а JS-код в красную):</p>
                <div id="code_block_HTML">
                   <p class="code">
                      &lt;button id="button_test"&gt;Сменить цвет!&lt;/button&gt;
                   </p>
                </div>
                <div id="code_block_js">
                   <p class="code">
                      let button = document.getElementById("button_test");
                   </p>
                   <p class="code">
                      let isButtonApplied = false;
                   </p>
                   <p class="code">
                      button.addEventListener("click", function() {
                   </p>
                   <p class="sub_code">
                      if(isButtonApplied === false) {
                   </p>
                   <p class="sub_sub_code">
                      ducument.querySelector("body").style.background = "black";
                   </p>
                   <p class="sub_sub_code">
                      isButtonApplied = true;
                   </p>
                   <p class="sub_code">} else if (isButtonApplied === true) {</p>
                   <p class="sub_sub_code">
                      document.querySelector("body").style.background = "#F0F0F2";
                   </p>
                   <p class="sub_sub_code">
                      isButtonApplied = false;
                   </p>
                   <p class="sub_code">}</p>
                   <p class="code">});</p>
                </div>
                <button id="button_test">Сменить цвет!</button>
                <script type="text/javascript">
                   let button = document.getElementById("button_test");
                   let isButtonApplied = false;
                   button.addEventListener("click", function() {
                       if(isButtonApplied === false) {
                           document.querySelector("body").style.background = "black";
                           isButtonApplied = true;
                       } else if(isButtonApplied === true) {
                           document.querySelector("body").style.background = "#F0F0F2";
                           isButtonApplied = false;	
                       }
                   });
                </script>
                <h3 class = "pre_chap_6" id="js_game">Финал JS. Игра на реакцию на web-странице</h3>
                <p class="post_pre_chap_6">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                   Внимательно смотрите за кодом, как обычно HTML-код мы разместим внутри синей рамки, JS-код в красной, а CSS будет в зеленой:</p>
                <div id="code_block_HTML">
                   <p class="code">
                      &lt;div id="shape"&gt;&lt;/div&gt;
                   </p>
                   <p class="code">
                      &lt;h3&gt;Время реакции &lt;span id="reactionTime"&gt;&lt;/span&gt;&lt;/h3&gt;
                   </p>
                </div>
                <div id="code_block_CSS">
                   <p class="code">
                      #shape {
                   </p>
                   <p class="sub_code">
                      width: 150px;
                   </p>
                   <p class="sub_code">
                      height: 150px;
                   </p>
                   <p class="sub_code">
                      background-color: green;
                   </p>
                   <p class="sub_code">
                      dysplay: none;
                   </p>
                   <p class="sub_code">
                      position: relative;
                   </p>
                   <p class="code">}</p>
                </div>
                <div id="code_block_js">
                   <p class="code">
                      let startTime = new Date().getTime();
                   </p>
                   <p class="code">
                      function getRandomColor() {
                   </p>
                   <p class="sub_code">
                      let letters = "0123456789ABCDEF".split('');
                   </p>
                   <p class="sub_code">
                      let color = "#";
                   </p>
                   <p class="sub_code">
                      for(let i = 0; i < 6; i++) {
                   </p>
                   <p class="sub_sub_code">
                      color += letters[Math.floor(Math.random() * 16)];
                   </p>
                   <p class="sub_code">}</p>
                   <p class="sub_code">
                      return color;
                   </p>
                   <p class="code">}</p>
                   <p class="code">
                      let makeShapeVisible = function() {
                   </p>
                   <p class="sub_code">
                      let shape = document.getElementById("shape");
                   </p>
                   <p class="sub_code">
                      let top = Math.random() * 400;
                   </p>
                   <p class="sub_code">
                      let left = Math.random() * 700;
                   </p>
                   <p class="sub_code">
                      let width = Math.random() * 200 + 50;
                   </p>
                   <p class="sub_code">
                      shape.style.top = top + "px";
                   </p>
                   <p class="sub_code">
                      shape.style.left = left + "px";
                   </p>
                   <p class="sub_code">
                      shape.style.width = width + "px";
                   </p>
                   <p class="sub_code">
                      if(Math.random() > 0.3) {
                   </p>
                   <p class="sub_sub_code">
                      shape.style.borderRadius = "50%";
                   </p>
                   <p class="sub_sub_code">
                      shape.style.borderBottom = "0";
                   </p>
                   <p class="sub_sub_code">
                      shape.style.backgroundColor = getRandomColor();
                   </p>
                   <p class="sub_code">
                      } else if(Math.random() >= 0.3 && Math.random() <= 0.7) {
                   </p>
                   <p class="sub_sub_sub_code">
                      shape.style.borderRadius = "0";
                   </p>
                   <p class="sub_sub_sub_code">
                      shape.style.backgroundColor = getRandomColor();
                   </p>
                   <p class="sub_sub_sub_code">
                      shape.style.borderRadius = "0";
                   </p>
                   <p class="sub_code">
                      } else if(Math.random() > 0.7) {
                   </p>
                   <p class="sub_sub_code">
                      shape.style.left = "0";
                   </p>
                   <p class="sub_sub_code">
                      shape.style.left = "0";
                   </p>
                   <p class="sub_sub_code">
                      shape.style.borderLeft = "50px solid transparrent";
                   </p>
                   <p class="sub_sub_code">
                      shape.style.borderReft = "50px solid transparrent";
                   </p>
                   <p class="sub_sub_code">
                      shape.style.borderBottom = "100px solid " + getRandomColor();
                   </p>
                   <p class="sub_sub_code">
                      shape.style.backgroundColor = "transparrent";
                   </p>
                   <p class="sub_code">}</p>
                   <p class="sub_code">
                      shape.style.dysplay = "block";
                   </p>
                   <p class="sub_code">
                      startTime = new Date().getTime();
                   </p>
                   <p class="code">
                      }
                   <p class="code">
                      setTimeout(makeShapeVisible, Math.random() * 1000);
                   </p>
                   <p class="code">
                      document.getElementById("shape").onclick = function() {
                   </p>
                   <p class="sub_code">
                      let shape = document.getElementById("shape");
                   </p>
                   <p class="sub_code">
                      shape.style.dysplay = "none";
                   </p>
                   <p class="sub_code">
                      let finishTime = new Date().getTime();
                   </p>
                   <p class="sub_code">
                      let reactionTime = (finishTime - startTime) / 1000;
                   </p>
                   <p class="sub_code">
                      document.getElementById("reactionTime").innerHTML = reactionTime + " секунд";
                   </p>
                   <p class="sub_code">
                      setTimeout(makeShapeVisible, Math.random() * 1000);
                   </p>
                   <p class="code">}</p>
                </div>
                <div id="game">
                   <div id="shape"></div>
                   <h3>Время реакции <span id="reactionTime"></span></h3>
                   <script type="text/javascript">
                      let startTime = new Date().getTime();
                      
                      function getRandomColor() {
                      
                          let letters = "0123456789ABCDEF".split('');
                          let color = "#";
                      
                          for(let i = 0; i < 6; i++) {
                              color += letters[Math.floor(Math.random() * 16)];
                          }
                          return color;
                      }
                      
                      let makeShapeVisible = function() {
                      
                          let shape = document.getElementById("shape");
                          let top = Math.random() * 400;
                          let left = Math.random() * 400;
                          let width = Math.random() * 200 + 50;
                          shape.style.top = top + "px";
                          shape.style.left = left + "px";
                          shape.style.width = width + "px";
                      
                          if(Math.random() > 0.3) {
                              shape.style.borderRadius = "50%";
                              shape.style.borderBottom = "0";
                              shape.style.backgroundColor = getRandomColor();
                          } else if(Math.random() >= 0.3 && Math.random() <= 0.7) {
                              shape.style.borderRadius = "0";
                              shape.style.backgroundColor = getRandomColor();
                              shape.style.borderRadius = "0";
                          } else if(Math.random() > 0.7) {
                              shape.style.left = "0";
                              shape.style.left = "0";
                              shape.style.borderLeft = "50px solid transparrent";
                              shape.style.borderReft = "50px solid transparrent";
                              shape.style.borderBottom = "100px solid " + getRandomColor();
                              shape.style.backgroundColor = "transparrent";
                          }
                      
                          shape.style.dysplay = "block";
                          startTime = new Date().getTime();
                      }
                      
                      setTimeout(makeShapeVisible, Math.random() * 1000);
                      
                      document.getElementById("shape").onclick = function() {
                      
                      let shape = document.getElementById("shape");
                      shape.style.dysplay = "none";
                      
                      let finishTime = new Date().getTime();
                      let reactionTime = (finishTime - startTime) / 1000;
                      document.getElementById("reactionTime").innerHTML = reactionTime + " секунд";
                      setTimeout(makeShapeVisible, Math.random() * 1000);
                      }
                   </script>
                   <br><br><br><br><br><br><br><br><br><br>
            </div>
  
  
  
  
  
  
  
  
  
            <div class="tom" id="tom4">
                <h2>Том IV. jQuery</h2>
            </div>
  
            <div class="jquery_block">
              <h3 id="jquery_basics" class="pre_chap_6">Общие положения</h3>
                <p class = "post_pre_chap_6">
                   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                   jQuery – это библиотека, построенная на основе языка JavaScript. То есть, весь код, написанной на этой библиотеке, соответственно, написан на этом языке. В целом, библиотеки в языках программирования – это сборники подпрограмм или объектов, используемых для разработки программного обеспечения. То есть, дополнительные средства, добавляющие функционал и/или упрощающие манипуляции с кодом программы. Говоря еще проще: библиотека – это набор из каких-то кусков кода, которые были написаны другими программистами для общего пользования. И подключая эти куски кода к коду нашей программы, мы можем значительно повысить функционал и/или упростить его реализацию.<br>
                   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Для того, чтобы использовать библиотеку jQuery, её необходимо сначала подключить к веб-странице. Один из популярных вариантов сделать это – с помщью сайта <strong>'googleapis'</strong>. Для этого мы просто вставляем в тег <strong>'head'</strong> ссылку на внешний источник:<br>
                   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="break"><strong>&lt;script&gt;src="https://ajax.googleapis.com/ajax/libs/jquery/3.6.1/jquery.min.js"&lt;/script&gt;</strong></span> – это и есть внешняя ссылка для подключения библиотеки.<br>
                   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Код с помощью jQuery записывается следующим образом: в начале всегда пишется знак доллара – <strong>$</strong>, то есть это обращение (выбор) того, что мы указываем далее в скобках, к примеру весь HTML-документ или что-то другое. Далее пишется <strong>'.ready'</strong>, то есть код будет выполняться тогда, когда документ будет готов – загружен. Далее пишется ключевое слово <strong>'function()'</strong>, после чего открываются фигурные скобки. Внутри фигурных скобок, соответственно, мы можем писать код, который будет выполняться после загрузки документа. Пример в коде ниже выполняет функцию выбора всех заголовков <strong>'h3'</strong>, при нажатии на которые у них будет меняться цвет фона. После обращений к заголовкам (после доллара) для того, чтобы действие выполнялось по клику, пишется <strong>.click</strong>, а затем снова <strong>'function()'</strong>:</p>
                <div id="code_block_js">
                   <p class="code">
                      $(document).ready(function() {
                   </p>
                   <p class="sub_code">
                      $("h3").click(function() {
                   </p>
                   <p class="sub_sub_code">
                      $(this).css("background-color", "red");
                   </p>
                   <p class="sub_code">});</p>
                   <p class="code">});</p>
                </div>
                <h3 id="jquery_selector" class = "pre_chap_6">Селектор</h3>
                <p class = "post_pre_chap_6">
                   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                   Как можно вспомнить из главы выше, в JS существует несколько методов обращения к какому-либо элементу – селекторов. В jQuery всё выбирается при помощи одного селектора. Этот селектор уже был представлен в главе выше – это знак <strong>'$'</strong>. Таким образом можно обращаться к любому объекту (элементу) в HTML. Будть до заголовки, списки или все элементы в списке (<strong>'$('h3');'</strong>). Но что делать, если нам нужно обратиться к какому-то конкретному элементу, например, в том же списке? Это делается с помощью такого же селектора, но в круглых скобках последовательно указывается интересующий нас эелемент. К примеру, у нас есть два списка, один неупорядоченный, другой упорядоченный. Но нам нужно взаимодействовать только с элементами из упорядоченного списка. Выглядеть код будет так: <strong>'$('ol li')'</strong>. Точно так же мы можем обратиться к элементами мы можем и по ID. Делается это так: <strong>$('#ваш_ID')</strong>. Та же схема актуальна и для класса. 
                </p>
                <h3 id="jquery_css_method" class = "pre_chap_6">Метод css()</h3>
                <p class = "post_pre_chap_6">
                   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                   Как вы могли заметить, в главе об общих положениях использовался метод <strong>.css</strong>. Этот метод, как можно догадаться, позволяет взаимодействовать с элементами на уровне стилей. То есть, если мы создаем какой-то элемент в HTML с ID: 
                <div id="code_block_HTML">
                   <p class="code">
                      &lt;h3 id="header"&gt;Заголовок&lt;/h3&gt;
                   </p>
                </div>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Затем мы можем задать этому эелементу какой-то стиль с помощью jQuery при помощи метода <strong>.css</strong>:
                <div id="code_block_js">
                   <p class="code">
                      $(#header).css('bacgroundColor', 'red');
                   </p>
                </div>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Как можно заметить, такой метод записи обращений к стилям гораздо короче, чем при помощи селекторов в JS. Но это не единственное и не самое главное приимущество. Дело в том, что мы в одном методе вызова CSS можем поменять сразу несколько свойств. Делается это при помощи объекта:
                <div id="code_block_js">
                   <p class="code">
                      let testStyle = {
                   </p>
                   <p class="sub_code">
                      color: "green",
                   </p>
                   <p class="sub_code">
                      background: "yellow",
                   </p>
                   <p class="sub_code">
                      border: "1px solid red"
                   </p>
                   <p class="code">};</p>
                </div>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Теперь этот созданный объект с набором стилей можно применить. Запись при этом будет чрезвычайно простой:
                <div id="code_block_js">
                   <p class="code">
                      $('h3').css(testStyle);
                   </p>
                </div>
                <p class="post_pre_chap_6">
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Для сравнения и лучшего понимания, можно рассмотреть, как бы выглядел бы код для изменения цвета элементов списка, но уже без применения jQuery, а на обычном JS:</p>
                <div id="code_block_js">
                   <p class="code">
                      let colors = document.querySelectorAll('h3');
                   </p>
                   <p class="code">
                      for(let i = 0; i < colors.length; i++) {
                   </p>
                   <p class="sub_code">
                      colors[i],style.color = 'blue';
                   </p>
                   <p class="code">};</p>
                </div>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;А вот так с помощью jQuery:
                <div id="code_block_js">
                   <p class="code">
                      $('ul li').css('blue');
                   </p>
                </div>
                <h3 id="jquery_text_method" class = "pre_chap_6">Метод text()</h3>
                <p class = "post_pre_chap_6">
                   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                   При помощи метода <strong>.text()</strong> можно получать и/или устанавливать любой текст. Этот метод вполне можно рассмтаривать как версию метода <strong>'.textContent'</strong> в JS. У метода <strong>.text()</strong> есть особенность: он выбирает не только текст в выбранном элементе, но и текст во всех потомках выбранного элемента. Работа этого метода так же проста, как и работа предыдущего метода. К примеру, если нам нужно получить текстовый контент какого-либо элемента, то код будет выглядеть так:
                <div id="code_block_js">
                   <p class="code">
                      $('h3').text();
                   </p>
                </div>
                <p class="post_pre_chap_6">
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Если же нам нужно изменить текстовое содержимое в выбранном элементе, то код будет выглядеть так:</p>
                <div id="code_block_js">
                   <p class="code">
                      $('h3').text('Новый текст');
                   </p>
                </div>
                <div class="faq_all">
                   <div class="f_img_22">
                      <img class = "faq_img" src = "/instruction/img/faq.png">
                   </div>
                   <div class="p_faq22">
                      <p class="faq_p">*для справки: у jQuery существует <strong>очень</strong> большое множетсво самых различных методов, уместить описание которых в эту инструкцию задача непростая да и не рациональная. Поэтому, я вижу рациональным оставить ссылку на официальный сайт jQuery, где есть подробное описание каждого из всех методов с инструкциями и примерами в виде кода. Ссылка находится <a id="methods" href="https://api.jquery.com/">здесь</a>. 
                      </p>
                   </div>
                </div>
                <h3 id="jquery_html_method" class = "pre_chap_6">Метод html()</h3>
                <p class = "post_pre_chap_6">
                   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                   Метод jQuery <strong>.html()</strong> по своему принципу одинаков с методом из ванильного JS <strong>.innerHTML</strong>. Но, как и многие остальные манипуляции с помощью jQuery, этот метод позволяет проще взаимодействовать с HTML документом, изменяя его. К примеру, если в списке мы хотим заменить все его элементы на элементы ссылок, то код бы выглядел таким образом:
                </p>
                <div id="code_block_js">
                   <p class="code">
                      $('li').html('&lt;a href="http://google.com"&gt;Сайт Google&lt;/a&gt;');
                   </p>
                </div>
                <div class="faq_all">
                   <div class="f_img_23">
                      <img class = "faq_img" src = "/instruction/img/faq.png">
                   </div>
                   <div class="p_faq23">
                      <p class="faq_p">*для справки: важным уточнением было бы то, что если в HTML присутствует какой-то элемент &lt;input&gt;, то с помощью jQuery этот элемент необходимо распознавать при помощи метода <strong>.text()</strong>, а не при помощи <strong>'.html()'</strong>. Это делается с целью безопасности, защищая сайт от "терроризма". Дело в том, что знающий программирование пользователь может отослать какой-либо JS код в поле input, дав какие-то инструкции и таким образом легко повредить сайт.  
                      </p>
                   </div>
                </div>
                <h3 id="jquery_attr_method" class = "pre_chap_6">Метод attr()</h3>
                <p class = "post_pre_chap_6">
                   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                   Как можно догадаться из названия, метод <strong>.attr()</strong> используется в jQuery для манипуляции с атрибутами в HTML, подобно методу <strong>.getAttribute</strong> из ванильного JS. Рассматривать подробнее этот метод не вижу смысла, но за одним исключением, которое удобно рассмотреть на примере работы с элементами <strong>&lt;img&gt;</strong>. Это вариация выбора элементов, с помощью "порядкового" селектора. То есть, если мы поместили в HTML ряд изображений, но нам нужно изменить параметры только одного из них, с помощью jQuery это можно сделать так:</p>
                <div id="code_block_js">
                   <p class="code">
                      $('img:first').attr('src', 'какой-то_другой_атрибут');
                   </p>
                </div>
                <h3 id="jquery_val_method" class = "pre_chap_6">Метод val()</h3>
                <p class = "post_pre_chap_6">
                   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                   Атрибут <strong>value</strong> используется в HTML в различных элементах. К примеру, при применении этого атрибута к элементу списка &lt;li&gt;, можно установить порядковый номер этого элемента. То есть, если установить, к примеру, "100", можно начинать отсчет именно с этого значения. Но с точки зрения jQuery гораздо полезнее получать <strong>value</strong>, например, из элемента &lt;input&gt;, чтобы узнать, что ввел пользователь в поле. Делается это следующим образом:
                <div id="code_block_js">
                   <p class="code">
                      $('input').val();
                   </p>
                </div>
                <p class="post_pre_chap_6">
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Соответственно, для установления нового значения, круглые скобки просто заполняются необходимым содержимым. В случае элемента &lt;input&gt; это делается, например, для очистки поля ввода для другого пользователя после того, как какой-то пользователь что-то ввел туда. Делается это точно так же, только в круглых скобках указывается пустая строка.
                </p>
                <h3 id="jquery_class_manipulation_methods" class = "pre_chap_6">Методы манипуляции классами</h3>
                <p class = "post_pre_chap_6">
                   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                   Базовые методы манипуляции классами в jQuery так же не отличаются от методов из ванильного JS и похожи названиями: <strong>'.addClass()'</strong>, <strong>'.removeClass()'</strong> и <strong>'.toggleClass()'</strong>. Как можно заметить, эти методы одинковы с методами JS после обращения к .classList. На примере того же списка, для автоматического добавления классов к его элементам с помощью jQuery можно использовать такой код:
                <div id="code_block_js">
                   <p class="code">
                      $('li:lt(3)').addClass('Первые_три_элемента');
                   </p>
                </div>
                <p class="post_pre_chap_6">
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Как вы могли заметить, в параметре селектора при обращении к элементам списка есть еще один "подселектр". Эта запись позволяет выбрать последовательность элементов, чей индекс <strong>меньше</strong> установленного. Напомню, отсчет ведется от ноля. Соответственно, в этом примере выбираются все эелементы от 0 до 2.
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Обратным от селектора <strong>:lt()</strong> существует селектор <strong>:gt()</strong>. Он выбирает все эелементы, чей индекс <strong>больше</strong> установленного.
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Все остальные манипуляции с классами абсолютно идентичны с ванильным JS, описывать их мы не будем. 
                </p>
                <h3 id="jquery_click_method" class = "pre_chap_6">Метод click()</h3>
                <p class = "post_pre_chap_6">
                   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                   Точно так же, как и в ванильном JS, у jQuery есть набор методов, которые позволяют реагировать на какие-то события. Опять же, полное и развернутое описание каждого из них кажется мне не слишком рациональным, поэтому ссылку на полный список с подробным описанием на сайте jQuery я оставлю <a id="methods" href="https://api.jquery.com/category/events/">здесь</a>.<br>
                   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Для наглядности снова обратимся к нашему ненумерованному списку. К примеру, нам нужно сделать так, чтобы при нажатии на первый элемент из списка, в браузере выводился <strong>alert</strong>. Код будет выглядеть следующим образом:
                <div id="code_block_js">
                   <p class="code">
                      $('li').first().click(function() {
                   </p>
                   <p class="sub_code">
                      alert('Вы кликнули на первый эелемент!');
                   </p>
                   <p class="code">});</p>
                </div>
                <p class="post_pre_chap_6">
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Разумеется, точно так же мы можем выбрать несколько элементов, без уточнения <strong>.first()</strong> или подобных.
                </p>
                <h3 id="jquery_keypress_method" class = "pre_chap_6">Метод keypress()</h3>
                <p class = "post_pre_chap_6">
                   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                   Эта глава не только о самом методе <strong>.keypress()</strong>, но и об остальных методах, касающихся отслеживания нажатий клавиш на клаваиатуре, таких как <strong>.keydown()</strong> и <strong>keyup()</strong>. Метод <strong>.keydown()</strong> включается сразу после того, как клавиша буквально нажата. Метод <strong>.keyup()</strong> включается сразу после того как клавиша отпущена. <strong>keypress()</strong> включается как бы между этими состояними, но есть и существенное отличие, которое состоит в том, что методы .keyup() и .keydown() будут активированы, если, к примеру, нажать сочетание клавиш Shift + 'буква' – чтобы написать большую букву, а метод .keypress() будет активирован тогда, когда будет нажата большая буква. Важным уточнением было бы то, что все эти методы работают только в том случае, если в браузере есть элемент &lt;input&gt; и они с ним взаимодействуют. К примеру, можно написать код, который бы присылал alert сообщение, если была нажата любая клавиша (перед этим, разумеется, представим, что на страницу был добавлен элемент &lt;input&gt;):
                <div id="code_block_js">
                   <p class="code">
                      $('input').keypress(function() {
                   </p>
                   <p class="sub_code">
                      alert('Вы нажали клавишу!');
                   </p>
                   <p class="code">});</p>
                </div>
                <p class="post_pre_chap_6">
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Обычно в коде требуется определить, какая именно клавиша была нажата. И если была нажата нужная нам клавиша, то в этом случае мы запускаем код. То есть, что чаще всего используется в том же эелементе &lt;input&gt;, если пользователь ввел какое-то содержимое в этот элемент, то удобнее всего было бы отправить весь заполненный материал при помощи клавиши <strong>Enter</strong>. Для этого нам нужно "слушать" событие нажатия именно этой клавиши. Для примера возьмем тот же код, но теперь в параметре исполняемой функции необходимо обозначить переменную <strong>'event'</strong>. Как мы объясним программе, какую именно клавишу нам "слушать"? Для этого в JS предусмотрена система с кодами клавишь. То есть, у каждой из клавишь на клавиатуре есть свой собственный уникальный код, прописав который, мы можем взаимодействовать далее. У клавиши Enter код "13", по нажатию на которую мы будем выводить сообщение в консоль:</p>
                <div id="code_block">
                   <p class="code">
                      $('input').keypress(function(event) {
                   </p>
                   <p class="sub_code">
                      if(event.which === 13) {
                   </p>
                   <p class="sub_sub_code">
                      concole.log('Вы нажали клавишу ENTER!');
                   </p>
                   <p class="sub_code">};</p>
                   <p class="code">});</p>
                </div>
                <h3 id="jquery_on_method" class = "pre_chap_6">Метод on()</h3>
                <p class = "post_pre_chap_6">
                   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                   Метод <strong>.on()</strong> является универсальной заменой всем event-методам, таким, как к примеру <strong>.click()</strong> или <strong>.keypress()</strong>. В этом случае, чтобы реагировать, например, на клик и менять цвет вона заголовка, код бы выглядел так:
                <div id="code_block_js">
                   <p class="code">
                      $('h3').on('click', function() {
                   </p>
                   <p class="sub_code">
                      $(this).css('background', 'red');
                   </p>
                   <p class="code">});</p>
                </div>
                <p class="post_pre_chap_6">
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Еще один сценарий, при котором можно использовать метод <strong>.on()</strong> это наведение мыши на какой-то объект. За это отвечает параметр <strong>'mouseenter'</strong>. Обратным от эффекта этого параметра выступает параметр <strong>'mouseleave'</strong>. 
                </p>
                <h3 id="jquery_effects" class = "pre_chap_6">Эффекты</h3>
                <p class = "post_pre_chap_6">
                   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                   В jQuery есть эффекты. Например, эффект плавного исчезновения какого-то элемента. Допустим, если мы хотим плавно убирать заголовки по клику, то код будет выглядеть таким образом:
                <div id="code_block_js">
                   <p class="code">
                      $('h3').on('click', function() {
                   </p>
                   <p class="sub_code">
                      $(this).fadeOut("slow");
                   </p>
                   <p class="code">
                      });
                   </p>
                </div>
                <p class="post_pre_chap_6">
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Длинтельность эффекта можно регулировать как словами (в примере выше), так и милисекундами.<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Разумеется, обратным от эффекта <strong>.fadeOut</strong> является <strong>.fadeIn</strong>, он работает ровно по такому же принципу. Однако для удобства в jQuery существует метод <strong>.fadeToggle</strong>, который работает неким переключателем.<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Блок эффектов довольно важен для технического украшения и привлекательности страницы. Поэтому <a id="methods" href="https://api.jquery.com/category/effects/">здесь</a> я так же оставлю ссылку на официальный сайт с документацией jQuery, где описаны все эффекты. 
                </p>
                <h3 id="shopping_list" class = "pre_chap_6">Приложение "Список покупок"</h3>
                <p class = "post_pre_chap_6">
                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Думаю, было бы не слишком рационально размещать в этой текстовой инситрукци целое приложение-список покупок, поэтому мы напишем его на отдельной странице. Здесь же я расскажу только о том, как всё это работает. Здесь мы развернем описание кода JS и jQuery.<br>
                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                        <div id="sl_button_text">Перейти на эту страницу можно по этой кнопке: <a target="_blank" href="shopping_list.html" id="shop_list">Перейти к списку!</a>
                        </div><br>
                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Итак. В jQuery есть отдельный метод, позволяющий реагировать на нажатие только непосредственно на тот элемент, на которое произошло нажатие, без распространения на родительские элементы. Делается это с апомощью метода <strong>'.stopPropagation()'</strong>. Для его работы необходимо задать параметр функции. Далее, чтобы распространить нажатие выше, нужно применить метод <strong>.parent()</strong>. Но что же делать с тем, что при добавлении пользователем новых эелементов, старые эелементы никуда не деваются? То есть, пользователь может добавить в список огромное количество различных пунктов, а они так и будут постоянно висеть. Для этого существует метод <strong>.remove()</strong>, который удаляет из структуры HTML документа выбранный элемент. Делается это с помощью callback-функции.<br>
                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Далее нам нужно через элемент &lt;input&gt; добавлять какой-то продукт в наш список. Делается это с помощью метода <strong>'append()'</strong>. Выглядит код таким образом: <strong>'$('ul').append(&lt;li&gt;&lt;/li&gt;)'</strong>. Ну а что бы произошло непосредственное добавление текста из input, то нужно прибавить переменную (внимательно следите за кодом ниже).<br>
                    <span class="sl_desc_span">Дописать полное описание принципа работы списка покупок!</span>
                </p>

                <div class="tom" id="tom5">
                    <h2>Том V. Bootstrap</h2>
                </div>
      
                    <h3 id="bootstrap__general" class="pre_chap_6">Общие положения</h3>
                        <p class = "post_pre_chap_6">
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Bootstrap – это популярный фрэймворк (библиотека), которая удобно, быстро и эффективно позволяет создавать адаптивные веб-страницы как для десктопного отображения, так и для мобильного. При подключении Bootstrap к странице, он вносит ряд изменений в стили, которые не соотносятся с настоящими стилями этой страницы. По этой причине я вижу рациональным для демонстрации работы Bootstrap сделать отдельную, внешнюю веб-страницу.<br>
                       <div class="bootstrap__div"></div><p class="bootstrap__p">Перейти на неё можно по кнопке далее:</p><a class="bootstrap__link" target="_blank" href="bootstrap_demo.html">Перейти к Bootstrap!</a></div><br>
                       &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Так же мне бы хотелось дополнительно с акцентировать внимание на том, что лично я в применении технологий Bootstrap не вижу фундаментального смысла. Если вы достаточно хорошо знакомы с технологиями CSS, а именно CSS Grid и CSS Flex, то это позволит вам создавать столь же адаптивные веб-старницы, но еще и более глубокой и гибкой их настройкой. В этом томе описания этой технолгии будут описаны элементы, которые лично для меня кажутся уж слишком ограничивающими, превращающие разработчика в ребенка, который в погоне за скоростью не способен самостоятельно указать даже цвет текста. В виду всего этого, описание этого фреймворка будет весьма сжатым и в [описании] будет множетсво ссылок на внешние статьи учебников, так как мне не хотелось бы тратить на это время. Если же вас заинтересует данная технология, то о ней всегда можно прочесть гораздо более исчерпывающее руководство, опять же, на том W3Schools.
                        </p>
                    <h3 id="bootstrap__responsive_design" class="pre_chap_6">Responsive Design</h3>
                        <p class = "post_pre_chap_6">
                            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Итак, как мы уже условились, ключ к красивому, а главное функциональному сайту кроется в его адаптивности, а именно, адаптивная (responsive) разметка элементов. То есть, разметка, реагирующая на различные размеры экранов устройств, на которых осуществляется загрузка веб-страницы.<br>
                            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Прежде всего, основная задача для реализации подобного функционального поведения лежит на контейнернерах. В Bootstrap контейнерами называются элементы &lt;div&gt; с классом <strong>'container'</strong>, которые содержат внутри себя какой-то элемент. Контейнеры являются основными и самыми необходимыми элементами в Bootstrap, если используется grid-система (установленная по умолчанию). 
                        </p>
                        <div class="faq_all">
                            <div class="f_img_24">
                               <img class = "faq_img" src = "/instruction/img/faq.png">
                            </div>
                            <div class="p_faq24">
                               <p class="faq_p">*для справки: grid-система – это некая сетка размещения элементов на веб-странице. То есть, весь экран веб-сайта разбивается на колонки, а элементы внутри них способны автоматически подстраиваться друг под друга. В целом, css grid-view во многом помогает в дизайне веб-страниц тем, что серьзено упрощает размещение элементов. 
                               </p>
                            </div>
                         </div>
                        <p class="post_pre_chap_6">
                            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;К примеру, с помощью техники grid-css и технологий Bootstrap мы можем разместить у себя на странице три адаптивных колонки текста одинаковой ширины, которые будут менять своё расположение в зависимости от размера экрана. Делаться это будет с помощью такого кода:
                        </p>
                        <div id="code_block_HTML">
                            <p class="code">
                                &lt;div class="container"&gt;
                            </p>
                            <p class="sub_code">
                                &lt;div class="row"&gt;
                            </p>
                            <p class="sub_sub_code">
                                &lt;div class="col-sm"&gt;
                            </p>
                            <p class="sub_sub_sub_sub_sub_code">
                                Одна из трех колонок
                            </p>
                            <p class="sub_sub_code">
                                &lt;/div&gt;
                            </p>
                            <p class="sub_sub_code">
                                &lt;div class="col-sm"&gt;
                            </p>
                            <p class="sub_sub_sub_sub_sub_code">
                                Одна из трех колонок
                            </p>
                            <p class="sub_sub_code">
                                &lt;/div&gt;
                            </p>
                            <p class="sub_sub_code">
                                &lt;div class="col-sm"&gt;
                            </p>
                            <p class="sub_sub_sub_sub_sub_code">
                                Одна из трех колонок
                            </p>
                            <p class="sub_sub_code">
                                &lt;/div&gt;
                            </p>
                            <p class="sub_code">
                                &lt;/div&gt;
                            </p>
                            <p class="code">
                                &lt;/div&gt;
                            </p>
                        </div>
                    <h3 id="bootstrap__grid" class="pre_chap_6">Grid</h3>
                        <p class = "post_pre_chap_6">
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Grid-cистема построена с помощью flexbox свойства и позволяет создавать до 12ти колонок по ширине страницы. Если использовать все 12 колонок нет необходимости, их можно группировать вместе, для создания более широкого пространства для контента. Как говорилось выше, grid-система адаптивна, то есть, чувствительна к ширине – колонки переустанавливаются (перераспределяются) автоматически, в зависимости от ширины экрана устройства.
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;В Bootstrap есть набор классов, которые позволяют использовать и настраивать grid-систему, их всего пять и это:
                        </p>
                        <ul class="list_10">
                            <li><strong>.col-</strong><span class="grid__li li__1"> – используется для очень маленьких девайсов, ширина экрана которых меньше 576px;</span></li>
                            <li><strong>.col-sm-</strong><span class="grid__li li__2"> – используется для маленьких устройств, ширина экрана которых равна или больше 576px;</span></li>
                            <li><strong>.col-md-</strong><span class="grid__li li__3"> – ширина экрана равна или больше 768px;</span></li>
                            <li><strong>.col-lg</strong><span class="grid__li li__4"> – большие устройства, ширина которых равна или больше 992px;</span></li>
                            <li><strong>.col-xl-</strong><span class="grid__li li__5"> – очень большие девайсы, ширины которых равна или больше 1200px;</span></li>
                        </ul>
                        <p class="post_pre_chap_6">
                            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Классы, описанные выше, могут комбинироваться. Подводя итог, структура Bootstrap Grid выглядит следующим образом: сначала размещаются элементы <strong>&lt;div&gt;</strong> класса <strong>''raw</strong>, то есть, строки, а в этих эементах &lt;div&gt; уже, соответсвенно, располагать колнки разных классов, описанных в списке выше. Прописывать полное название классов не обязательно, Bootstrap может делать это автоматически, выставляя нужную ширину колонок. То есть, если установлено два элемента в контейнере с классом <strong>'.raw'</strong>, то ширина колонок будет выставлена в 50%, если три то 33.33% и так далее.<br>
                            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Если нужно работать <strong>НЕ</strong> автоматически, то запись класса, внутри контейнера с классом <strong>'raw'</strong> будет выглядеть так: <strong>'&lt;div&gt; class="col-*-*"'</strong>, где первая звездочка означает значение адаптивности, то есть, тот элемент, который мы указывали в списке выше (к примеру, -sm). Вторая звездочка отображает число колонок, которое может изменяться, от одной до двенадцати для каждой строки.<br>
                            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;По подробнее остановившись на основных контейнерах для Bootstrap скажу, что есть два их типа: уже описанный <strong>'.container'</strong> – предоставляет фиксированную ширину контейнера и <strong>'.container-fluid'</strong> – предоставляет ширину контейнера, который заполняет всю ширину экрана.
                        </p>
                        <h3 id="bootstrap__topography" class="pre_chap_6">Topography</h3>
                        <p class = "post_pre_chap_6">
                            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Topography – это оформление контента, в Bootstrap для этого есть установки по умолчанию:
                        </p>
                            <ul class="list_10">
                                <li>Для текста по умолчанию используется размер 16px, высота строки 1.5 и семейство шрифтов – Helvetica New, Helvetica, Arial, sans-serif;</li>
                                <li> У всех элементов &lt;p&gt; свойство <strong>margin-top</strong> установлено на '0', а свойство <strong>margin-bottom</strong> на 1rem (то есть, 16px);</li>
                                <li>У элементов заголовков:
                                    <ul class="sub_list_7">
                                        <li>Заголовок h1 имеет значение в 2.5rem (40px);</li>
                                        <li>Заголовок h2 имеет значение в 2rem (32px);</li>
                                        <li>Заголовок h3 имеет значение в 1.75rem (28px);</li>
                                        <li>Заголовок h4 имеет значение в 1.5rem (24px);</li>
                                        <li>Заголовок h5 имеет значение в 1.25rem (20px);</li>
                                        <li>Заголовок h6 имеет значение в 1rem (16px);</li>
                                    </ul>
                                </li>
                            </ul>
                            <p class="post_pre_chap_6">
                                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Так же для заголовков можно использовать класс <strong>.display-</strong> (со значением от одного до шести) и с помощью него задавать размер и толщину текста для заголовка. Кроме того, при работе с заголовками можно использовать HTML элемент <strong>&lt;small&gt;</strong>, который позволяет создавать текст второстепенного значения прямо внутри заголовка – текст будет немного меньше и тоньше.<br>
                                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Элемент <strong>&lt;mark&gt;</strong> добавляет желтоватый фон для текста, так, будто его выделяет неких маркер светлого оттенка. Элемент <strong>&lt;abbr&gt;</strong> добавляет тексту нижнее подчеркивание точками.
                                <div class="operators__a">
                                    <a id="operators" target="_blank" href="https://www.w3schools.com/bootstrap/bootstrap_typography.asp"><span class="here">Здесь</span></a>
                                </div>
                                <p id="p_operators">&nbsp;вы можете подробнее прочесть про различные классы Bootstrap Topography на сайте W3Schools.</p>
                                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Так же Bootstrap позволяет использовать набор классов для добавления цветов текста. Если вы хоть немного значете CSS, то смысла в настолько глубоком применении Bootstrap на своей веб-странице я не вижу.<br><br>
                                <div class="operators__a">
                                    <a id="operators" target="_blank" href="https://www.w3schools.com/bootstrap/bootstrap_typography.asp"><span class="here">Здесь</span></a>
                                </div>
                                <p id="p_operators">&nbsp;тоже на сайте W3Schools вы можете прочесть про все классы, позволяющие работать с цветами в Bootstrap.</p>
                                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Там же можно прочесть и про классы, позволяющие задать цвет фона. Подробнее про то, как может выглядеть текст с применением подобных классов, а так же про применение других классов, задающих оформление, смотрите по ссылке Bootstrap из главы "Общие положения".
                            </p>
                        <h3 id="bootstrap__nav__bar" class="pre_chap_6">Nav Bar</h3>
                        <p class = "post_pre_chap_6">
                            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                        </p>
                        <h3 id="bootstrap__forms__tables" class="pre_chap_6">Формы и таблицы</h3>
                        <p class = "post_pre_chap_6">
                            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                        </p>
                        <h3 id="bootstrap__" class="pre_chap_6"></h3>
                        <p class = "post_pre_chap_6">
                            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                        </p>
                        <h3 id="bootstrap__" class="pre_chap_6"></h3>
                        <p class = "post_pre_chap_6">
                            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                        </p>
          <div class="final">
                  <p class="tobe" id="tobe">To Be Continued...<br>//документ в разработке//</p>
                  <hr class="hr_final" id="bottomm">
                  <p class="final">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Конечно, абсолютно всю информацию бывает весьма сложно уместить на какую-то примитивную веб-страницу, тем более, учитывая уровень навыков того, кто в данный момент её создает. Поэтому предлагаю выход!<br>
                  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;В этом списке представлены некоторые внешние интернет-ресурсы, где можно найти остальную, безграничную информацию по фронтенд/бэкэнд разработке, полный объем которой простому смертному невозможно уместить на одной web-странице:
                  </p>
                  <ol class="list_final">
                      <li class="li_final"><a class="a_bottom" href="https://html5book.ru/html-html5/">Это</a>&nbsp;&nbsp;&nbsp;<ins>HTML5</ins> Book – справочник не только по HTML5, но и по CSS, а так же JavaScript;</li>
                      <li class="li_final"><a class="a_bottom" href="https://developer.mozilla.org/ru/docs/Web/HTML">А это</a>&nbsp;&nbsp;<ins>MDN</ins> – популярный во всём мире ресурс-форум для web-development'a;</li>
                      <li class="li_final"><a class="a_bottom" href="https://www.w3schools.com/html/html_formatting.asp">Здесь</a> &nbsp;очень известный и очень мощный справочник по web-dev'у – это<ins>W3Schools</ins>;</li>
                  </ol>
          </div>
  
            <div id="div_table_of_contents">
               <p id="table_of_contents_down"><a href="#table_of_contents_down" id="table_of_contents_down_a">Нижнее оглавление</a></p>
               <ul id="top_ul">
                  <li><a href="#table_of_contents_up" id="header_table">Верхнее оглавление</a></li>
                  <p id="table_up_down"><a href="#table_of_contents_downer_bot" id="table_of_contents_upper_bot">Нижняя часть оглавления</a></p>
                  <p id="table_up_down"><a href="#main_h1">Красивое слово "Инструкция"</a></p>
                  <p id="table_up_down"><a href="#introduction">Введение</a></p>
                  <li>
                     <a href="#tom1" id="header_table">Том I. HTML5</a>
                     <ul id="decor">
                        <li><a href="#general_html">Общие положения</a></li>
                        <li><a href="#lists">Списки и инструменты форматирования документа</a></li>
                        <li><a href="#tables">Таблицы</a></li>
                        <li><a href="#tags">Ссылки</a></li>
                        <li><a href="#forms">Формы</a></li>
                        <li><a href="#semant">Видео, аудио и семантические элементы</a></li>
                     </ul>
                  </li>
                  <li>
                     <a href="#tom2" id="header_table">Том II. CSS</a>
                     <ul id="decor">
                        <li><a href="#general_css">Общие положения</a></li>
                        <li><a href="#advanced_selectors">Немного о продвинутых селекторах</a></li>
                     </ul>
                  </li>
                  <li>
                     <a href="#tom3" id="header_table">Том III. JavaScript</a>
                     <ul id="decor">
                        <li><a href="#general_js">Общие положения</a></li>
                        <li><a href="#variables">Переменные в JavaScript</a></li>
                        <li><a href="#built_methods">Встроенные методы</a></li>
                        <li><a href="#order_operators">Порядок операторов в JavaScript</a></li>
                        <li><a href="#if_else">Условные операторы в JavaScript. If/Else</a></li>
                        <li><a href="#ternary">Тернарный оператор</a></li>
                        <li><a href="#switch">Оператор Switch</a></li>
                        <li><a href="#while">Цикл While</a></li>
                        <li><a href="#for">Цикл For</a></li>
                        <li>
                           <a href="#finctions">Функции</a>
                           <ul>
                              <li><a href="#function_param">Параметры (аргументы) функции</a></li>
                              <li><a href="#returns">Возвращаемые значения функции</a></li>
                              <li><a href="#statements">Statemens vs. Expressions</a></li>
                              <li><a href="#func_ex">Различные примеры реализации функций</a></li>
                           </ul>
                        </li>
                        <li><a href="#area_of_vis">Область видимости пеерменных</a></li>
                        <li>
                           <a href="#massives">Массивы</a>
                           <ul>
                              <li><a href="#massive_methods">Методы массивов</a></li>
                           </ul>
                        </li>
                        <li><a href="#objects">Объекты</a></li>
                        <li><a href="#objects_massives">Массивы или объекты?</a></li>
                        <li>
                           <a href="#objects_methods">Методы объктов</a>
                           <ul>
                              <li><a href="#this">'this' в методе объекта</a></li>
                           </ul>
                        </li>
                        <li>
                           <a href="#dom">DOM</a>
                           <ul>
                              <li><a href="#dom_selectors">DOM. Селекторы</a></li>
                              <li><a href="#dom_changing_content">DOM. Изменение контента</a></li>
                              <li><a href="#dom_changing_styles">DOM. Изменение стилей</a></li>
                              <li><a href="#dom_changing_attributes">DOM. Изменение атрибутов</a></li>
                              <li><a href="#dom_events">DOM. Events</a></li>
                           </ul>
                        </li>
                        <li><a href="#js_game">Финал JS. Игра на реакцию на web-странице</a></li>
                     </ul>
                  </li>
                  <li>
                     <a id="header_table" href="#tom4">Том IV. jQuery</a>
                     <ul id="decor">
                        <li><a href="#jquery_basics">Общие положения</a></li>
                        <li><a href="#jquery_selector">Селектор</a></li>
                        <li><a href="#jquery_css_method">Метод css()</a></li>
                        <li><a href="#jquery_html_method">Метод html()</a></li>
                        <li><a href="#jquery_attr_method">Метод attr()</a></li>
                        <li><a href="#jquery_val_method">Метод val()</a></li>
                        <li><a href="#jquery_click_method">Метод click()</a></li>
                        <li><a href="#jquery_keypress_method">Метод keypress()</a></li>
                        <li><a href="#jquery_on_method">Метод on()</a></li>
                        <li><a href="#jquery_effects">Эффекты</a></li>
                     </ul>
                  </li>
                  <li>
                    <a id="header_table" href="#tom5">Том V. Bootstrap</a>
                     <ul id="decor">
                        <li><a href="#bootstrap__general">Общие положения</a></li>
                        <li><a href="#bootstrap__responsive_design">Responsive Design</a></li>
                        <li><a href="#bootstrap__grid">Grid</a></li>
                        <li><a href="#bootstrap__topography">Topography</a></li>
                        <li><a href="#bootstrap__nav__bar">Nav Bar</a></li>
                        <li><a href="#bootstrap__forms__tables">Формы и таблицы</a></li>
                        <li><a href="#"></a></li>
                        <li><a href="#"></a></li>
                        <li><a href="#"></a></li>
                        <li><a href="#"></a></li>
                        <li><a href=""></a></li>
                     </ul>
                  </li>
                  <li><a href="#bottomm" id="header_table">Конец</a></li>
                  <li><a href="#clockers" id="header_table">Часы</a></li>
                  <p id="table_up_down"><a href="#table_of_contents_down" id="table_of_contents_downer_bot">Верхняя часть оглавления</a></p>
               </ul>
            </div>
  
  
              <div class="clock_all" id="clockers">
                  <div class="light"><span id="span"></span></div>
                  <div class="clock">
                      <div class="hour">
                          <div class="hr" id="hr"></div>
                      </div>
                      <div class="min">
                          <div class="mn" id="mn"></div>
                      </div>
                      <div class="sec">
                          <div class="sc" id="sc"></div>
                              <script type="text/javascript">
                                  const deg=6;
                                  const hr = document.querySelector('#hr');
                                  const mn = document.querySelector('#mn');
                                  const sc = document.querySelector('#sc');
                                              setInterval(() => {
                                                                  
                                      let day = new Date();
                                      let hh = day.getHours() * 30;
                                      let mm = day.getMinutes() * deg;
                                      let ss = day.getSeconds() * deg;
  
                                  hr.style.transform = `rotateZ(${(hh)+(mm/12)}deg)`;
                                  mn.style.transform = `rotateZ(${mm}deg)`;
                                  sc.style.transform = `rotateZ(${ss}deg)`;
                                  })
                                                      
                              </script>
                      </div>
  
                  </div>
              </div>


    </body>

</html>
